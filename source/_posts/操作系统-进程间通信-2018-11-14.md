---
title: 操作系统--进程间通信(一)
date: 2018-11-14 22:13:04
tags:
    - 操作系统
---
## IPC 运用范畴
![avatar](https://github.com/Yejy813/pictures/blob/master/Snipaste_2018-11-12_22-04-22.png?raw=true)
> **配图与本文无关，纯属有趣**

相对于做点什么，我们更想睡懒觉，但是相对于睡觉，我想写总结！
今天把博客的 `git` 分支搞混了，浪费了一点时间。那么今天介绍一下进程间通信(`IPC`) 。进程间通信，我们从 << `UNIX`网络编程卷2：进程间通信 >> 最后一章 **Sun RPC** 谈起，那为什么呢？ 因为我们去掌握一个东西，肯定是因为它有价值，我们才去学习，如果一些技术现在都不用了，淘汰了，那我们就没有必要去深究，只需学习其思想，浅尝辄止即可。
<!-- more -->
最后一张概述部分是这样介绍的，构筑一个应用程序时，我们首先在以下两者之间作出选择：
>  (1) 构筑一个庞大的单一程序，完成全部工作；
>  (2) 把整个应用程序散步到彼此通信的多个进程中。
如果我们选择后者，接下去的抉择是：
>>   (2a) 假设所有进程运行在同一台主机上 (允许 `IPC` 用于这些进程间的通信)；
>>   (2b) 假设某些进程会运行在其他主机上 (要求使用进程间某种形式的网络通信)。

这本著作主要关注的是 `2a` 这种情况，也就是 **使用`消息传递`、`共享内存`、并可能使用某种形式的`同步`来进行同一台主机上的进程间 `IPC`**。同一进程内不同线程间的 `IPC` 以及不同进程内各个线程间的 `IPC`只是这种情形的特殊情况。

而对于不同部分之间需要网络通信的应用程序则大多数使用 **显示网络编程**（`explicit network programming`)方式编写，也就是我们现在流行的 `Socket`编程。

那么现在是什么情况呢？ 由于互联网大火，导致现在主流热门的进程间通信方式变成了使用 `Socket` 套接字通信。这个也可以理解，由于互联网就是传统的 `C/S`(服务器端-客户端)架构，对于客户端开发来说，主要就是移动应用开发、`PC`端应用开发、Web 浏览器开发，这些是互联网主要的流量入口，应用和浏览器需要通信的对象就是服务器，服务器要做的也是和客户端更好的进行通信，所以如果需要从事互联网的工作，那么对 `Socket` 编程相对于其他 `IPC` 手段就需要更熟悉，特别是服务器后台开发，客户端还好，客户端业务逻辑和 `UI` 体验相对重要，至于一些系统层技术，开发框架都已经封装的很好了，只需掌握使用方法就可以，像`android` 、 `IOS`开发。但是如果你是从事系统开发，那么所有的 `IPC` 方式都需要了解，特别是`消息传递`、`共享内存`需要深入了解。

## 具体的 IPC 手段
### 信号
软件中断通知事件处理 例如：SIGFPE, SIGKILL, SIGUSR1, SIGSTOP, SIGCONT
接收到信号会发生什么：
* Catch：指定信号处理函数被调用
* Ignore：依靠操作系统的默认操作
    example：Abort，memory dump，suspend or resume process
* Mask：闭塞信号，因此不会发生
    可能是暂时的（处理同样类型的信号）

不足：不能传输要交换的任何数据

特点：
* signals are only delivered between processes when either:  仅在同一个用户的进程间传递，或者超级用户发出信号
    1. the processes involved are run by the same user
    2. the raising process is run by a superuser
* signal types and type names are defined in signal.h 定义在 signal.h 文件
* signals are not queued   信号没有排队
* handlers "terminate process" (SIG_DFL) and "ignore signal" (SIG_IGN) are already defined in signal.h 常用终止进程和忽略信号定义在 signal.h


`unix` 主要接口信息：
``` c++
 #include: signal.h

 functions：void raise(int sig_type)
 description：用信号sig_type发信号。

 functions：void signal(int sig_type, void (*sig_handler)(int signal_type))
 description：sig_type是signal.h中定义的信号值（或名称）之一。 sig_handles是一个指向带有int参数的函数的指针。当进程被指定类型的信号命中时，此函数将在进程上下文中运行。

 functions：int kill(pid_t dest_pid, int sig_type)
 description：向使用PID dest_pid运行的进程发送sig_type类型的信号。 dest_pid的特定类型0和-1 make kill（）分别发送与发送方的同一组执行的所有进程，并发信号通知系统中运行的所有进程（仅适用于超级用户凭据)。
```

### 管道和FIFO
**1.管道，通常指无名管道，是 `UNIX` 系统`IPC`最古老的形式**。
特点：
* pipes are uni-directional  半双工
* with file descriptors, they can only be shared between processes with parent-child relationship 只能用于父子进程间
* atomicity is guaranteed for messages shorter than PIPE_BUF bytes  特定大小缓存保持原子性
* alf-open pipes are told widowed (or broken) pipes. Writing on them causes a write error, reading from them always returns 0 bytes.  坏的管道，会出现写错误，读取时，返回0字节.

`unix` 主要接口信息：
``` c++
 #include: unistd.h
 functions： int pipe(int *fd_couple)  
 description：创建一个管道并将其文件描述符存储到fd_couple [0]（读取结束）和fd_couple [1]（写入结束）。 
 return： 成功返回 0，错误返回 -1
```

模拟使用场景，实现 `Linux` 系统调用 `popen`，主要代码：
```c++
FILE * vpopen(const char * cmdstring, const char * type)
{
    int pfd[2];
    FILE * fp;
    pid_t pid;

    if ((type[0] != 'r' && type[0] != 'w') || type[1] != 0)
    {
        errno = EINVAL;
        return (NULL);
    }

    if(pipe(pfd) != 0)
    {
        return NULL;
    }

    if((pid = vfork()) < 0) // vfork 相对于fork区别是: vfork需要等待子进程执行完后才开始执行，两者共享地址空间
    {
        return NULL;
    }
    else if(pid == 0) // 子进程
    {
        if(*type == 'r')
        {
            close(pfd[0]);
            if (pfd[1] != STDOUT_FILENO)
            {
                dup2(pfd[1], STDOUT_FILENO);
                close(pfd[1]);
            }
        }
        else 
        {
            close(pfd[1]);
            if (pfd[0] != STDIN_FILENO)
            {
                dup2(pfd[0], STDIN_FILENO);
                close(pfd[0]);
            }
        }

        if(execl("/bin/bash", "bash", "-c", cmdstring, (char *) 0) < 0)
        {
            return NULL;
        }
    }

    wait(0); // 等子进程结束，回收子进程

    if (*type == 'r')
    {
        close(pfd[1]);
        if ((fp = fdopen(pfd[0], type)) == NULL)
        {
            return (NULL);
        }
    }
    else
    {
        close(pfd[0]);
        if ((fp = fdopen(pfd[1], type)) == NULL)
        {
            return (NULL);
        }
    }

    return (fp);
}
```
**2.有名管道，FIFO，**
特点：
* 每个FIFO有一个路径名与之关联，允许无亲缘关系进程间的通信  
* 拥有标准管道的属性和特征

`unix` 主要接口信息：
```c++
 *  #include: sys/types.h and sys/stat.h
 *  functions： int mkfifo(char *path, mode_t mode) 
 *  description：path是要创建的FIFO文件的（路径+）名称。 mode是文件权限（请参阅umask（2）和chmod（2））
 *  return： 成功返回 0，错误返回非 0
```

模拟使用场景：
```c++
 * 模拟场景
 *  1. 在 shell 端使用命令创建有名管道： mkfifo /tmp/named_pipe
 *  2. 运行该接口
 *  3. 在 shell 端写入数据到管道 ：echo "hey, this is a message" > /tmp/named_pipe
 *  4. 测试完毕，删除管道： rm /tmp/named_pipe
 * 
 *  当然我们也可以自己启动一个任意进程向FIFO管道里面写数据
```
具体实现代码：
```C++
int fifo_read()
{
    int pipe;
    char ch;
    static char TmpCh;

    /* we expect a named pipe has been created
     * in /tmp/named_pipe . The command
     *   $ mkfifo /tmp/named_pipe
     * is a friend to get to this point
     */

    pipe = open("/tmp/named_pipe", O_RDONLY);
    if (pipe < 0) {
        printf("open fifo error, maybe you should create a fifo first !\n");
        exit(1);
    }
        
    /* preparing to read from the pipe... */
    printf("Waiting data from the pipe... \n");

    /* reading one char a time from the pipe */
    while (1) {
        if (read(pipe, &ch, 1) < 0) {
            printf("Read the pipe failed! \n");
            exit(2);
        }
        

        if(ch != TmpCh)
        {
            printf("%c", ch);
        }

        TmpCh = ch;
    }
    
    /* leaving the pipe */
    close(pipe);
    
    return 0;
}
```
## 总结
上述主要对`IPC`做了一个大体的介绍，以及介绍了信号(signal)和管道两种`IPC`方式，这两者在`Linux`系统自带功能实现中用的较多。至于 `Posix`和 `System V`的进程间通信方式 **消息队列**，**信号**和 **共享内存**，由于内容较多后面再单独介绍。

