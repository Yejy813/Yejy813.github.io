---
title: 操作系统--进程管理(二)
date: 2018-11-03 08:13:53
tags: 操作系统
---

## 进程状态(State)

![avatar](https://github.com/Yejy813/pictures/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE.png?raw=true)

**操作系统通过维护进程状态队列，来对进程进行管理**。
>  状态队列：
>  * 由操作系统来维护一组队列，用来表示系统当中所有进程的当前状态；
>  * 不同的状态分别用不同的队列来表示(就绪队列，各种类型的阻塞队列)；
>  * 每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生改变时，它的PCB从一个队列中
>    脱离出来，加入到另一个队列。
<!-- more -->
### 进程的生命周期管理
```
    * 进程创建
      引起进程创建的三个主要事件：
      * 系统初始化时;(创建init进程，负责创建其他新的进程)
      * 用户请求创建一个新进程；
      * 正在运行的进程执行了创建进程的系统调用；

    * 进程运行
      内核选择一个就绪进程，让它占有处理机并执行（涉及相关调度算法，来满足如何选择进程何时来执行）

    * 进程等待
      在以下情况下，进程等待(阻塞)：
        1. 请求并等待系统服务，无法马上完成(例如：执行I/O，请求硬盘时)
        2. 启动某种操作，无法马上完成(需要等待其他进程完成某个操作才可以执行)
        3. 需要的数据没有到达
      进程一旦由运行态转换成等待状态就不占有CPU了，那么其他就绪进程就可以占有CPU执行。进程等待(阻塞)只能由进程自己触发，
      因为只有进程自己知道才能知道何时需要等待某种事件的发生。

    * 进程唤起（由阻塞态转换为就绪态）
      唤醒进程的原因：
        1. 被阻塞进程的需要的资源得到满足
        2. 被阻塞进程等待的事件可达
        3. 将该进程的PCB插入到就绪队列
      进程只能被别的进程或者操作系统唤醒

    * 进程结束

```
### 进程的状态变化模型

![avatar](https://github.com/Yejy813/pictures/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E9%98%9F%E5%88%97.png?raw=true)

> 进程的三种基本状态：
> 进程在生命结束前处于且仅处于三种基本状态之一，不同系统设置的进程状态数目不同。
>+      运行状态(Running)：当一个进程正在处理机上运行时。
>+      就绪状态(Ready): 一个进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。
>+      等待状态(又称阻塞状态Blocked)：一个进程正在等待某一事件而暂停运行时。如等待某资源，等待输入/输出完成。

### 进程的挂起模型

>    进程在挂起状态时，意味着进程没有占有内存空间，处在挂起状态的进程映像在磁盘上。
>    挂起状态：
>*   阻塞挂起状态(Blocked-suspend)：进程在外存并等待某事件的出现
>*   就绪挂起状态(Ready-suspend)：进程在外存，但只要进入内存即可运行

## 进程调度算法
1. **FCFS: first come fist server (先来先服务)**
```
    优点：简单
    缺点：
    * 平均等待时间波动较大
    * 花费时间少的任务可能排在花费时间长的任务后面
    * 可能导致I/O和CPU之间的重叠处理
```
2. **SPN/SRT : 短任务优先**
```
    按照预测的完成时间来将任务入队。
    可以是可抢占的或者不可抢占的，可抢占：又叫shortest-Remaining-Time(SRT) (最短剩余时间)

    优点：不公平，最优平均等待时间
    缺点：
    * 优先考虑短时间进程，可能导致饥饿
    * 需要预知未来，如何预估进程执行时间长短(根据过去预估未来)
```
3. **HRRRN : 最高响应比优先 (在SPN基础上改进)**
```
    R = (W + S)/S  
    W ：waiting time 等待时间
    S ：service time 执行时间
    选择R值最高的进程，充分考虑了进程等待的时间，缓解饥饿现象，不可抢占
```
4. **Round Robin 轮循调度算法**
```
    在叫作时间切片的离散单元中分配处理器，时间片结束时，切换到下一个准备好的进程

    经验规则：维持上下文切换开销处于1%以内，99%的时间用在实际进程执行中

    优点：公平
    缺点：平均等待时间较差
```
5. **MLFQ 多级反馈队列**
```
 动态的根据进程执行的过程，操作系统可以根据进程具有cpu密集型和I/O密集型的特征来动态的调整进程优先级
```
6. **Fair-share scheduling 公平共享调度**
```
 使得用户的请求在不同的级别享受公平调度，是在进程级别还是用户级别或者用户组级别公平的共享进程的调度
```
