<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CMake]]></title>
    <url>%2F2019%2F01%2F26%2FCMake%2F</url>
    <content type="text"><![CDATA[CMake 介绍 CMake 是一个开源的跨平台工具系列，旨在构建，测试和打包软件。 CMake 用于使用简单的平台和独立于编译器的配置文件来控制软件编译过程，并生成可在你选择的编译器环境中使用的本机 makefile 和工作空间。 CMake 是个开源的跨平台自动化建构系统，它用组态文档控制建构过程（build process）的方式和 Unix 的 Make 相似，只是 CMake 的组态文档取名为 CMakeLists.txt。CMake 并不直接建构出最终的软件，而是产生标准的建构档（如 Unix 的 Makefile 或 Windows Visual C++ 的 projects/workspaces），然后再依一般的建构方式使用。这使得熟悉某个集成开发环境（IDE）的开发者可以用标准的方式建构他的软件。CMake 可以编译源代码、制作程序库、产生适配器（wrapper）、还可以用任意的顺序建构可执行文件。CMake 支持 in-place 建构（二进档和源代码在同一个目录树中）和 out-of-place 建构（二进档在别的目录里），因此可以很容易从同一个源代码目录树中建构出多个二进档。CMake 也支持静态与动态程序库的建构。 CMake 特点主要有： 开放源代码，使用类 BSD 许可发布。 https://cmake.org/licensing 跨平台，并可生成 native 编译配置文件，在 Linux/Unix 平台，生成 makefile，在苹果平台，可以生成 xcode，在 Windows 平台，可以生成 MSVC 的工程文件。 能够管理大型项目。我所在公司的项目代码就是用 CMake 构建的，代码量大概 140 万行。 简化编译构建过程和编译过程。CMake 的工具链非常简单：cmake+make。 高效虑，相对其他构建体系，构建速度上有优势。 可扩展，可以为 CMake 编写特定功能的模块，扩充 CMake 功能。 CMake 缺点 CMake 很简单，但是没有想象中的简单，比如知乎网友神评论：”屠龙的英雄，自己也已经成为了龙”。CMake 编写的过程实际就是编程的过程，我们编写的是 CMakeLists.txt (每个目录一个), 使用的是 “CMake 语言和语法”。 项目构建步骤： 为每个代码目录编写 CmakeLists.txt。 执行命令“cmake PATH”或者“ccmake PATH”生成 Makefile ( PATH 是 CMakeLists.txt 所在的目录 )。 使用 make 命令进行编译。 看构建步骤是不是感觉 CMake 很简单，相对于 MakeFile 编写来说确实如此，想想看, 如果一份代码中包含数十个 Project，然后每个 Project 中文件夹数目也很多，这时候我们如果使用 MakeFile 构建整份代码，那我们需要编写的依赖项会十分繁重且复杂，想想都头大，但是 CMake 却能够通过简单且直观的 cmake-commands 来帮你编写出你想要的 MakeFile 文件，最后只需简单的执行一步 make 指令，便可以完成整份代码的编译。反正我自从开始写 CMake 以后，就不写 MakeFile 了。 CMake 安装CMake 目前已经成为各大 Linux 发行版提供的组件，基本不需要我们手动安装，Linux 系统下，执行 cmake --version，如果可以看到版本号，就说明已经安装, 如果觉得版本太旧，想要更新，可以从官网下载。 https://cmake.org/download/ CMake 官方文档CMake 为我们提供了一个官方文档，其中将 CMake 整体进行了一下内容的划分，该文档可以作为我们的一个帮助手册，仅仅作为查阅指令的功能，因为官方并没有为我们提供使用的 example，而是提供了 CMake 的相关课程和书籍 &lt;&lt; mastering CMake &gt;&gt;，当然这些事需要付费的。 官方文档 (3.13版本)： https://cmake.org/cmake/help/v3.13/index.html 具体目录如下： Command-Line Tools 提供了三种命令行工具，除了cmake，还有测试和打包工具 cmake(1) ctest(1) cpack(1) Interactive Dialogs 交互式对话，一般用命令行工具就够了 cmake-gui(1) ccmake(1) Reference Manuals 参考手册 cmake-buildsystem(7) 构建系统 cmake-commands(7) 指令 cmake-compile-features(7) 编译功能 cmake-developer(7) 为开发人员修改 cmake 源代码树本身以及创作外部维护模块的人员参考 cmake-env-variables(7) 环境变量 cmake-generator-expressions(7) cmake 生成器表达式 cmake-generators(7) cmake 生产器 cmake-language(7) 语言 cmake-modules(7) 模块 cmake-packages(7) 包 cmake-policies(7) 策略 cmake-properties(7) 属性 cmake-qt(7) qt相关 cmake-server(7) 服务器 cmake-toolchains(7) 工具链 cmake-variables(7) 变量 cpack-generators(7) cpack 生成器 Release Notes CMake Release Notes 发布版本说明 列出这个目录，只是为了提醒，我们需要有阅读英文文档的能力，因为开源项目基本都是以英文形式发布的，所以我们必须养成习惯，不懂得地方借助 google 翻译，慢慢就能看懂了。 这边有位博友翻译过，可以参考一下：https://www.cnblogs.com/coderfenghc/archive/2012/06/16/CMake_ch_01.html Hello CMake下面从最简单的程序介绍如何构建 CMake 工程，然后慢慢引入 CMake 的各项特性。 C++代码先使用 CMake 尝试构建单文件的工程，工程只有 main.cpp 一个文件：123456#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; "Hello CMake!" &lt;&lt; std::endl; return 0;&#125; CMakeLists.txt在 main.cpp 的同一目录下，新建一个文本文件，命名为 CMakeLists.txt，内容如下：12345678project(Hello_CMake)cmake_minimum_required (VERSION 2.8.12) set(SRC_FILES main.cpp)add_executable(hellocmake $&#123;SRC_FILES&#125; ) 解释一下上面的 CMake: CMake 中，以命令为单位执行动作，命令不区分大小写。project 命令声明工程的名称，同时会添加一些变量（支持的语言，不写默认支持所有），CMake 管理的每个工程都需要有 project 命令。cmake_minimum_requried 声明最小要求，可以是 CMake的版本，也可以是其他的条件，这里要求使用 CMake 最低版本为2.8.12 。set 命令用来给设置变量，set 的第一个参数为变量名，其后的所有参数都将放入到这个变量中，参数可以有多个，需要注意与命令不同，CMake 的变量是区分大小写的。add_executable 命令可以增加一个目标来生成可执行文件，第一个参数为目标名称，之后的参数为源代码文件列表，源代码可以有多个。例子中使用了变量内容作为源代码，也可以直接填上源代码路径。如果在 CMakeLists.txt 中需要引用变量中的内容，需要使用 ${Var} 来展开，如例子中的 ${SRC_FILES} 将会展开成main.cpp ，如果不使用 ${}，SRC_FILES 将会被当做一般的字符串处理。 编译CMake 支持原地编译和分离编译两种方法编译，分离编译可以使编译中间文件和最终文件和源代码分离，便于源代码的管理，所以CMake 这里介绍分离编译方法。我的源代码和CMakeLists.txt放在cmakedemo目录下。 先将工作目录切换到源代码目录的上一层cd ..创建一个编译目录，并进入该目录mkdir buildcmakedemo &amp;&amp; cd buildcmakedemo在该目录下使用cmake配置工程，生成makefilecmake ../cmakedemo使用make编译工程make在编译目录下就生成了hellocmake，./hellocmake可以执行。cmake命令可以解析CMakeLists.txt生成makefile，还可以传入给项目一些变量，控制编译过程，在后面会详细介绍。 最终的目录结构：12345[root@yejy cmakedemo]# tree.|-- buildcmakedemo # 编译目录`-- cmakedemo # 源代码目录 `-- main.cpp 子目录和库多数工程是分为多个模块的，每个模块处在不同的目录中，CMake 中可以使用命令 add_subdirectory 添加子目录，子目录继承父目录所有的属性和变量。现在为我们的 HelloCMake程序加点料。 在源代码目录新建文件夹 child，在 child 中新建源代码文件 lib.cpp 内容如下123456#include &lt;iostream&gt;void call_child()&#123; std::cout &lt;&lt; "Oh My Lady Gaga!" &lt;&lt; std::endl; return 0;&#125; 在 child 下创建文本文件 CMakeLists.txt，内容如下：12345set(SRC_FILES lib.cpp)add_library(child $&#123;SRC_FILES&#125;) add_library 命令与 add_executable 类似，但生成的是库文件，CMake 默认会生成静态库，如果需要生成动态库，可以目标名后添加 SHARED 关键字，add_library(child SHARED ${SRC_FILES})，这样就会生成动态库。 我们还要为 child 这个库提供一个头文件，在 child 目录下新建一个头文件lib.h，然后在文件中声明call_child()。1void call_child(); 修改 main.cpp 使用 child 库，main.cpp 修改后如下：123456789#include &lt;iostream&gt;#include &lt;lib.h&gt;int main()&#123; std::cout &lt;&lt; "Hello CMake!" &lt;&lt; std::endl; call_child(); return 0;&#125; 为了让编译器知道如何查找头文件 lib.h 和让连接器知道 hellocmake 需要库 child，我们需要修改根目录下的CMakeLists.txt：1234567891011121314151617project(Hello_CMake)cmake_minimum_required(VERSION 2.8.12) set(SRC_FILES main.cpp)# 新增：添加子目录的CMakeLists.txt，以及包含 child 文件目录add_subdirectory(child)include_directories(child)add_executable(hellocmake $&#123;SRC_FILES&#125; ) # 新增：链接 child 库target_link_libraries(hellocmake child ) 解释一下上面的 CMake: 如前面提到的 add_subdirectory 会添加一个子目录到工程中，CMake 会解析子目录中的 CMakeLists.txt 为子目录生成MakeFile。include_directories 命令相当于 gcc 命令的 -I，告诉编译器到该目录中查找头文件。target_link_libraries 命令相当于gcc的-l命令，告诉连接器连接这个库，第一个参数为生成的目标名称，后面可以跟项目中其他库的目标名称或者已经存在的库文件名，查找规则和gcc -l一致。编辑完成后就可以到第三步的编译目录中再次执行 cmake 和 make 生成 hellocmake。这个hellocmake使用child库输出了文本Oh My Lady Gaga!。注：当然，我们也可以使用find_package 交叉编译CMake 会默认使用本机的编译器来配置项目，如果需要交叉编译，需要设定变量 CMAKE_C_COMPILE 和 CMAKE_CXX_COMPILE，可以通过 cmake 命令的 -D 参数传入,-D 参数可以给 CMake 传入变量，格式为 -DVar=Value。切换工作目录到第三步建立的编译目录中。 执行命令:1cmake ../cmakedemo -DCMAKE_C_COMPILER=arm-linux-gnueabi-gcc -DCMAKE_CXX_COMPILER=arm-linux-gnueabi-g++。 执行 make 编译工程，就可以在编译目录得到 arm 平台下的 hellocmake 程序。 CMAKE_C_COMPILE和 CMAKE_CXX_COMPILE 也可以在 CMakeLists.txt 中使用 set命令设定，需要注意的是，由于project 命令会根据这这两个变量设定一些其他的变量，所以它们应该在 project 命令前被设定。 修改源代码目录的 CMakeLists.txt：12345678910111213141516171819# 设置编译平台参数set(CMAKE_C_COMPILER arm-linux-gnueabi-gcc)set(CMAKE_CXX_COMPILER arm-linux-gnueabi-g++)project(Hello_CMake)cmake_minimum_required(VERSION 2.8.12) set(SRC_FILES main.cpp)add_subdirectory(child)include_directories(child)add_executable(hellocmake $&#123;SRC_FILES&#125; ) target_link_libraries(hellocmake child ) 到编译目录下执行 cmake 和 make 也可以得到 arm 平台下的 hellocmake。 CMake 进阶CMake 有一整套完备的编译控制体系，拥有繁多的命令和预置变量，这一节将选取一些较常用的命令做简单介绍，其具体使用和其他未介绍到的可以浏览官方文档。官方文档详细介绍了包括 cmake 命令本身和 CMakeLists.txt 中使用的所有命令和变量。在 cmake 安装包中也有相应的 man 文档，cmake 命令也有--help-command 参数可以查阅各命令的用法。 通用变量1、CMAKE_BUILD_TYPE这个变量可以控制程序的生成模式，可以留空，也可以选择这四种模式：Release，MinSizeRel，Debug，RelWithDebInfo。 Release模式下打开-O2开关。 MinSizeRel模式下打开-Os开关。 Debug模式打开-g开关。 RelWithDebInfo模式同时打开-O2和-g开关。 2、CMAKE_VERBOSE_MAKEFILE控制编译命令是否可见，设置这个变量为 ON 将会在 make 时看到编译命令，所有编译时加入的参数和编译的文件都将打印出来，便于校验 CMakeLists.txt 的正确性。 3、CMAKE_SOURCE_DIR指向工程源代码根目录，如使用 cmake ../cmakedemo 配置工程时，CMAKE_SOURCE_DIR 的值就是 ../cmakedemo的路径。 4、CMAKE_BINARY_DIR指向编译目录，如前一节的例子，CMAKE_BINARY_DIR 的值就是 buildcmakedemo 的路径。 编译阶段命令及变量1、add_definitions添加编译器参数的命令，相当于直接在编译时直接在编译命令上添加参数，需要注意这个命令不影响链接时的参数。如使用 g++ 编译时，添加命令add_definitions(-std=c++11)会让编译时使用&quot;g++ -std=c++11&quot;命令，但是连接时没有&quot;-std=c++11&quot;。 2、CMAKE_C_FLAGS这个命令也是在编译命令上添加参数，与 add_definitions 不同的是这个命令有兄弟命令，可以在不同模式下添加不同的参数： CMAKE_C_FLAGSCMAKE_C_FLAGS_DEBUGCMAKE_C_FLAGS_MINSIZERELCMAKE_C_FLAGS_RELEASECMAKE_C_FLAGS_RELWITHDEBINFO 分别对应所有模式、Debug模式、MinSizeRel模式、Release模式和RelWithDebInfo模式。对应 C++ 语言的变量只要把变量名第二段的C换成CXX即可。 3、configure_file这个命令用于传递CMake变量给语言，在跨平台编译中比较常用。其格式为：1configure_file(&lt;input&gt; &lt;output&gt; [COPYONLY] [ESCAPE_QUOTES] [@ONLY] [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF]]) 命令将会拷贝input到output并将其中的${var}和@var@换成对应CMAKE中的变量。由于在一些语言中${var}已经被占用，所以CMake添加了@var@这种表示方法，在命令中添加关键字@ONLY可以仅替换文件中的@var@，${var}会被忽略。 例如，我们可以在代码中这样定义：12#define HAS_BOOST $&#123;BOOST_FOUND&#125;#define HAS_PTHREAD @PTHREAD_FOUND@ 在CMakeLists.txt中使用命令：1configure_file($&#123;CMAKE_BINARY_DIR&#125;/cfg.h $&#123;CMAKE_SOURCE_DIR&#125;/cfg.in.h) 假设BOOST_FOUND和PTHREAD_FOUND都被定义为1，执行cmake后，构建目录将会生成一个cfg.h文件，内容为：12#define HAS_BOOST 1#define HAS_PTHREAD 1 如果configure_file命令添加了@ONLY则${BOOST_FOUND}将会被忽略，config.h内容则变为：12#define HAS_BOOST $&#123;BOOST_FOUND&#125;#define HAS_PTHREAD 1 4、系统变量 1,CMAKE_MAJOR_VERSION，CMAKE 主版本号，比如 2.4.6 中的 2。2,CMAKE_MINOR_VERSION，CMAKE 次版本号，比如 2.4.6 中的 43,CMAKE_PATCH_VERSION，CMAKE 补丁等级，比如 2.4.6 中的 64,CMAKE_SYSTEM，系统名称，比如 Linux-2.6.22。5,CMAKE_SYSTEM_NAME，不包含版本的系统名，比如 Linux。6,CMAKE_SYSTEM_VERSION，系统版本，比如 2.6.227,CMAKE_SYSTEM_PROCESSOR，处理器名称，比如 i686.8,UNIX，在所有的类 UNIX 平台为 TRUE，包括 OS X 和 cygwin。9,WIN32，在所有的 win32 平台为 TRUE，包括 cygwin。 5、aux_source_directory这个命令可以搜索某个目录所有的源代码文件，添加到变量里，其格式为aux_source_directory(&lt;dir&gt; &lt;variable&gt;)，多次对同一变量使用该命令，可以将不同目录的源代码都保存到变量中。对于一些在同一目录下放有很多源代码的工程，使用这个命令可以很方便地获取所有需要编译的文件。 在前一节的例子中，在源代码根目录使用命令 aux_source_directory(. SRC_FILES)就把main.cpp的路径添加到SRC_FILES变量中。 6、file(GLOB_RECURSE …)file是文件操作命令，有基本的文件功能，这里介绍文件查找功能。file有两种模式可以查找文件，一个是GLOB，另一个是GLOB_RECURSE，GLOB只会查找当前目录下的文件，GLOB_RECURSE会查找当前目录和子目录下的文件。命令格式如下：12file(GLOB variable [RELATIVE path] [globbing expressions]...)file(GLOB_RECURSE variable [RELATIVE path] [FOLLOW_SYMLINKS] [globbing expressions]...) 命令默认会保存文件的绝对路径，如果需要相对路径，可以用关键字RELATIVE加上需要获取相对于哪个目录的路径来获取相对路径，但是官方不推荐获取相对路径。填写 globbing expressions（通配符）可以简单过滤文件。 如前一节的例子，使用 file(GLOB SRC_FILES *.cpp) 可以获取到 main.cpp 的路径，使用 file(GLOB_RECURSE SRC_FILES *.cpp) 可以获取到 main.cpp 和 child/lib.cpp 的路径。 链接阶段命令及变量1、CMAKE_C_LINK_FLAGES与 CMAKE_C_FLAGS 家族类似，模式下的细分变量，其内容将添加在连接器的参数上。 2、link_directories设置库查找位置，相当于 gcc 的 -L，可以同时设置多个目录。 安装阶段命令及变量1、install大型项目中，会编译出来很多个模块，每个模块都在各自的文件夹中，不方便发布，install 命令可以指定目标的安装位置，install 可以安装多种文件，这里只介绍安装 CMake 目标的安装方法，CMake 主要有 add_executable 和 add_library 命令创建的目标，都可以使用:1234install(TARGETS target1 target2 LIBARARY DESTINATION lib ARCHIVE DESTINATION lib/static RUNTIME DESTINATION bin) 这里的安装位置需要加上下面提到的变量 CMAKE_INSTALL_PREFIX ，默认情况下 Linux的 CMAKE_INTALL_PREFIX=/usr，使用 make install 命令将会把可执行文件目标安装到 /usr/bin下。 2、CMAKE_INSTALL_PREFIX工程安装位置，为 install 命令使用目录的前缀，Linux下默认为/usr。 3、CMAKE_INSTALL_RPATH设定安装后可执行文件的运行目录，相当于 gcc 的 -Wl,rpath 在交叉编译时比较常用。 分支结构和逻辑运算cmake有完备的流程控制机制，有一般编程语言常用的if分支结构，也有foreach循环结构，这里介绍一下if分支结构，if用法如下：1234567if(expression) COMMAND(ARGS ...)elseif(expression2) COMMAND(ARGS ...)else(expression) COMMAND(ARGS ...)endif(expression) expressin 填入真值表达式，变量为 0, OFF, NO, FALSE, N, IGNORE, NOTFOUND、以-NOTFOUND结尾或未定义的值为false，其他为 true。 注意: else 和endif的expression可以忽略，但是必须带上括号。if内可以使用比较运算比较两个变量获得真值： 常用的数值运算有:1,EQUAL: 相等2,LESS：小于3,GREATER：大于常用的字符串运算：1,STRLESS：字符串小于。2,STRGREATER：字符串大于3,STREQUAL：字符串等于4,MATCHES：正则表达式匹配此外还有文件比较等功能，可自行查阅官方文档。多条表达式可以使用逻辑运算NOT、AND和OR连接起来，这几个运算符优先级和C语言的逻辑运算符不同，所以推荐使用括号来明确运算顺序。 find_package 查找外部库我们前面已经讲过如何链接外部库，上面提到的方法是显式调用，也就是我们知道库和头文件的位置，直接通过include_directories和target_link_libraries将库文件链接进来。现在我们介绍一下另一种方式find_package。 find_package能查找本机安装的外部库，并获取对应的环境和变量。其常用形式为：1find_package(&lt;package&gt; [version] [REQUIRED]) 我们以Qt库为例，如果需要Qt库，那先要使用命令find_package(Qt4 REQUIRED)来获取Qt的相关变量，由于Qt库是必须的，所以加上REQUIRED关键字。 find_package会调用cmake安装目录的shared目录下的FindQt4.cmake来设置Qt变量，同时添加一些函数和宏。使用这些变量和宏就可以编译Qt工程。 系统中FindQt4.cmake目录:1/usr/local/share/cmake-3.3/Modules/FindQt4.cmake find_package查找Qt成功后，会定义一下常用变量：123QT_FOUND: 是否找到QT_LIBRARIES：Qt所有库的路径，在target_link_libraries时添加。QT_INCLUDES: Qt 头文件路径 对于系统预定义的 Find.cmake 模块，每一个模块都会定义以下几个变量: • &lt; name&gt;_FOUND• &lt; name&gt;_INCLUDE_DIR or &lt; name&gt;_INCLUDES• &lt; name&gt;_LIBRARY or &lt; name&gt;_LIBRARIES其中的name为find_package中的package参数 找到外部模块后，我们便可以将外部模块链接进来： 123456find_package(Qt4 REQUIRED)if(QT_FOUND) include_directories($&#123;QT_INCLUDE_DIR&#125;) target_link_libraries($&#123;project_name&#125; $&#123;QT_LIBRARIES&#125;)end() 实用的 CMake 封装下面列一些实用的 CMake 封装，后续持续更新！ 1、自动检测 C++ 版本参数12345678910111213# using C++ newest feature, auto test Cxx versioninclude(CheckCXXCompilerFlag)foreach(cxx_feature_name "c++20" "c++2a" "c++17" "c++1z" "c++14" "c++1y" "c++11" "c++0x") set(cxx_feature_flag "-std=$&#123;cxx_feature_name&#125;") string(REPLACE "+" "x" cxx_feature_suffix $&#123;cxx_feature_name&#125;) CHECK_CXX_COMPILER_FLAG($&#123;cxx_feature_flag&#125; COMPILER_SUPPORTS_$&#123;cxx_feature_suffix&#125;) if(COMPILER_SUPPORTS_$&#123;cxx_feature_suffix&#125;) set(CMAKE_CXX_FLAGS "$&#123;CMAKE_CXX_FLAGS&#125; $&#123;cxx_feature_flag&#125;") message(STATUS "The compiler $&#123;BUILDTOOL_PREFIX&#125;-g++ has $&#123;cxx_feature_name&#125; support") break() endif()endforeach() 2、库文件安装123456789101112# 设置安装路径set(CMAKE_INSTALL_PREFIX "$&#123;CMAKE_BINARY_DIR&#125;/output")message("Install prefix: $&#123;CMAKE_INSTALL_PREFIX&#125;")# project用的库文件安装函数function(target_install OBJECTS) install(TARGETS $&#123;OBJECTS&#125; RUNTIME DESTINATION bin ARCHIVE DESTINATION lib LIBRARY DESTINATION lib )endfunction() 3、将所有包含CMakeLists.txt的子目录添加进来 123456789101112131415161718192021222324# Add all subdirectories that exist CMakeLists.txtinclude(CMakeParseArguments)function(add_all_subdirectories) cmake_parse_arguments(SUBDIR "" "" "EXCLUDE" $&#123;ARGN&#125;) file(GLOB ALL_FILES *) foreach(subdir $&#123;ALL_FILES&#125;) if((IS_DIRECTORY $&#123;subdir&#125;) AND (EXISTS $&#123;subdir&#125;/CMakeLists.txt)) file(RELATIVE_PATH relPath $&#123;CMAKE_CURRENT_SOURCE_DIR&#125; $&#123;subdir&#125;) if(SUBDIR_EXCLUDE) list(FIND SUBDIR_EXCLUDE $&#123;relPath&#125; _index) if (_index EQUAL -1) add_subdirectory($&#123;subdir&#125;) elseif(CMAKE_DEBUG) message("Exclude [$&#123;relPath&#125;] when add_all_subdirectories") endif() else() add_subdirectory($&#123;subdir&#125;) endif() endif() endforeach()endfunction() 总结CMake 大概就总结到这里，总的来说这个工具还是十分不错的，整体结构清晰明了，后续的话，就着力把一些好的小的功能点，封装成函数或者宏，记录下来，以后碰到需要用了，就可以直接拿来用，基本可以做到一劳永逸。 参考 &lt;&lt; cmake 实践 &gt;&gt;]]></content>
      <tags>
        <tag>编译 (compile)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GDB]]></title>
    <url>%2F2019%2F01%2F23%2FGDB%2F</url>
    <content type="text"><![CDATA[What is GDB? 官方文档： https://sourceware.org/gdb/download/onlinedocs/ GDB 是 GNU 项目的调试器，你可以用 GDB 查看另一个程序在执行过程中的内部内容, 或者在程序崩溃时，查看程序当时正在执行的操作。 (gdb) set print address on(gdb) f 0#0 Request::process (this=0x7fffffffe690) at /home/willy/myshare/thread-pool/DeadLock_Test/main.cpp:8 8 &emsp; PosixThread::MutexLockGuard &lt; PosixThread::MutexLock &gt; lock(mutex_);(gdb) 上述指令表示，当程序显示函数信息时，GDB 会显出函数的参数地址，然后调用 f &lt;n&gt; 或 frame &lt;n&gt;, 表示查看当前栈层的信息。在我看来，查看栈层信息以及打印相关变量的地址，是 GDB 最为有用的地方。 GDB 主要做四件事情(以及支持这些事情的其他事情)，来帮助你捕捉程序中的错误： 1. 启动程序，指定可能影响其行为的任何内容。2. 使程序在指定条件下停止。3. 当程序停止时，检查发生了什么。4. 更改程序中的内容，以便您可以尝试纠正一个错误的影响并继续了解另一个错误。 这些程序可能与 GDB 在同一台机器上，或者另一台机器（远程）或模拟器上执行。 GDB 可以在大多数流行的 UNIX 和 Microsoft Windows 变体上运行，也可以在 Mac OS X 上运行。 What Languages does GDB Support?GDB 支持以下语言（按字母顺序排列）： Ada Assembly C C++ D Fortran Go Objective-C OpenCL Modula-2 Pascal Rust GDB 本机调试首先我们总结一下 GDB 本机调试，也就是可执行程序和 GDB 跑在同一台机器上, 这也是我们最为常见的一种方式。1. 编译 GDB 可调试的程序我用 GDB 主要调试 C/C++ 程序，为了将调试信息加到可执行文件中，我们需要用到 gcc编译器提供的 -g 参数，具体编译方法如下： Make g++&emsp;-g&emsp;-Wall&emsp;hello.cpp&emsp;-o&emsp;hello CMake： set(CMAKE_BUILD_TYPE&emsp;”Debug”)set(CMAKE_CXX_FLAGS_DEBUG&emsp;”$ENV{CXXFLAGS}&emsp;-O0&emsp;-Wall&emsp;-g2&emsp;-ggdb”) #替换 Debug 版本参数 启动下面是程序的启动，启动操作主要有三种： 1.直接加载可执行程序1gdb &lt;program&gt; # program 为你编译的可执行程序 2.调试可执行程序的同时，将 core 文件加入其中12# 注意：core 文件是已经生成的 coredump，如何生成coredump后面介绍。gdb &lt;program&gt; core 3.当你调试正在运行的进程, 可以通过该指令附着（attach）到进程中调试。1gdb &lt;program&gt; &lt;PID&gt; 当然我们也可以执行 gdb 指令，然后通过 file &lt;program&gt;来加载可执行程序的符号。 例如：123456789101112[root@yejy build]# gdb output/bin/dead_lock.exx # 采用方式1, 直接加载可执行程序GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-94.el7Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;...Reading symbols from /home/willy/myshare/thread-pool/build/output/bin/dead_lock.exx...done.(gdb) 设置断点12345678# 在进入指定函数时停住。C++ 可以使用class::function或function(type,type)格式来指定函数名。break &lt;function&gt;# 在源文件filename的linenum行处停住。break filename：linenum# 在源文件filename的function函数的入口处停住。break filename：function 例如：123# 将断点设置在 main 函数(gdb) b main # break简写Breakpoint 1 at 0x40143d: file /home/willy/myshare/thread-pool/DeadLock_Test/main.cpp, line 25. 程序运行与单步调试较常用指令是如下四个：123456789101112# 程序开始运行run# 恢复程序运行，直到程序结束，或是下一个断点到来。ignore-count表示忽略其后的断点次数。continue，c命令意思相同。continue [ignore-count]c [ignore-count]# 单步跟踪，如果有函数调用，会进入该函数, count 表示连续执行count条，然后停止，否则一条一条执行。step &lt;count&gt;# 单步跟踪，如果有函数调用，不会进入该函数，count 同上。next &lt;count&gt; 例如：12345678910(gdb) run # 开始执行Starting program: /home/willy/myshare/thread-pool/build/output/bin/dead_lock.exx [Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib64/libthread_db.so.1&quot;.Breakpoint 1, main (argc=1, argv=0x7fffffffe128) at /home/willy/myshare/thread-pool/DeadLock_Test/main.cpp:2525 char* pBuff = nullptr;Missing separate debuginfos, use: debuginfo-install glibc-2.17-222.el7.x86_64 libgcc-4.8.5-28.el7_5.1.x86_64 libstdc++-4.8.5-28.el7_5.1.x86_64(gdb) n # next简写，执行下一条26 *pBuff = &apos;2&apos;; 分析栈信息当程序运行到断点时，我们需要查看程序在哪里停住了。当程序调用了一个函数，函数的地址，函数参数，函数内的局部变量都会被压入”栈”（Stack）中。我们可以使用 GDB 命令来查看栈中的信息。 1234567891011121314151617181920# 打印当前的函数调用栈的所有信息, n是一个正整数，表示打印栈顶上n层的栈信息, n可为负数，表示栈底。backtrace &lt;n&gt;bt &lt;n&gt;# 查看当前栈，一般来说，程序停止时，最顶层的栈就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是切换当前栈# 例: frame 0，表示栈顶，frame 1，表示栈的第二层。frame &lt;n&gt;f &lt;n&gt;# 这个命令会打印出更为详细的当前栈层的信息# 大多都是运行时的内存地址。比如：函数地址，调用函数的地址，被调用函数的地址，# 目前的函数是由什么样的程序语言写成的、函数参数地址及值、局部变量的地址等等info frameinfo f# 打印出当前函数的参数名及其值。info args# 打印出当前函数中所有局部变量及其值。info locals 测试代码：123456789101112131415161718192021222324252627282930class Request&#123;public: void process() const __attribute__((noinline)) &#123; PosixThread::MutexLockGuard&lt;PosixThread::MutexLock&gt; lock(mutex_); // .. Printf(); &#125; void Printf() const __attribute__((noinline)) &#123; PosixThread::MutexLockGuard&lt;PosixThread::MutexLock&gt; lock(mutex_); // .. &#125;private: mutable PosixThread::MutexLock mutex_;&#125;;int main(int argc, char *argv[])&#123; char* pBuff = nullptr; *pBuff = '2'; Request req; req.process(); return 0;&#125; GDB 调试打印：12345678910111213141516171819202122(gdb) backtrace # 查看所有调用栈#0 main (argc=1, argv=0x7fffffffe128) at /home/willy/myshare/thread-pool/DeadLock_Test/main.cpp:25(gdb) f # 查看当前调用栈#0 main (argc=1, argv=0x7fffffffe128) at /home/willy/myshare/thread-pool/DeadLock_Test/main.cpp:2525 char* pBuff = nullptr;(gdb) info f # 当前调用栈详细信息Stack level 0, frame at 0x7fffffffe050: rip = 0x40143d in main (/home/willy/myshare/thread-pool/DeadLock_Test/main.cpp:25); saved rip 0x7ffff6ded445 source language c++. Arglist at 0x7fffffffe040, args: argc=1, argv=0x7fffffffe128 Locals at 0x7fffffffe040, Previous frame&apos;s sp is 0x7fffffffe050 Saved registers: rbx at 0x7fffffffe038, rbp at 0x7fffffffe040, rip at 0x7fffffffe048(gdb) info args # 函数参数argc = 1argv = 0x7fffffffe128(gdb) info locals # 函数局部变量pBuff = 0x401340 &lt;_start&gt; &quot;1\355I\211\321^H\211\342H\203\344\360PTI\307\300`\030@&quot;req = &#123;mutex_ = &#123;mutex_ = &#123;__data = &#123;__lock = -138651536, __count = 32767, __owner = 15775487, __nusers = 0, __kind = 1, __spins = 0, __elision = 0, __list = &#123; __prev = 0x40183d &lt;__libc_csu_init+77&gt;, __next = 0x7fffffffe040&#125;&#125;, __size = &quot;pX\274\367\377\177\000\000\377\266\360\000\000\000\000\000\001\000\000\000\000\000\000\000=\030@\000\000\000\000\000@\340\377\377\377\177\000&quot;, __align = 140737349703792&#125;, holder_ = 0&#125;&#125; 查看源码12345678# 显示程序第linenum行的周围的源程序。list &lt;linenum&gt;# 显示函数名为function的函数的源程序。list &lt;function&gt;# 设置一次默认显示源代码的行数。set listsize &lt;count&gt; 例如：1234567891011(gdb) list23 int main(int argc, char *argv[])24 &#123;25 char* pBuff = nullptr;26 *pBuff = &apos;2&apos;;27 (gdb) set listsize 2 # 一次显示两行(gdb) list28 Request req;29 req.process();(gdb) 设置显示选项123456789# 当程序显示函数信息时, GDB会显示出函数的参数地址.set print addressset print address on# printf pretty这个选项，那么当GDB显示结构体时会比较漂亮.set print pretty on# 当此选项打开时，GDB将用比较规整的格式来显示虚函数表.set print vtbl &lt;on/off&gt; 例如：12345678910(gdb) show print addressPrinting of addresses is on.(gdb) f # argv 有地址#0 main (argc=1, argv=0x7fffffffe128) at /home/willy/myshare/thread-pool/DeadLock_Test/main.cpp:2525 char* pBuff = nullptr;(gdb) set print address off(gdb) f # argv 无地址#0 main (argc=1, argv=) at /home/willy/myshare/thread-pool/DeadLock_Test/main.cpp:2525 char* pBuff = nullptr;(gdb) GDB 中运行 UNIX 的 shell 程序在 GDB 环境中，我们可以执行 UNIX 的 shell 命令来完成一些操作, 包括 Make/CMake。1shell &lt;command string&gt; 例：12345678910111213(gdb) shell ls # ls指令3rdlib bin CMakeCache.txt CMakeFiles cmake_install.cmake DeadLock_Test install_manifest.txt lib Makefile output src unit_mock unit_test(gdb) shell cmake .. -DENABLE_DEBUG=ON -DENABLE_TEST=ON # 执行cmake指令-- The compiler -g++ has c++1y supportInstall prefix: /home/willy/myshare/thread-pool/build/outputCMAKE_CXX_FLAGS : -std=c++1yCMAKE_CXX_FLAGS_DEBUG : -O0 -Wall -g2 -ggdbCMAKE_CXX_FLAGS_RELEASE : -O3 -WallBuild Type: Debug-- Configuring done-- Generating done-- Build files have been written to: /home/willy/myshare/thread-pool/build(gdb) 调试 coredump 文件Linux 平台下在一个程序崩溃时，它一般会在指定目录下生成一个 core 文件，core 文件仅仅是一个内存映象(同时加上调试信息)，使用 GDB 来查看 core 文件，可以指示出导致程序出错的代码所在文件和行数。 首先我们需要生成 core 文件1.查看当前系统是否能生成 core 文件, 如果显示为 0 则说明当前系统不会生成 core 文件，需要运行 unlimited 操作：12345# 查看当前允许生产 core 文件大小ulimit -c# 将 core 文件大小设置为不限制大小ulimit -c unlimited 2.设置 core 文件输出路径core 文件默认输出到程序运行的目录，也可以更改为其他目录(目录一定要可写)：1echo &quot;/tmp/core&quot; &gt;/proc/sys/kernel/core_pattern 运行以上命令后，core 文件会输出到 /tmp 目录下，名称为 core.进程ID，比如进程308挂掉后生成的 core 文件为/tmp/core.308。 注：运行以上命令的 shell 一定要和运行程序的 shell 是同一个 3.GDB 调试 core 文件我们使用 gdb &lt;program&gt; core 的启动方式来调试，这样等于在问题出现后，现场已经不存在的情况下，我们也可以进行调试，很管用。当然在正常系统环境中生成 coredump 文件的方式各有不同，原理都是获得其函数调用栈地址，然后通过 address2line 具体定位到某个函数，某一行代码。 我们通过例子来说明，我在代码中加入下面两句，导致函数出现段错误：12char* pBuff = nullptr;*pBuff = '2'; 执行程序：123456789101112131415161718192021222324[root@yejy build]# ./output/bin/dead_lock.exx 段错误(吐核)[root@yejy build]# ls /tmp/core.4209 # 生成了一个 core 文件/tmp/core.4209[root@yejy build]# gdb output/bin/dead_lock.exx /tmp/core.4209 # 使用 gdb 执行程序并且调试 core 文件GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-94.el7Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;...Reading symbols from /home/willy/myshare/thread-pool/build/output/bin/dead_lock.exx...done.[New LWP 4209][Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib64/libthread_db.so.1&quot;.Core was generated by `./output/bin/dead_lock.exx&apos;.Program terminated with signal 11, Segmentation fault.#0 0x0000000000401449 in main (argc=1, argv=0x7ffd573c8518) at /home/willy/myshare/thread-pool/DeadLock_Test/main.cpp:26 26 *pBuff = &apos;2&apos;; # 直接就提示 26 行出现段错误Missing separate debuginfos, use: debuginfo-install glibc-2.17-222.el7.x86_64 libgcc-4.8.5-28.el7_5.1.x86_64 libstdc++-4.8.5-28.el7_5.1.x86_64(gdb) 查看 C++ 对象虚函数表我们前面在设置显示选项的时候，有设置显示虚函数表 set print vtbl &lt;on/off&gt;, 那具体是怎么查看呢？步骤如下：1234567891011# 设置可显示set print vtbl on# 打印所有虚函数地址info vtbl pObject# 打印某一个虚函数p /a (*(void ***)pObject)[0]@10 # /a 表示 16 进制打印；10表示打印的虚函数个数# 查看相应地址的符号info symbol 0x80486c8 线程123456# 断点只对指定线程生效，该线程执行到该断点停止后，所有线程会一起停止，方便我们调试。break &lt;linespec&gt; thread &lt;threadno&gt;break &lt;linespec&gt; thread &lt;threadno&gt; if ...# 上面的 threadno 是 gdb 分配的，我们可以通过下面这个查看线程 id。info threads 查阅帮助12345678# 列出 gdb 指令种类help# GDB 指令详细帮助gdb -help# 一般指令help &lt;command&gt; 上述讲解了在工作中最为常用的一些 GDB 指令，总体可以覆盖整个调试流程，当然GDB 还有非常多的其他指令，需要我们去发掘并使用，这个只能祈祷工作中可以多遇到些问题，然后尝试使用 GDB 去解决，这样我们才可以学到更多东西，掌握更多的调试手段。 如果还想更细致的了解 GDB 指令，可以查看如下链接： http://wiki.ubuntu.org.cn/index.php?title=%E7%94%A8GDB%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F&amp;variant=zh-cn GDB 远程调试远程调试过程，真正的调试指令和本地调试基本一致，主要区别在于调试环境不一样，需要事先搭建。我们会用到远端系统使用的gdbserver 和本机使用的 gdb，大概介绍一下整体的流程。 编译 gdbserver 和 gdb这一步需要对 gdb 和 gdbserver 做一下交叉编译，一般相应平台的gdb公司内部都会有编译好的，直接用就可以，如果需要编译，大致流程如下：12345678910111213141. 将gdb-7.6.tar.gz拷贝到虚拟机/opt目录下2. 解压缩：cd /opttar -xzvf ./ gdb-7.6.tar.gz3. 创建gdb build目录（最好一个编译器建立一个build目录，不然容易出错） mkdir -p xxx-gdb/build4. 配置gdb平台参数，生成makefile cd xxx-gdb/build/opt/gdb-7.6/configure --target=arm-linux-gnueabi --prefix=/opt/xxx-gdb注：此处不用定义(--host)，host 是编译 Linux 版本的程序，会默认以 gcc 编译的，target是定义目标系统的版本5. 编译gdb make&amp;&amp; make install# gdbserver类似 环境配置将 GDB 加入到环境变量：123vi /etc/profile在文件的末尾加入以下语句： export PATH=/opt/xxx/bin:/opt/xxx-gdb/bin/:$PATH 保存/etc/profile文件后运行一下. /etc/profile或重新连接shell 具体使用首先在远程调试机器上运行gdbserver，假设是 mnt 目录（该目录一般为挂载目录），2345为任意端口(保证之前没用过就行)，然后Exe.exx 为你需要运行的程序, 指令大概如下：12345/mnt/gdb/gdbserver localhost:2345 /mnt/bin/Exe.exx # 执行完，大概提示这个：Process /mnt/bin/Exe.exx created; pid = 497Listening on port 2345 接着在你的编译机器(可能是虚拟机或者编译服务器)上，使用 gdb 跑你的可执行程序，然后远程连接到远端的 IP:port 就可以了，大致如下所示：123456789101112131415#首先使用你的 xxx-gdb 跑你的程序xxx-gdb # 链接相关库，因为生产中，不可能就一个可执行程序，需要链接大量的动态库和静态库set solib-absolute-prefix /lib/set solib-search-path /lib/# 加载可执行程序符号，Exe.exx 和远程服务器上执行的是同一个file ./bin/Exe.exx# 编译虚拟机(或编译服务器)上的 gdb 与远程机器上的 gdbserver 连接。 10.3.3.243为 IP，2345 为你设置的端口target remote 10.3.3.243:2345# 执行你的程序run 或者 break function （设置断点什么的，或者直接跑） 总之，远程调试主要是加入了一个gdbserver，用做远程系统上的服务程序，来和编译服务器上的 gdb 进行通信，其他调试手段和本机调试基本一致。 总结GDB常用知识大概就是这些，如果都掌握吸收了，一般的生产工作基本没有什么问题，可以很好的解决遇到的问题，当然这只是 GDB 所有内容中的一部分，没有官方文档那样细致，所以如果想要更加深入的了解其他 GDB 指令，请参阅官方文档。 还有就是像前面那篇参考文章中提到的，编写 GDB 脚本来自动调试我们编写的程序，我觉得吧，虽然想法很美好，但是实用性可能不会太高，一个是编写调试脚本的工作成本是一个问题，然后该脚本所适用的调试场景可能也会比较特殊、通用性不够，导致整体成本会比较高。当然如果把编写调试脚本当做一种对 GDB 深入了解的方法，倒是非常不错，这样可以很好的提升我们的 Debug 能力与思维。 参考链接 http://wiki.ubuntu.org.cn/index.php?title=%E7%94%A8GDB%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F&amp;variant=zh-cn]]></content>
      <tags>
        <tag>GNU Software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MakeFile 编写]]></title>
    <url>%2F2019%2F01%2F20%2Fmake%2F</url>
    <content type="text"><![CDATA[程序的编译与链接1234567891011# Top level makefile, the real shit is at src/Makefiledefault: all.DEFAULT: cd src &amp;&amp; $(MAKE) $@install: cd src &amp;&amp; $(MAKE) $@.PHONY: install GNU Make 是一个工具，它从程序的源文件中控制程序的可执行文件和其他非源文件的生成。 C、C++ 程序在编译的时候，首先要把源文件编译成中间代码文件，在 Windows 下也就是 .obj 文件， UNIX 下是 .o 文件，即 Object File，这个动作叫做编译（compile），然后再把大量的 Object File 合成执行文件，这个动作叫作链接（link）。在编译时，编译器只检测程序语法，和函数、变量是否被声明，而在链接程序时，链接器会在所有的 Object File 中找寻函数的实现，如果找不到，就会报链接错误。 make 则是一个工具，MakeFile 类似是一个脚本文件，文件中定义了一系列的规则来告诉 make 需要如何去编译和链接程序。 MakeFile 概述MakeFile 组成Makefile 里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。 1、显式规则。显式规则说明了，如何生成一个或多个的目标文件。这是由 Makefile 的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。2、隐晦规则。由于我们的 make 有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写 Makefile，这是由 make 所支持的。3、变量的定义。在 Makefile 中我们要定义一系列的变量，变量一般都是字符串，这个有点像 C 语言中的宏，当 Makefile 被执行时，其中的变量都会被扩展到相应的引用位置上。4、文件指示。其包括了三个部分，一个是在一个 Makefile 中引用另一个 Makefile，就像 C语言中的 include 一样；另一个是指根据某些情况指定 Makefile 中的有效部分，就像 C 语言中的预编译#if 一样；还有就是定义一个多行的命令。5、注释。 Makefile 中只有行注释，和 UNIX 的 Shell 脚本一样，其注释是用“#”字符。 还有一点需要注意，在 Makefile 中的命令，必须要以[Tab]键开始。 MakeFile 工作方式GNU 的 make 工作时的执行步骤如下： 1、读入所有的 Makefile。2、读入被 include 的其它 Makefile。3、初始化文件中的变量。4、推导隐晦规则，并分析所有规则。5、为所有的目标文件创建依赖关系链。6、根据依赖关系，决定哪些目标要重新生成。7、执行生成命令。 MakeFile 使用书写规则用一个示例来说明 MakeFile 的书写规则，以便给大家一个感性认识。示例来源于 gnu 的 make 使用手册，这个示例中，我们的工程有8个c文件，和3个头文件，我们要写一个 MakeFile 来告诉 make 命令如何编译和链接这几个文件。我们的规则是： 1）如果这个工程没有编译过，那么我们的所有c文件都要编译并被链接。2）如果这个工程的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。3）如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序。 MakeFile 写得够好，所有的这一切，我们只用一个 make 命令就可以完成，make 命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。 MakeFile 的书写规则：1234target ... : prerequisites ...command...... target 也就是一个目标文件，可以是 Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”中会有介绍。prerequisites 就是要生成那个 target 所依赖的文件或是目标。command 也就是 make 需要执行的命令。（任意的 Shell 命令） 这是一个文件的依赖关系，意思是， target 这一个或多个的目标文件依赖于 prerequisites 中的文件，其生成规则定义在 command 中。说白一点就是说， prerequisites 中如果有一个以上的文件比 target 文件要新的话， command 所定义的命令就会被执行。这就是 Makefile 的规则，也就是 Makefile 中最核心的内容。 正如前面所说的，如果一个工程有3个头文件，和8个c文件，我们为了完成前面所述的那三个规则，我们的 Makefile 如下： 反斜杠（\）是换行符的意思，这样比较便于makefile的易读。我们可以把这个内容保存在名字为 “makefile” 或 “Makefile” 的文件中，然后在该目录下直接输入命令 “make” 就可以生成执行文件 edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下 “make clean” 就可以了。 上图中是最原始的写法，其中有很多变量是重复出现的，我们可以新增 变量 以及根据 make 的 自动推导，来简化 Makefile。 引入变量objects： GNU 的 make 很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。 只要 make 看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果 make 找到一个 whatever.o，那么 whatever.c，就会是 whatever.o 的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的 makefile 再也不用写得这么复杂。 最新的 makefile： 编译C时，.o 的目标会自动推导为 .cMakefile 中12main : main.o gcc -o main main.o 会自动变为:12345main : main.o gcc -o main main.omain.o: main.c &lt;-- main.o 这个目标是隐含生成的 gcc -c main.c log 打印我们可以使用 info / warning / error 打印日志。123456789$(error text…)$(warning text…)$(info text…)# To print variables,$(error VAR is $(VAR))$(warning VAR is $(VAR))$(info VAR is $(VAR))# when you use 'error' the make execution will stop after showing the error string 例如：输出： 变量1. 变量赋值 2. 变量替换3. 变量追加值 +=4.变量覆盖5.目标变量 前缀 伪目标“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以 make 无法生成它的依赖关系和决定它是否要执行。为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向 make 说明，不管是否有这个文件，这个目标就是“伪目标”123.PHONY: clean --&gt; 最好加上，以免和文件名冲突clean: rm *.o temp 伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的 Makefile 需要一口气生成若干个可执行文件，但你只想简单地敲一个 make 完事，并且，所有的目标文件都写在一个 Makefile 中，那么你可以使用“伪目标”这个特性：12345678all: prog1 prog2 prog3.PHONY: allprog1: prog1.o utils.o cc -o prog1 prog1.o utils.oprog2: prog2.o cc -o prog2 prog2.oprog3: prog3.o sort.o utils.o cc -o prog3 prog3.o sort.o utils.o 总结MakeFile 主要思想就是依赖关系，判断依赖文件更新，来执行相关 command。MakeFile 对于一些工程结构简单的代码，可以很好的胜任组织编译链接工作，但是当工程非常大的时候(代码目录繁多，层次错综复杂)，手写 MakeFile 会非常麻烦，而且 MakeFile 是类 Unix 平台（平台相关）上的工具，，如果换一个平台(windows、android等)，又需要重新编写其他编译链接脚本，因此，在开发生产中，建议使用跨平台编译工具 CMake。 主要参考书籍 &lt;&lt; 跟我一起写 MakeFile &gt;&gt; 官方文档：http://www.gnu.org/software/make/manual/make.html#Reading]]></content>
      <tags>
        <tag>编译 (compile)</tag>
        <tag>GNU Software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 多线程编程]]></title>
    <url>%2F2019%2F01%2F12%2FC-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[多线程编程123456789101112131415161718192021class MutexLock&#123;public: MutexLock(); ~MutexLock(); MutexLock(const MutexLock &amp;mutex) = delete; MutexLock &amp;operator=(const MutexLock &amp;mutex) = delete; void lock(); void unlock(); bool IsLockedByThisThread() const; pthread_mutex_t *getPthreadMutex();private: friend class Condition;private: pthread_mutex_t mutex_; pid_t holder_;&#125;; 这段时间，主要在分析和整理多线程相关的内容，主要是因为工作中我有负责部门基础库的开发维护，其中就包括线程库，然后近期要在组内做异步这一块的分享，所以也希望趁这个机会对这一块知识进行系统的梳理，然后自己也将 posix-thread 线程重新使用了一下，加深印象，基本覆盖到了相关关键接口的使用。加上之前已经对 线程概念，以及 同步和互斥 做了一下总结，所以整体来说，对多线程已经有了一个比较系统的认识。 具体C代码见： https://github.com/Yejy813/posix-thread C++ 封装 Posix-thread最近把陈硕老师 muduo 网络库中多线程部分的代码阅读了一遍，同时把其中的 MutexLock, MutexLockGuard, Condition, AtomicIntegerT, CountDownLatch, Thread 等多线程构件代码敲了一编，同时写了一些测试程序，并将封装思路和注意点加入到注释中，相当于对多线程做了一个总结，加深了对多线程的理解。 具体C++代码见： https://github.com/Yejy813/posix-thread-cplusplus 总结通过 posix-thread 的使用和封装，你会发现，其实多线程相关工具接口的使用并不难，只要我们提前制定好使用规则，将异步操作模块化的提供给业务层使用，提供一种异步机制，内部可能是使用线程池等方式对所有线程进行管理，就可以很好的降低多线程的使用难度，以此更好的避免多线程相关的问题；那么提供完异步机制，那就只剩一个问题，如果我们在异步中对共享资源进行访问，如何做到同步互斥，以及尽可能高的效率，这又是我们需要考虑的另一个问题，用 互斥锁，自旋锁，原子操作，还是条件变量，或者是由这些底层同步机制衍生出来的，更高级的同步构件，这些是需要我们仔细的去思考和设计的。 多线程的概念和实现就先分析这么多，后续会对 C++ 11 中提供的线程库以及 Java 多线程相关的知识进行关注和深入学习，C++ 11 中的多线程库，我觉得会是一个趋势，首先它是官方的，跨平台的，资料相应会较多，而且统一，所以会更好些 ，当然封装一套多线程库也不难，现在各个公司如果还是使用 Linux 原生的线程接口，那么各自都会根据业务需求，做不同程度的封装，这是历史原因造成的，但是我们要向前看；至于 java 多线程，主要是其对一些多线程工具类的封装思路，是值得借鉴的，C++ 多线程相关确实需要向 java 语言学习，毕竟 C++ 语言直到 C++11 才提供自己的线程库。]]></content>
      <tags>
        <tag>多线程编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 单元测试框架-gtest]]></title>
    <url>%2F2019%2F01%2F02%2Fgoogletest%2F</url>
    <content type="text"><![CDATA[Unit Test 和 gtest 介绍 单元测试（ Unit Test ，模块测试）是开发者编写的一小段代码，用于检验被测代码的一个很小的、很明确的功能是否正确，通过编写单元测试可以在编码阶段发现程序编码错误，甚至是程序设计错误。 单元测试不但可以增加开发者对于所完成代码的自信，同时，好的单元测试用例往往可以在 回归测试 的过程中，很好地保证之前所发生的修改没有破坏已有的程序逻辑。因此，单元测试不但不会成为开发者的负担，反而可以在保证开发质量的情况下，加速迭代开发的过程。GoogleTest是一个跨平台的(Liunx、Mac OS X、Windows、Cygwin、Windows CE and Symbian) C++ 单元测试框架，GoogleTest由 google 公司发布, 且遵循 New BSD License（可用作商业用途）的开源项目, 为当前比较主流的 C++ 单元测试框架，目前所在公司也在使用。 gtest 安装、导入项目（Linux系统）下载源码我本地使用的系统参数：12bash-4.2$ uname -aLinux yejy 3.10.0-514.el7.x86_64 #1 SMP Tue Nov 22 16:42:41 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux gtest github 地址： https://github.com/google/googletest 下载源码：1bash-4.2$ git clone https://github.com/google/googletest 导入项目简单测试下载源码后，接着就是将其导入到我们的项目中使用，如果你只是想简单测试一下，可以直接编译 gtest 源码，生成相应的静态库，将库和头文件拷贝到系统的头文件和库中，然后就可以直接写代码进行测试了，步骤如下： 12345bash-4.2$ cd googletestbash-4.2$ cmakebash-4.2$ makebash-4.2$ cp libgtest*.a /usr/lib bash-4.2$ cp –a include/gtest /usr/include 写一个简单的测试程序：123456789101112131415#include&lt;gtest/gtest.h&gt;int add(int a, int b)&#123; return a+b;&#125;TEST(testCase, test0)&#123; EXPECT_EQ(add(4,3), 7); // 断言检测两参数是否相等&#125;int main(int argc, char **argv)&#123; testing::InitGoogleTest(&amp;argc, argv); // 初始化，所有测试都是这里启动的 return RUN_ALL_TESTS(); // 运行所有测试用例&#125; 编译代码，当然你可以用 make 或者 cmake 编译都可以，具体输出：123456[==========] Running 1 test from 1 test case.[----------] Global test environment set-up.[----------] 1 test from testCase[ RUN ] testCase.test0[ OK ] testCase.test0 (0 ms)[----------] 1 test from testCase (0 ms total) 工业生产上面这种测试方法比较特殊，等于是把 gtest 库和 gnu c 库一样使用了，正常工作项目中，肯定不会这样用的。 正确的做法是 以第三方库的形式直接将源码引入进项目。可能有人就会说了，为什么一定要将源代码引入其中，而不先编译出静态库，然后导入其中呢，这样编译自己项目的时候不就不用再重新编译了吗？ 这里主要是考虑 跨平台，编译环境会有多种，需要多次编译，因此需要源码导入，同宿主项目一起编译。 我比较熟悉的编译工具是 cmake, 工作中使用的也是这个，该工具也是跨平台的，在编译大型跨平台项目时，很有优势，那这边就大致讲一下引入步骤，如果你对 cmake 很熟悉，那这边就很轻松了。 首先看一下引入后的代码结构，如下图： 重点是这个文件 unit_test/CMakeLists.txt ：1234567891011121314151617181920212223242526file(GLOB SRC_FILES ./*.cpp)file(GLOB HEADER_FILES ./*.h)# 将给定目录添加到编译器用于搜索包含文件的目录中。相对路径被解释为相对于当前源目录。# 相当于gcc命令的-I，告诉编译器到该目录中查找头文件include_directories($&#123;CMAKE_SOURCE_DIR&#125;/src)if(ENABLE_TEST) include_directories( $&#123;CMAKE_SOURCE_DIR&#125;/3rdlib/googletest/googlemock/include $&#123;CMAKE_SOURCE_DIR&#125;/3rdlib/googletest/googletest/include )endif()# 生成可执行文件 posix_thread_test.exx add_executable(posix_thread_test.exx $&#123;SRC_FILES&#125; )# 引入 gtest 库，posixthread 为源代码库target_link_libraries(posix_thread_test.exx gtest posixthread )target_install(posix_thread_test.exx) 导入项目，主要就是看 unit_test/CMakeLists.txt 这个文件了，其他基本变化不大，如果你熟悉 cmake 很容易就能看懂。 至于图中的源码，是最近在封装 Posix-thread 时写的，源码大部分引用了陈硕老师的 muduo 网络库中的线程相关代码。 gtest 具体使用介绍一下断言，断言主要用来做一些逻辑判断，主要有以下两类接口: ASSERT_XXX()： 如果断言失败，则测试处理终止。 EXPECT_XXX()： 非致命性失败，允许继续处理。 Test Fatal NonFatal condition 为真 ASSERT_TRUE(condition) EXPECT_TRUE(condition) condition 为假 ASSERT_FALSE(condition) EXPECT_FALSE(condition) Equal ASSERT_EQ(arg1,arg2) EXPECT_EQ(arg1,arg2) Not Equal ASSERT_NE(arg1,arg2) EXPECT_NE(arg1,arg2) Less Than ASSERT_LT(arg1,arg2) EXPECT_LT(arg1,arg2) Less Than or Equal ASSERT_LE(arg1,arg2) EXPECT_LE(arg1,arg2) Greater Than ASSERT_GT(arg1,arg2) EXPECT_GT(arg1,arg2) Greater Than or Equal ASSERT_GE(arg1,arg2) EXPECT_GE(arg1,arg2) C String Equal ASSERT_STREQ(str1,str2) EXPECT_STREQ(str1,str2) C String Not Equal ASSERT_STRNE(str1,str2) EXPECT_STRNE(str1,str2) C String Case Equal ASSERT_STRCASEEQ(str1,str2) EXPECT_STRCASEEQ(str1,str2) C String Case Not Equal ASSERT_STRCASENE(str1,str2) EXPECT_STRCASENE(str1,str2) Verify that exception is thrown ASSERT_THROW(statement,exception_type) EXPECT_THROW(statement,exception_type) Verify that exception is thrown ASSERT_ANY_THROW(statement) EXPECT_ANY_THROW(statement) Verify that exception is NOT thrown ASSERT_NO_THROW(statement) EXPECT_NO_THROW(statement) 测试代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;gtest/gtest.h&gt;#include &lt;posix_thread.h&gt;void threadFunc()&#123; std::cout &lt;&lt; "tid= "&lt;&lt; PosixThread::CurrentThread::tid() &lt;&lt; std::endl;&#125;TEST(PosixThreadTest, CreateThread)&#123; std::cout &lt;&lt; "pid= " &lt;&lt; ::getpid() &lt;&lt; " tid= " &lt;&lt;PosixThread::CurrentThread::tid() &lt;&lt; std::endl; PosixThread::Thread t1(threadFunc); t1.start(); ASSERT_TRUE(t1.started()); EXPECT_FALSE(t1.started()); // 故意失败 ASSERT_FALSE(t1.started()); // 故意失败 std::cout &lt;&lt; "t1.tid: " &lt;&lt; t1.tid() &lt;&lt; std::endl; std::cout &lt;&lt; "thread name: " &lt;&lt; t1.name().c_str() &lt;&lt; std::endl; t1.join(); std::cout &lt;&lt; "CreateThread end !\n" &lt;&lt; std::endl;&#125;TEST(AtomicTest, AtomicInt64)&#123; std::cout &lt;&lt; "pid= " &lt;&lt; ::getpid() &lt;&lt; " tid= " &lt;&lt;PosixThread::CurrentThread::tid() &lt;&lt; std::endl; PosixThread::AtomicInt64 a0; ASSERT_EQ(a0.get(), 0); ASSERT_EQ(a0.getAndAdd(1), 0); ASSERT_EQ(a0.get(), 1); ASSERT_EQ(a0.addAndGet(2), 3); ASSERT_EQ(a0.get(), 3); ASSERT_EQ(a0.incrementAndGet(), 4); ASSERT_EQ(a0.get(), 4); a0.increment(); ASSERT_EQ(a0.get(), 5); ASSERT_EQ(a0.addAndGet(-3), 2); ASSERT_EQ(a0.getAndSet(100), 2); ASSERT_EQ(a0.get(), 100);&#125; 执行结果：12345678910111213141516171819202122232425262728293031bash-4.2$ ./output/bin/posix_thread_test.exx [==========] Running 2 tests from 2 test cases.[----------] Global test environment set-up.[----------] 1 test from PosixThreadTest[ RUN ] PosixThreadTest.CreateThreadpid= 5297 tid= 5297tid= 5298/home/willy/myshare/thread-pool/unit_test/thread_test.cpp:16: FailureValue of: t1.started() Actual: trueExpected: false/home/willy/myshare/thread-pool/unit_test/thread_test.cpp:17: FailureValue of: t1.started() Actual: trueExpected: false[ FAILED ] PosixThreadTest.CreateThread (0 ms)[----------] 1 test from PosixThreadTest (0 ms total)[----------] 1 test from AtomicTest[ RUN ] AtomicTest.AtomicInt64pid= 5297 tid= 5297[ OK ] AtomicTest.AtomicInt64 (0 ms)[----------] 1 test from AtomicTest (0 ms total)[----------] Global test environment tear-down[==========] 2 tests from 2 test cases ran. (0 ms total)[ PASSED ] 1 test.[ FAILED ] 1 test, listed below:[ FAILED ] PosixThreadTest.CreateThread 1 FAILED TEST 从执行结果，我们可以很清楚的知道测试用例具体执行到哪一步，如果失败了，我们可以看到具体是哪一行代码出问题了，程序预期结果是什么，但是实际结果又是什么，输出十分详细。 我们还可以将测试结果导出到 xml 文件，通过参数：--gtest_output 实现。1234567891011121314151617181920bash-4.2$ ./output/bin/posix_thread_test.exx --gtest_output="xml:./test.xml"bash-4.2$ cat test.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;testsuites tests="2" failures="1" disabled="0" errors="0" timestamp="2019-01-04T21:36:40" time="0" name="AllTests"&gt; &lt;testsuite name="PosixThreadTest" tests="1" failures="1" disabled="0" errors="0" time="0"&gt; &lt;testcase name="CreateThread" status="run" time="0" classname="PosixThreadTest"&gt; &lt;failure message="/home/willy/myshare/thread-pool/unit_test/thread_test.cpp:16&amp;#x0A;Value of: t1.started()&amp;#x0A; Actual: true&amp;#x0A;Expected: false" type=""&gt;&lt;![CDATA[/home/willy/myshare/thread-pool/unit_test/thread_test.cpp:16Value of: t1.started() Actual: trueExpected: false]]&gt;&lt;/failure&gt; &lt;failure message="/home/willy/myshare/thread-pool/unit_test/thread_test.cpp:17&amp;#x0A;Value of: t1.started()&amp;#x0A; Actual: true&amp;#x0A;Expected: false" type=""&gt;&lt;![CDATA[/home/willy/myshare/thread-pool/unit_test/thread_test.cpp:17Value of: t1.started() Actual: trueExpected: false]]&gt;&lt;/failure&gt; &lt;/testcase&gt; &lt;/testsuite&gt; &lt;testsuite name="AtomicTest" tests="1" failures="0" disabled="0" errors="0" time="0"&gt; &lt;testcase name="AtomicInt64" status="run" time="0" classname="AtomicTest" /&gt; &lt;/testsuite&gt;&lt;/testsuites&gt; 此外，在运行可执行目标程序时，可以使用 --gtest_filter 来指定要执行的测试用例，支持字符串正则匹配，主要如下几种常用情况：123456./output/bin/posix_thread_test.exx 没有指定filter，运行所有测试；./output/bin/posix_thread_test.exx --gtest_filter=* 指定filter为*，运行所有测试；./output/bin/posix_thread_test.exx --gtest_filter=PosixThreadTest.* 运行测试用例FooTest的所有测试；./output/bin/posix_thread_test.exx --gtest_filter=*Null*:*Thread* 运行所有全名；./output/bin/posix_thread_test.exx --gtest_filter=PosixThreadTest.*-PosixThreadTest.CreateThread 运行测试用例FooTest的所有测试，但不包括PosixThreadTest.CreateThread。 gtest 还有很多方便你测试的功能，包括 事件机制, 参数化, 死亡测试, 运行参数等，我们点到为止，如果想继续深入，可以参考这位博主的 gtest 系列, 很详细：玩转Google开源C++单元测试框架Google Test系列 googlemock 使用googlemock，是用于编写和使用C++ 模拟类的框架，在我们工作中，主要用来模拟应用程序的一部分，在单元测试用例编写过程中，常常需要编写模拟对象来隔离被测试单元的“下游”或“上游”程序逻辑或环境，从而达到对需要测试的部分进行隔离测试的目的，它可以帮助我们获得更好的系统设计并编写更好的测试。googlemock 同样遵循 New BSD License（可用作商业用途）的开源项目。 在开发过程中，经常出现各联调模块间，进度不一的情况；测试环境非常不稳定，易导致测试失败，导致达不到单元测试的目的，模仿对象提供了解决这些问题的方法：模仿对象符合实际对象的接口，但只包含用来“欺骗”测试对象并跟踪其行为的必要代码。因此，其实现往往比实际实现类简单很多。 官方教程： https://github.com/google/googletest/blob/master/googlemock/docs/ForDummies.md 官方的 Tutorial 讲的很详细，我在github上也找了一个使用例子，很简洁，但是能很好的说明问题，大致代码如下：mail_service.h文件：123456789101112131415161718#ifndef MAIL_SERVICE_HPP#define MAIL_SERVICE_HPP/** \brief Mail service. This represents one of the collaborators of the SUT. * \author David Stutz */// 邮件服务class MailService&#123;public: /** \brief Send a mial. * \param[in] message message to send */ virtual void send(std::string message) = 0; &#125;;#endif /* MAIL_SERVICE_HPP */ order.h文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#ifndef ORDER_HPP#define ORDER_HPP#include &lt;string&gt;#include &lt;memory&gt;#include "warehouse.h"#include "mail_service.h"/** \brief An order of a product with quantity. */// 订单class Order&#123;public: /** \brief Constructor. * \param[in] quantity quantity requested * \param[in] product product name requested */ Order(int quantity, std::string product) &#123; this-&gt;quantity = quantity; this-&gt;product = product; &#125; /** \brief Set the mail service to use. * \param[in] mailService the mail service to attach */ // 设置邮件服务 void setMailService(std::shared_ptr&lt;MailService&gt; mailService) &#123; this-&gt;mailService = mailService; &#125; /** \brief Fill the order given the warehouse. * \param[in] warehouse the warehouse to use * \return whether the operation was successful */ // 判断产品是否有库存，发送邮件通知 bool fill(Warehouse &amp;warehouse) &#123; if (warehouse.hasInventory(quantity, product)) &#123; // ... warehouse.remove(quantity, product); this-&gt;mailService-&gt;send("Order filled."); return true; &#125; else &#123; // ... this-&gt;mailService-&gt;send("Order not filled."); return false; &#125; &#125; private: /** \brief Product name. */ std::string product; /** \brief Quantity requested. */ int quantity; /** \brief Mail service to use. */ std::shared_ptr&lt;MailService&gt; mailService;&#125;;#endif /* ORDER_HPP */ warehouse.h文件：1234567891011121314151617181920212223242526272829#ifndef WAREHOUSE_HPP#define WAREHOUSE_HPP#include &lt;string&gt;/** \brief Warehouse interface. This interface is one of the collaborators of our SUT. * \author David Stutz */class Warehouse&#123;public: /** \brief Check whether the product in the given quantity is on stock. * \param[in] quantity quantity requested * \param[in] product product name * \return whether the warehouse has the product on stock for the given quantity */ // 是否有库存 virtual bool hasInventory(int quantity, std::string product) const = 0; /** \brief Remove the given quantity of the product from the warehouse. * \param[in] quantity quantity to remove * \param[in] product product name to remove */ // 从库存中删除 virtual void remove(int quantity, std::string product) = 0; &#125;;#endif /* WAREHOUSE_HPP */ 主要场景就是处理产品订单，其中库存Warehouse类和邮件服务MailService类，我们只声明一下虚基类，不实现，然后通过模拟对象的方式mock一下Warehouse和MailService，来达到订单类接口测试的正常开展，具体测试代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;gmock/gmock.h&gt;#include "lib/mail_service.h"#include "lib/order.h"#include "lib/warehouse.h"using ::testing::Return;using ::testing::_; // Matcher for parametersclass MockWarehouse : public Warehouse&#123;public: // see https://github.com/google/googletest/blob/master/googlemock/docs/ForDummies.md MOCK_CONST_METHOD2(hasInventory, bool(int, std::string)); MOCK_METHOD2(remove, void(int, std::string));&#125;;class MockMailService : public MailService&#123;public: MockMailService() &#123; &#125; MOCK_METHOD1(send, void(std::string));&#125;;TEST(OrderTest, Fill)&#123; MockWarehouse warehouse; std::shared_ptr&lt;MockMailService&gt; mailService = std::make_shared&lt;MockMailService&gt;(); Order order(50, "Talisker"); order.setMailService(mailService); EXPECT_CALL(warehouse, hasInventory(50, "Talisker")) .Times(1) .WillOnce(Return(true)); EXPECT_CALL(warehouse, remove(50, "Talisker")) .Times(1); EXPECT_CALL(*mailService, send(_)) // Not making assumptions on the message send ... .Times(1); ASSERT_TRUE(order.fill(warehouse));&#125;int main(int argc, char **argv)&#123; testing::InitGoogleMock(&amp;argc, argv); // Runs all tests using Google Test. return RUN_ALL_TESTS();&#125; 测试结果：1234567891011bash-4.2$ ./output/bin/order.exx [==========] Running 1 test from 1 test case.[----------] Global test environment set-up.[----------] 1 test from OrderTest[ RUN ] OrderTest.Fill[ OK ] OrderTest.Fill (0 ms)[----------] 1 test from OrderTest (0 ms total)[----------] Global test environment tear-down[==========] 1 test from 1 test case ran. (1 ms total)[ PASSED ] 1 test. 其中main函数和gtest差不多，只是初始化的是googlemock，我们着重了解的是几个宏的含义: MOCK_METHOD1234MOCK_METHOD#1(#2, #3(#4) )MOCK_CONST_METHOD2(hasInventory, bool(int, std::string));MOCK_METHOD2(remove, void(int, std::string)); 其中#1表示你要mock的方法共有几个参数，#2是你要mock的方法名称，#3表示这个方法的返回值类型，#4是这个方法具体的参数。 EXPECT_CALL1234using ::testing::Return;EXPECT_CALL(warehouse, hasInventory(50, "Talisker")) .Times(1) .WillOnce(Return(true)); 设定期望对象被访问的方式及其响应，其中warehouse为对象，希望hasInventory在传递参数为(50, “Talisker”)时，被调用且仅被调用一次，第一次返回true。 ON_CALL12345ON_CALL(#1, #2(#3)).WillByDefault(Return(#4));ON_CALL(foo, GetSize()) .WillByDefault(Return(1)); // ... other default actions ... 其中#1表示mock对象，#2表示个方法名称，#3表示方法的参数，#4表示参数为#1, #2，#3情况下返回结果。 ON_CALL和EXPECT_CALL的区别? ON_CALL定义了调用mock方法时会发生什么，但并不意味着对被调用方法的任何期望。 EXPECT_CALL不仅定义了行为，还设置了对给定次数（以及在指定顺序时按给定顺序）使用给定参数调用方法的期望。 GoogleMock 为开发者设定 Mock 类行为，跟踪程序运行过程及结果，提供了丰富的支持。但与此同时，应用程序也应该尽量降低应用代码间的耦合度，使得单元测试可以很容易对被测试单元进行隔离。(尽量做到高内聚，低耦合) 总结Googletest 与 GoogleMock，很好的简化了我们的C++单元测试工作，本篇文章对此做了一个总结，让自己对gtest有了一个系统的认识。测试并不只是测试工程师的责任，对于开发工程师，为了保证发布给测试环节的代码具有足够好的质量（ Quality ），为所编写的功能代码编写适量的单元测试是十分必要的。 如果还想更加深入的了解，可查阅官方文档： https://github.com/google/googletest/tree/master/googlemock/docs 参考链接 https://www.ibm.com/developerworks/cn/linux/l-cn-cppunittest/?mhq=gtest&amp;mhsrc=ibmsearch_ahttps://blog.csdn.net/russell_tao/article/details/7344739http://www.cnblogs.com/coderzh/archive/2009/03/31/1426758.htmlhttps://github.com/davidstutz/googlemock-example]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你有困惑吗]]></title>
    <url>%2F2018%2F12%2F15%2F%E4%BD%A0%E6%9C%89%E5%9B%B0%E6%83%91%E5%90%97%2F</url>
    <content type="text"><![CDATA[工程师层级人员讨论会 – 2018-12-7 上周，部门主管黄总和HR组织了一场讨论会，召集了大概20个开发，大概水平都是处于工程师层级，这个层级评定和你工作年龄无关，而是和你的工作产出，负责项目相关。在我看来，过去的大部分都是业务骨干，因为基本涉及部门所有产品线的所有开发人员，有工作两年的，工作4年，5年，8年的。确实，软件开发和年龄其实关系不大，而是和你负责的业务，技术水平相关。如果你负责公司的核心业务开发，只要你能支撑下来，就算你工作年限不长，技术水平不广，不深，但是因为你处在这个位置上，因此你也很有价值，但是话又说回来，如果你工作很多年，还是处于这个层级，那就确实是要考虑一下了，因为你陷入了一个瓶颈，可能工作中80%-90%的时间都是做一些常规项目，而且是做完这一个接着又做下一个。 因此对于多年处于这个阶段的人来说，是安排的工作太简单了，得不到提高，还是干活的人想的太简单，这个需要自身考虑清楚。 今天讨论会主要分为两个阶段，第一阶段，首先大家分为4个小组，然后每个组讨论，将自己工作中遇到的困惑，瓶颈，以及一些需要外部协助的点(包括公司层面，其他部门等)列出来。 总的说下来，大概就是以下几点： 项目周期太紧，需求开发时间安排不合理，整个项目中，产品部需求评审耗费时间较长，需求评审时，测试部也参与，而测试部往往疑问较多，导致评审周期拉的很长。(克服方法：尽量线上解决或者只参与自己负责的需求; 提前熟悉相关需求，做到提前量) 项目中，分配的模块整改，代码重构时间较短。导致重构做的不彻底，挖的不够深，整体性能和设计上，做的效果不明显。(克服方法：尽量早的提出预研，拉长时间周期；如果是影响后续大版本开发的重构，那没办法，必须做) 多线程工作，一个人同一个时间身上负责多个项目。在日常工作中，因为参与项目较多，导致工作经常性的被人打断，在多个项目中切换，效率很低。(克服方法：分析问题和编码，做好整体思路存档标记，问题处理完回来可以无缝切回来；对于插入问题，预先进行分析评估，短时间解决不了，另行安排时间，不纠缠) 工作中做的 90% 多都是常规工作，技术提升的、绩效突破性工作安排较少。(克服方法：自己向上级反馈, 主动提出) 最后一点是我对自己提出的，接触的模块多，技术点也多，但是由于总结意愿不强烈，导致很多东西掌握的不够系统，不够深入，当然也有一部分时间上的限制就是了(项目紧，工作忙) (克服方法：加强写总结的习惯，反省自己) 与外部对接方面工作，推动力不足，主导意愿不强，很多时间往往浪费在沟通和踢皮球上，对工作毫无进展。(克服方法：改变态度，无论是现在公司，还是以后的工作中，对于参与工作，要与担当，积极主动的去推进) 上述大部分遇到的问题，都是很多公司的问题，并不是公司独有，黄总也说面试过很多人，这些问题都是客观存在的，如果你能把这些克服，做好，那提升会很明显，一句话，效率最重要。 第二个阶段，提出四个需求，让大家进行讨论，给出一个大致的想法，思考方式。每个组选择了同一个，如下： 需求1：公司一款产品，之前支持存储5000个联系人，现在客户反馈不够，需要能支持5万个。 最后大家讲了一遍，给出的总体流程和思路如下： 可行性分析，该产品之前支持5000个，现在要升级一个数量级，基于现有系统的内存和CPU频率，是否能够支持这么多联系人的存储、搜索工作。 需求分析，之前方案设计实现背景，是否可以在之前方案上直接进行拓展; 竞品和公司其他产品线是否有相关方案的支持，如果支持，是否可以直接借鉴和复用; 现在是要求5万，后续如果再升级到10万，30万，50万，选择的方案是否可以支持，需要向拓展性上考虑 在原有方案下拓展优化，还是说对整个框架进行重构，如果重构，是要引进什么新的技术吗? 数据库? 如果引入新的技术，那如何保证整个系统的鲁棒性和可移植性，因为后续可能不止你一个产品要用，可能将方案适配到多个平台上去。 方案选择好后，需要同相关涉及模块的开发人员，一起讨论，对外进行评审，排除各个模块的风险 设计文档编写，给出整体的思维导图，理清各模块间交互，保证方案的拓展性和易维护性，方案整体要在时间和空间上进行平衡，保证搜索和存储都较好满足，某些场景可能需要牺牲空间来满足搜索的速度，而某些相反，最后将相关接口评审完毕，进入开发 开发完成后，需要编写相关测试用例，包括引入相关测试框架进行单元测试，性能测试，内存检测等。编写测试导图，以便测试部能够更好的展开测试工作 异常场景考虑，在开发和自测过程中，要将异常场景考虑在内，如果采用的是云端联系人存储，临时拉取方案，那如果向服务器请求时，出现丢失该如何处理；在满载，高负载场景下，是否会有异常，UI表现是否正常；是否要加入相关请求的防抖动处理，一句话，开发人员也要有测试思维，加强异常极限场景考虑。 大概就是上面两个事，总的来说收获是有的，对于测试这一块还需要做的更好，相关开源测试框架和性能工具需要多加使用。总的来说，勤写总结，吾日三省吾身，找到效率瓶颈，提升效率，提升技术水平是没错的。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程间通信-消息队列]]></title>
    <url>%2F2018%2F11%2F24%2F%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-2018-11-24%2F</url>
    <content type="text"><![CDATA[Message Queue 使用场景今天介绍一下消息队列，对此做个总结，酝酿了有一段时间，因为消息队列在开发中占据了一个很重要的地位。 一般这种系统设施，如果你是在 Linux 系统用户空间进行开发(内核开发除外的所有开发)，需要懂得其原理、接口使用、消息框架构建机制、封装系统提供的 MQ 接口来对上层提供服务。如果你是从事内核开发，那还需要将这些系统设施的实现了解清楚。我现在做的是系统应用层开发，就以我现在公司为例，开发的是嵌入式系统设备，之前公司消息机制使用的是 Linux 系统自带的消息队列，System V 那一套，后来因为系统资源确实匮乏，如果直接使用原生的消息队列机制，并发量太高的话，系统性能会下降(因为芯片太低端，而使用消息队列的功能模块在增加)，所以自己开发了一套消息机制，实现思路以及对外接口和原来差别不大。本次主要介绍 System V 和 Posix 消息队列使用和与之相关的设计模式。 消息队列（Message Queue），不仅是分布式系统中重要的组件, 也是我们客户机系统开发中的一个重要组件，特别是我们公司现在开发的系统，可以说完全是由消息驱动的系统，无论是进程间，还是进程内部，消息队列的发布/订阅模式，支撑起了整个系统框架。 首先，消息队列的使用场景主要有以下几个： 异步处理 非核心流程异步化，提高系统响应性能。发布者只需将消息通知出去，然后就可以去做其他事情。 程序解耦 对于不强依赖于非本系统的核心流程，可以放到消息队列中让消息消费者去按需消费，而不影响核心主流程，做到业务功能模块解耦 广播 发布/订阅模式，一个消息，可以多个对象定阅处理 流量削峰与流控 对于网络秒杀活动，消息队列可做缓冲处理 1.请求先入消息队列，而不是由业务处理系统直接处理，做了一次缓冲,极大地减少了业务处理系统的压力； 2.队列长度可以做限制，事实上，秒杀时，后入队列的用户无法秒杀到商品，这些请求可以直接被抛弃，返回活动已结束或商品已售完信息； 消息驱动的系统 避免直接调用下一个系统导致当前系统失败； 每个子系统对于消息的处理方式可以更为灵活，可以选择收到消息时就处理，可以选择定时处理，也可以划分时间段按不同处理速度处理； 通知其他系统做某些事情 以我现在公司的系统为例，上述场景除了流量削峰( 偏服务端 )，其他基本都有在系统中出现。公司开发的是通信终端系统，主要模块分为: GUI, 网络, 声音，协议等, 各模块都是系统中单独的一个进程, 各个进程间需要通信，则通过发消息的方式，十分方便; 同时进程内部也通过消息队列，对相关业务量比较重的核心模块，进行代码重构、解耦, 把一些非核心流程剥离出去，通过发消息的方式通知对应模块进行处理。 封装的接口形式和 windows 端的消息机制接口类似：1234msgPostMsgToThread() // 发送到特定线程msgBroadpostThreadMsg() // 广播etl_RegisterMsgHandle(TM_TIMER, TM_TIMER, &amp;CStatusManager::OnTimerMsgProgress); //订阅 通过上述接口，我们可以很方便的通知其他进程，并携带上相应的数据，完成进程间通信。消息机制完全采用发布/订阅模式。系统一启动，首先各个进程模块进行初始化操作，每个线程/进程会创建一个消息队列，进程中的各个模块按需调用 etl_RegisterMsgHandle() 接口，订阅消息。然后系统中各进程/线程间，会进行消息的定点发送或者广播，收到消息的进程则调用初始化时注册的 handle() 接口进行处理。 发布/订阅模式 (Publish-Subscribe) 首先介绍一下不包含消息队列的发布/订阅模式，我们先引用一下 20 年前的一本经典著作 GoF 中对发布/订阅模式的介绍, 发布/订阅模式别名观察者(observer), 依赖(Dependents), 该模式是一种对象行为型模式. 模式意图： 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。 模式结构类图 (引用自: GOF设计模式解析)主要角色： Subject: 目标 Observer: 观察者 传统的观察者模式的优点： 观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。 观察者模式在观察目标和观察者之间建立一个抽象的耦合。 观察者模式支持广播通信。 观察者模式符合”开闭原则”的要求。 观察目标和观察者之间不是紧密耦合，可以说建立了一个抽象耦合，观察者是知道Subject的，Subject也一直保持对观察者进行记录。然而在包含消息队列的发布/订阅模型中，发布者和订阅者并不知道对方的存在，它们只通过消息代理进行通信，组件是松散耦合的，而且观察者模式大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法。而包含消息队列的发布-订阅模式大多数时候是异步的（使用消息队列）。观察者模式需要在单个应用程序地址空间中实现，而发布-订阅更像交叉应用模式。 传统的观察者模式与包含消息队列的发布/订阅模型模式关系类似下图： POSIX 消息队列简单使用System V API 和 POSIX API 提供了消息队列，我们主要介绍一下 POSIX 特点： POSIX 和 System V 实现中的消息队列都具有内核级持续性 POSIX 主要接口信息：123456789101112131415161718192021222324252627282930313233343536373839404142#include: mqueue.h (sys/stat.h 用于在创建队列时使用权限宏)main types:1. mqd_t: 消息队列描述符2. struct mq_attr: 消息队列属性结构，定义如下： struct mq_attr &#123; long int mq_flags; /* Message queue flags. */ long int mq_maxmsg; /* Maximum number of messages. */ long int mq_msgsize; /* Maximum message size. */ long int mq_curmsgs; /* Number of messages currently queued. */ &#125;functions： mqd_t mq_open(const char *name, int flags, ... [ mode_t mode, struct mq_attr *mq_attr ])description：name消息队列名字; flags 用来表示打开消息队列的权限组合; 如果是以创建方式打开，则需要设置相应 的访问权限mode; 设置消息队列属性 mq_attr.return：返回消息描述符，或者（mqd_t）-1出错functions： int mq_close(mdq_t mqdes) return： 成功返回 0，错误返回 -1functions： int mq_unlink(const char *name)return： 成功返回 0，错误返回 -1functions：int mq_send(mqd_t mqdes, const char *msgbuf, size_t len, unsigned int prio)return： 成功返回 0，错误返回 -1functions：size_t mq_receive(mqd_t mqdes, char *buf, size_t len, unsigned *prio)return： 成功返回 0，或者（mqd_t）-1出错functions： int mq_getattr(mqd_t mqdes, struct mq_attr *mq_attr)return： 成功返回 0，或者（mqd_t）-1出错functions：int mq_setattr(mqd_t mqdes, const struct mq_attr *mqstat, struct mq_attr *omqstat)return： 成功返回 0，或者（mqd_t）-1出错functions：int mq_setattr(mqd_t mqdes, const struct mq_attr *mqstat, struct mq_attr *omqstat)return： 成功返回 0，或者（mqd_t）-1出错functions：int mq_notify(mqd_t mqdes, const struct sigevent *sevp);description： 在有消息时注册通知return：成功返回 0，或者（mqd_t）-1出错注： 编译时需要链接 rt 库 (Link with -lrt.) 模拟使用场景：1234* 模拟场景* 1. 总共三个进程，一个程序负责创建消息队列，一个发送消息，最后一个负责接收* 2. 接收程序使用 mq_notify 注册信号来处理消息从无到有的场景* 具体实现代码如下： cmake 程序 12345678910111213cmake_minimum_required(VERSION 2.8)add_definitions(-std=c++11)project(message_queue C CXX)aux_source_directory(. SRC_FILES)add_executable(message_queue $&#123;SRC_FILES&#125;)target_link_libraries(message_queue rt ) mq_create: 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include "errno.h"#include &lt;fcntl.h&gt; /* For O_* constants */#include &lt;sys/stat.h&gt; /* For mode constants */#include &lt;mqueue.h&gt;#define ERR_EXIT(m) \ do \ &#123; \ perror(m); \ exit(EXIT_FAILURE); \ &#125; while (0);int main(int argc, char * argv[])&#123; mqd_t mqid; mqid = mq_open("/zed", O_CREAT | O_RDWR, 0666, NULL); if (mqid == (mqd_t) - 1) &#123; ERR_EXIT("mq_open"); &#125; struct mq_attr attr; mq_getattr(mqid, &amp;attr); printf("max msg numb: [%ld], mq_msgsize: [%ld] byte, current msg size: [%ld], mq_flags[%ld]", attr.mq_maxmsg, attr.mq_msgsize, attr.mq_curmsgs, attr.mq_flags); mq_close(mqid); return 0;&#125; mq_send: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include "errno.h"#include &lt;fcntl.h&gt; /* For O_* constants */#include &lt;sys/stat.h&gt; /* For mode constants */#include &lt;mqueue.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define ERR_EXIT(m) \ do \ &#123; \ perror(m); \ exit(EXIT_FAILURE); \ &#125; while (0);typedef struct stu&#123; char data[32]; int index;&#125;STU;int main(int argc, char * argv[])&#123; mqd_t mqid; mqid = mq_open("/zed", O_RDONLY); if (mqid == (mqd_t) - 1) &#123; ERR_EXIT("mq_open"); &#125; STU stu; stu.index = 20; strcpy(stu.data, "my name is yejy"); printf("stu.data [%s], stu.index [%d]\n", stu.data, stu.index); mq_send(mqid, (const char*)&amp;stu, sizeof(stu), 1); struct mq_attr attr; mq_getattr(mqid, &amp;attr); printf("max msg numb: [%ld], mq_msgsize: [%ld] byte, current msg size: [%ld], mq_flags[%ld] \n", attr.mq_maxmsg, attr.mq_msgsize, attr.mq_curmsgs, attr.mq_flags); mq_close(mqid); return 0;&#125; mq_receive: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include "errno.h"#include &lt;fcntl.h&gt; /* For O_* constants */#include &lt;sys/stat.h&gt; /* For mode constants */#include &lt;mqueue.h&gt;#include &lt;signal.h&gt;#define ERR_EXIT(m) \ do \ &#123; \ perror(m); \ exit(EXIT_FAILURE); \ &#125; while (0);typedef struct stu&#123; char data[32]; int index;&#125;STU;struct sigevent sigev;mqd_t mqid;size_t size;void handle_sigusr1(int sig)&#123; mq_notify(mqid, &amp;sigev); // need registered again STU stu; unsigned int prio; if(mq_receive(mqid, (char*)&amp;stu, size, &amp;prio) == (mqd_t) -1) &#123; ERR_EXIT("mq_receive"); &#125; printf("data=[%s], index = [%d], prio = [%d]", stu.data, stu.index, prio);&#125;int main(int argc, char * argv[])&#123; mqid = mq_open("/zed", O_RDONLY); if (mqid == (mqd_t) - 1) &#123; ERR_EXIT("mq_open"); &#125; struct mq_attr attr; mq_getattr(mqid, &amp;attr); size = attr.mq_msgsize; printf("max msg numb: [%ld], mq_msgsize: [%ld] byte, current msg size: [%ld], mq_flags[%ld]\n", attr.mq_maxmsg, attr.mq_msgsize, attr.mq_curmsgs, attr.mq_flags); // signal signal(SIGUSR1, handle_sigusr1); sigev.sigev_notify = SIGEV_SIGNAL; sigev.sigev_signo = SIGUSR1; mq_notify(mqid, &amp;sigev); // Message from nothing, notify handle for (;;); // loop keep process execute mq_close(mqid); return 0;&#125; 总结对于相关设计模式需要懂得其原理与实现，毕竟这些是前人总结出来的宝贵经验，对我们的软件设计思维非常有帮助；至于消息队列，主要介绍了一下其思想与用途，以及对 POSIX 的消息队列接口做了一个简单模拟实现，了解了消息队列的基本使用。当然，作为计算机系统中的一个重要组件，在后端开发中，有很多优秀的消息队列中间件，后续有机会从事相关开发，再进行深入了解，通过此次文章总结，如果下次遇到消息队列相关问题和开发任务，应该会比较得心应手。]]></content>
      <tags>
        <tag>多线程编程</tag>
        <tag>操作系统</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不一样的周一]]></title>
    <url>%2F2018%2F11%2F19%2F%E9%9A%8F%E7%AC%94-%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%91%A8%E4%B8%80-2018-11-19%2F</url>
    <content type="text"><![CDATA[今天是 2018-11-19 日，周一，和以往的周一不太一样，首先我旁边少了一个人，导师加主管，上周离职了，惊讶加不解。不解的是公司发展到现在不容易，而他做到这个位置同样不易，而且已经不搞技术很久了，年龄也到了不惑有一，如果离开现在公司，外面还有更好的地方可以去吗？在我的印象里，他走的就是传统的程序员模式，从程序员开始，然后做Teamleader，最后是主管，这时候无需码代码，搞技术，整天就是开这个会那个会、需求评审、项目例会等等，忙的不可开交。到了这个时候，他最大的价值就是对公司的业务了如指掌，非常熟悉，基本每个功能点他都可以摸清楚。我在想，到这种地步，应该会一直呆公司吧，毕竟如果离开，成本太大了，去到新公司，要熟悉新业务不说，可能还要重新将拾起许久技术。 当然，他能够对现在业务摸的这么清楚，而且问题分析能力很强，逻辑思维很好，表达能力也强，十分善于沟通，项目管理这一块也很熟悉，所以优点是很明显的，到了新公司，我相信他也可以十分迅速的掌握新公司的业务，走上管理岗位。 第一个导师加主管，而且还是学长，教会了我很多，扮演着引入人的角色，对我十分关照，真的非常感谢。 希望您今后工作顺利，前程似锦！后会有期！ 当然，对我来说，我其实并不喜欢主管之前的状态，完全抛开技术，做管理工作。虽然现在我还比较迷茫，但是大方向还是确定的，我还是要搞技术，只是选哪个方向罢了，我觉得技术对我来说还是比较有吸引力的，毕竟技术改变未来，笑脸！ 今天是周一，像以往一样，我会先在阮一峰老师的博客上，看看有没有什么新鲜事，他是唯一一个可以把技术博客写的如此文艺的人，感觉非常不错。 从中看到印象最深刻的，莫过于计算机科学家 Tim Bray在一篇博客中谈到自己可能退休，但是令人感叹的不是退休，而是他对事物，对工作的态度。 Rea­sons to keep work­ing I get to write soft­ware that fil­ters and routes a mil­lion mes­sages a sec­ond. 编写软件，每秒过滤路由100万个消息 I’m in a po­si­tion where it’s re­al­ly hard for peo­ple not to lis­ten to my opin­ions abouttech­nol­o­gy. I’d be­come amaz­ing­ly un­in­ter­est­ing about fif­teen sec­onds af­ter re­tir­ing. 处于一个别人很难不听取我技术意见的位置 I learn things all the time about how to think about how to use com­put­er­s. 我一直在学习思考如何使用计算机 I get a chance to move the needle, a lit­tle, on the way peo­ple use com­put­er­s. 我有机会在人们使用计算机的方式上移动一针 I like com­put­er­s, and so it makes sense to work for (what I as­sume must be) the world’s largest provider of com­put­ers to peo­ple and busi­ness­es who use them. 我喜欢计算机 现在工作中，我还无法保持这种热情，那我是不是也可以退休了? 非也，我们可以努力培养自己这方面的能力，对事物持续投入热情的能力。虽然，有的时候早上起来还处于 Some morn­ings, I feel like sleep­ing in. 状态，但我相信这只是暂时的 ！ 参考： http://www.ruanyifeng.com/blog/2018/11/weekly-issue-31.htmlhttps://dev.to/acoh3n/why-i-love-java-5c14https://phpocean.com/blog/article/learning-programming-is-different-from-learning-a-programming-language/80]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统-进程互斥和同步]]></title>
    <url>%2F2018%2F11%2F18%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5-2018-11-18%2F</url>
    <content type="text"><![CDATA[背景 为什么会有同步和互斥？ 因为计算机系统中有多个进程存在，多个进程间进行交互，会引起它们对 共享资源的访问，如果这些资源处理不当，就可能出现一些意想不到的情况，比如说 饥饿，死锁等一系列问题。为什么会出现 饥饿，死锁问题，主要还是和进程调度相关。如果进程相对独立，彼此之间没有共享资源，彼此不需要发送数据或者通知对方干某些事情，那么进程和线程的执行过程是确定的，可重复的，那就不存在上述问题。但是如果不独立，彼此间需要进行交互，那么这种情况下，由于 调度系统的管理，有可能一会先调用这个进程，一会又先调用另一个进程，由于进程调度顺序不确定，可能导致对于单个进程而言，执行过程出现不确定性和不可重复性，因此会引入一些很难发现的 bug，导致系统出现不稳定的现象。 上述现象，称为Race Condition(竞态条件)。虽然有上述问题，但是进程间交互，共享资源又是必不可少的，因此我们需要引入同步和互斥来解决上述不确定性问题。 一些基本概念 Atomic Operation (原子操作)原子操作是指一次不存在任何中断或者失败的执行。 Critical Section (临界区) ：满足互斥，前进，有限等待临界区是指进程中的一段需要访问共享资源并且当另一个进程处于相应代码区域时便不会被执行的代码区域。(简单说：访问共享资源的一段代码) Mutual exclusion (互斥)当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源。(简单说：不允许多个进程进入临界区去访问) Dead lock (死锁)两个或以上的进程，在相互等待完成特定任务，而最终没法将自身任务进行下去。(简单说：两个进程需要等待对方的资源而导致无法向下执行) Starvation (饥饿)一个可执行的进程，被调度器持续忽略，以至于虽然处于可执行状态却不被执行。 临界区代码的保护方法 (锁的设计方法) 禁用硬件中断时钟中断，进行进程调度，执行临界区时屏蔽中断 缺点： 临界区执行时间过长，对系统整体执行效率影响很大 多CPU并行执行，屏蔽一个CPU中断不管用，无法解决互斥 基于软件的解决方法除了用在一般操作系统中，也用在分布式系统当中。 皮特森(Peterson)算法flag表示本进程已经准备好了想进去，然后如果两个进程都想进那么就要设立一个turn标志，turn表示如果两个进程都想进去临界区，turn=i就允许i进程进临界区。因为turn只能是一个值，所以也保证了两个进程竞争时只能有一个进去。如果不竞争，那turn无意义。（可使用反证法证明） Dekker算法 针对双线程 Bakery算法 针对n线程临界区问题解决方案 Peterson 算法大致代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;pthread.h&gt;#define true 1#define false 0typedef int bool;bool flag[2];int turn;void procedure0()&#123; while(true) &#123; flag[0] = true; turn = 1; while(flag[1] &amp;&amp; turn == 1)//退出while循环的条件就是，要么另一个线程 //不想要使用关键区，要么此线程拥有访问权限。 &#123; sleep(1); printf("procedure0 is waiting!\n"); &#125; //critical section flag[0] = false; &#125;&#125;void procedure1()&#123; while(true) &#123; flag[1] = true; turn = 0; while(flag[0] &amp;&amp; turn == 0) &#123; sleep(1); printf("procedure1 is waiting!\n"); &#125; //critical section flag[1] = false; &#125;&#125;void main()&#123; pthread_t t1,t2; flag[0] = flag[1] = false; int err; turn = 0; err = pthread_create(&amp;t1,NULL,(void*)procedure0,NULL); if(err != 0) exit(-1); err = pthread_create(&amp;t2,NULL,(void*)procedure1,NULL); if(err != 0 ) exit(-1); pthread_join(t1,NULL); pthread_join(t2,NULL); exit(0);&#125; Dekker 算法大致代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;pthread.h&gt;#define true 1#define false 0typedef int bool;bool flag[2];int turn;void visit(int num)&#123; sleep(1); printf("P%d is visting\n",num);&#125;void P0()&#123; while(true) &#123; flag[0] = true;//P0想使用关键区。 while(flag[1])//检查P1是不是也想用？ &#123; if(turn == 1)//如果P1想用，则查看P1是否具有访问权限？ &#123; flag[0] = false;//如果有，则P0放弃。 while(turn == 1);//检查turn是否属于P1。 flag[0] = true;//P0想使用。 &#125; &#125; visit(0); //访问Critical Partition。 turn = 1; //访问完成，将权限给P1。 flag[0] = false;//P0结束使用。 &#125;&#125;void P1()&#123; while(true) &#123; flag[1] = true; //P1想使用关键区。 while(flag[0]) //检查P0是不是也想用？ &#123; if(turn == 0) //如果P0想用，则查看P0是否具有访问权限？ &#123; flag[1] = false; //如果有，则P1放弃。 while(turn == 0); //检查turn是否属于P0。 flag[1] = true; // P1想使用。 &#125; &#125; visit(1); //访问Critical Partition。 turn = 0; //访问完成，将权限给P0。 flag[1] = false; //P1结束使用。 &#125;&#125;void main()&#123; pthread_t t1,t2; flag[0] = flag[1] = false; turn = 0; int err; err = pthread_create(&amp;t1,NULL,(void*)P0,NULL); if(err != 0) exit(-1); err = pthread_create(&amp;t2,NULL,(void*)P1,NULL); if(err != 0 ) exit(-1); pthread_join(t1,NULL); pthread_join(t2,NULL); exit(0);&#125; 更高级的抽象 (基于硬件原子操作指令，将下述两个流程封装成了机器指令，执行过程中不允许执行中断和切换)Test-and-Set 12345678910111213141516171819202122boolean TestAndSet(boolean *target)&#123; boolean rv = *target; *target = TRUE; return rv;&#125;具体使用例子：class Lock&#123;int value = 0;Acquire();Realease();&#125;;Lock::Acquire()&#123;while(test-and-set(value));//spin (当有进程执行，将value设置成1，其他进程再来执行的时候就一直是1，进入while循环自旋，直到value = 0)&#125;Lock::Realease()&#123;value = 0;&#125; Exchange 123456789101112131415161718void Exchange(boolean *a, boolean *b)&#123; boolean temp = *a; *a = *b; *b = temp;&#125;共享数据： int lock = 0;线程Ti int key; do&#123; key = 1; while(key == 1) Exchange(lock, key); critical section lock = 0; remainder section &#125; 如果觉得进程自旋忙等浪费CPU性能，而且临界区执行时间较长，那可以通过上下文切换，使得等待进程进入阻塞睡眠，当临界区进程执行完，再进行唤醒。是采用忙等还是进行上下文切换让进程进入睡眠，需要看一下临界区执行时间是否很长，如果执行时间长，则让进程进入睡眠。如果临界区执行时间很短，反而上下文切换对CPU损耗时间更长，则采用忙等。 信号量同步机制，临界区多个线程和进程来执行，进入临界区只是做读操作而不是写操作，如果只是读操作，那就没必要只是限制一个进程或者线程执行，可以有多个线程或者进程执行。多个进程或线程那么就要引入信号量来解决这个问题。 数据抽象-&gt; 一个整形(sem)，两个原子操作-&gt; P(): sem减1，如果sem &lt; 0，等待，否则继续执行-&gt; V(): sem加1，如果sem &lt;= 0, 唤醒一个等待的P 信号量特点 信号量是有符号整数一开始我们会设置成一个大于 0 的数，多次进行P()操作，一旦信号量小于0，则执行P()操作的 进程不能再向下执行，该进程就需要挂在该信号量上面。直到有其他进程执行V()操作，而且信 号量还小于等于0，则判断有进程挂在该信号量上面，因此唤醒一个进程 信号量是被保护的变量-&gt; 初始化完成后，唯一改变一个信号量的值得办法是通过P()和V()-&gt; 操作必须是原子的 P() 能够阻塞, V() 不会阻塞 我们假定信号量是 “公平的”FIFO先进先出队列管理挂在信号量上面的进程 两种类型的信号量-&gt; 二进制信号量: 可以是0或者1 (可以完成锁机制功能)-&gt; 一般/计数信号量: 可取任何非负值 (允许多个执行P()操作的进程进入临界区)-&gt; 两者相互表现(给定一个可以实现另一个) 信号量可以用在2个方面-&gt; 互斥-&gt; 条件同步 (调度约束 – 一个线程等待另一个线程的事情发生) 信号量使用 (解决生产者-消费者问题)生产者-消费者正确性要求： 在任何一个时间只能有一个线程操作缓冲区(互斥) 当缓冲区为空，消费者必须等待生产者(调度/同步约束) 当缓冲区满，生产者必须等待消费者(调度/同步约束) 示例伪代码： 123456789101112131415161718192021class BoundedBuffer&#123; mutex = new Semaphore(1); fullBuffers = new Semaphore(0); // 初值为 0 emptyBuffers = new Semaphore(n); // 初值为 n &#125; BoundedBuffer::Deposit(c)&#123; emptyBuffers-&gt;P(); mutex-&gt;P(); Add c to the buffer; mutex-&gt;V(); fullBuffers-&gt;V(); &#125; BoundedBuffer::Remove(c)&#123; fullBuffers-&gt;P(); mutex-&gt;P(); Remove c to the buffer; mutex-&gt;V(); emptyBuffers-&gt;V(); &#125; 信号量的实现大致代码： 1234567891011121314151617181920class Semaphore&#123; int sem; WaitQueue q;&#125;Semaphore::P()&#123; sem--; if(sem &lt; 0)&#123; Add this thread t to q; block(t); &#125;&#125;Semaphore::V()&#123; sem++; if(sem &lt;= 0)&#123; Remove a thread t from q; wakeup(t); &#125;&#125; 管程由于信号量机制的缺点：进程自备同步操作，P(S)和V(S)操作大量分散在各个进程中，不易管理，易发生死锁。因此引入管程的概念，这是一种比信号量更高的抽象。或者说并没有这种实体存在于系统或编程语言中，更多的是一种机制，一种解决方法，但是编程语言和操作系统都提供了实现管程的重要部件条件变量。 管程特点：管程封装了同步操作，对进程隐蔽了同步细节，简化了同步功能的调用界面。用户编写并发程序如同编写顺序(串行)程序。 目的：分离互斥和条件同步的关注 什么是管程：-&gt; 一个锁：指定临界区-&gt; 0或者多个条件变量：等待通知信号量用于管理并发访问共享数据 管程具体的执行流程图进程或线程以队列方式进入临界区前，执行wait(), 如果不能满足条件变量，则将进程或线程挂在相应条件变量队列上，直到有其他进程或线程执行完临界区，执行Signal(), 唤醒相应队列中的进程或线程继续执行。 管程实现其中wait()需要释放 lock，是由于在进入管程接口时，会先加锁，确保同一时刻只能有一个进程或者线程调用。 实现生产者消费者问题 总结主要介绍了锁，信号量，管程(管程依赖于锁和条件变量)。这三种机制可以解决同步互斥问题。需要注意的是，即使是有同步互斥方法来解决这些问题，但是由于不确定性现象的存在，使得对它进行调试分析很困难，出错了需要知道是怎么错的，因为下次重复操作的时候，问题可能不会重复出现，那么这种情况下，就需要我们 仔细的去设计和分析相应的同步互斥的操作过程，才能够解决此类问题。 总的来说，想要用好同步互斥，需要我们仔细的去分析问题，设计相应的操作流程，才能够有效的解决同步互斥的问题。]]></content>
      <tags>
        <tag>多线程编程</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统--进程间通信(一)]]></title>
    <url>%2F2018%2F11%2F14%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-2018-11-14%2F</url>
    <content type="text"><![CDATA[IPC 运用范畴 配图与本文无关，纯属有趣 相对于做点什么，我们更想睡懒觉，但是相对于睡觉，我想写总结！今天把博客的 git 分支搞混了，浪费了一点时间。那么今天介绍一下进程间通信(IPC) 。进程间通信，我们从 &lt;&lt; UNIX网络编程卷2：进程间通信 &gt;&gt; 最后一章 Sun RPC 谈起，那为什么呢？ 因为我们去掌握一个东西，肯定是因为它有价值，我们才去学习，如果一些技术现在都不用了，淘汰了，那我们就没有必要去深究，只需学习其思想，浅尝辄止即可。最后一张概述部分是这样介绍的，构筑一个应用程序时，我们首先在以下两者之间作出选择： (1) 构筑一个庞大的单一程序，完成全部工作； (2) 把整个应用程序散步到彼此通信的多个进程中。如果我们选择后者，接下去的抉择是： (2a) 假设所有进程运行在同一台主机上 (允许 IPC 用于这些进程间的通信)； (2b) 假设某些进程会运行在其他主机上 (要求使用进程间某种形式的网络通信)。 这本著作主要关注的是 2a 这种情况，也就是 使用消息传递、共享内存、并可能使用某种形式的同步来进行同一台主机上的进程间 IPC。同一进程内不同线程间的 IPC 以及不同进程内各个线程间的 IPC只是这种情形的特殊情况。 而对于不同部分之间需要网络通信的应用程序则大多数使用 显示网络编程（explicit network programming)方式编写，也就是我们现在流行的 Socket编程。 那么现在是什么情况呢？ 由于互联网大火，导致现在主流热门的进程间通信方式变成了使用 Socket 套接字通信。这个也可以理解，由于互联网就是传统的 C/S(服务器端-客户端)架构，对于客户端开发来说，主要就是移动应用开发、PC端应用开发、Web 浏览器开发，这些是互联网主要的流量入口，应用和浏览器需要通信的对象就是服务器，服务器要做的也是和客户端更好的进行通信，所以如果需要从事互联网的工作，那么对 Socket 编程相对于其他 IPC 手段就需要更熟悉，特别是服务器后台开发，客户端还好，客户端业务逻辑和 UI 体验相对重要，至于一些系统层技术，开发框架都已经封装的很好了，只需掌握使用方法就可以，像android 、 IOS开发。但是如果你是从事系统开发，那么所有的 IPC 方式都需要了解，特别是消息传递、共享内存需要深入了解。 具体的 IPC 手段信号软件中断通知事件处理 例如：SIGFPE, SIGKILL, SIGUSR1, SIGSTOP, SIGCONT接收到信号会发生什么： Catch：指定信号处理函数被调用 Ignore：依靠操作系统的默认操作 example：Abort，memory dump，suspend or resume process Mask：闭塞信号，因此不会发生 可能是暂时的（处理同样类型的信号） 不足：不能传输要交换的任何数据 特点： signals are only delivered between processes when either: 仅在同一个用户的进程间传递，或者超级用户发出信号 the processes involved are run by the same user the raising process is run by a superuser signal types and type names are defined in signal.h 定义在 signal.h 文件 signals are not queued 信号没有排队 handlers “terminate process” (SIG_DFL) and “ignore signal” (SIG_IGN) are already defined in signal.h 常用终止进程和忽略信号定义在 signal.h unix 主要接口信息：12345678910#include: signal.hfunctions：void raise(int sig_type)description：用信号sig_type发信号。functions：void signal(int sig_type, void (*sig_handler)(int signal_type))description：sig_type是signal.h中定义的信号值（或名称）之一。 sig_handles是一个指向带有int参数的函数的指针。当进程被指定类型的信号命中时，此函数将在进程上下文中运行。functions：int kill(pid_t dest_pid, int sig_type)description：向使用PID dest_pid运行的进程发送sig_type类型的信号。 dest_pid的特定类型0和-1 make kill（）分别发送与发送方的同一组执行的所有进程，并发信号通知系统中运行的所有进程（仅适用于超级用户凭据)。 管道和FIFO1.管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。特点： pipes are uni-directional 半双工 with file descriptors, they can only be shared between processes with parent-child relationship 只能用于父子进程间 atomicity is guaranteed for messages shorter than PIPE_BUF bytes 特定大小缓存保持原子性 alf-open pipes are told widowed (or broken) pipes. Writing on them causes a write error, reading from them always returns 0 bytes. 坏的管道，会出现写错误，读取时，返回0字节. unix 主要接口信息：1234#include: unistd.hfunctions： int pipe(int *fd_couple) description：创建一个管道并将其文件描述符存储到fd_couple [0]（读取结束）和fd_couple [1]（写入结束）。 return： 成功返回 0，错误返回 -1 模拟使用场景，实现 Linux 系统调用 popen，主要代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869FILE * vpopen(const char * cmdstring, const char * type)&#123; int pfd[2]; FILE * fp; pid_t pid; if ((type[0] != 'r' &amp;&amp; type[0] != 'w') || type[1] != 0) &#123; errno = EINVAL; return (NULL); &#125; if(pipe(pfd) != 0) &#123; return NULL; &#125; if((pid = vfork()) &lt; 0) // vfork 相对于fork区别是: vfork需要等待子进程执行完后才开始执行，两者共享地址空间 &#123; return NULL; &#125; else if(pid == 0) // 子进程 &#123; if(*type == 'r') &#123; close(pfd[0]); if (pfd[1] != STDOUT_FILENO) &#123; dup2(pfd[1], STDOUT_FILENO); close(pfd[1]); &#125; &#125; else &#123; close(pfd[1]); if (pfd[0] != STDIN_FILENO) &#123; dup2(pfd[0], STDIN_FILENO); close(pfd[0]); &#125; &#125; if(execl("/bin/bash", "bash", "-c", cmdstring, (char *) 0) &lt; 0) &#123; return NULL; &#125; &#125; wait(0); // 等子进程结束，回收子进程 if (*type == 'r') &#123; close(pfd[1]); if ((fp = fdopen(pfd[0], type)) == NULL) &#123; return (NULL); &#125; &#125; else &#123; close(pfd[0]); if ((fp = fdopen(pfd[1], type)) == NULL) &#123; return (NULL); &#125; &#125; return (fp);&#125; 2.有名管道，FIFO，特点： 每个FIFO有一个路径名与之关联，允许无亲缘关系进程间的通信 拥有标准管道的属性和特征 unix 主要接口信息：1234* #include: sys/types.h and sys/stat.h* functions： int mkfifo(char *path, mode_t mode) * description：path是要创建的FIFO文件的（路径+）名称。 mode是文件权限（请参阅umask（2）和chmod（2））* return： 成功返回 0，错误返回非 0 模拟使用场景：1234567* 模拟场景* 1. 在 shell 端使用命令创建有名管道： mkfifo /tmp/named_pipe* 2. 运行该接口* 3. 在 shell 端写入数据到管道 ：echo "hey, this is a message" &gt; /tmp/named_pipe* 4. 测试完毕，删除管道： rm /tmp/named_pipe* * 当然我们也可以自己启动一个任意进程向FIFO管道里面写数据 具体实现代码：123456789101112131415161718192021222324252627282930313233343536373839404142int fifo_read()&#123; int pipe; char ch; static char TmpCh; /* we expect a named pipe has been created * in /tmp/named_pipe . The command * $ mkfifo /tmp/named_pipe * is a friend to get to this point */ pipe = open("/tmp/named_pipe", O_RDONLY); if (pipe &lt; 0) &#123; printf("open fifo error, maybe you should create a fifo first !\n"); exit(1); &#125; /* preparing to read from the pipe... */ printf("Waiting data from the pipe... \n"); /* reading one char a time from the pipe */ while (1) &#123; if (read(pipe, &amp;ch, 1) &lt; 0) &#123; printf("Read the pipe failed! \n"); exit(2); &#125; if(ch != TmpCh) &#123; printf("%c", ch); &#125; TmpCh = ch; &#125; /* leaving the pipe */ close(pipe); return 0;&#125; 总结上述主要对IPC做了一个大体的介绍，以及介绍了信号(signal)和管道两种IPC方式，这两者在Linux系统自带功能实现中用的较多。至于 Posix和 System V的进程间通信方式 消息队列，信号和 共享内存，由于内容较多后面再单独介绍。]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统-线程概述]]></title>
    <url>%2F2018%2F11%2F09%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0-2018-11-9%2F</url>
    <content type="text"><![CDATA[为什么使用线程 我们需要一种新的实体(线程)，既能够满足不同实体之间可以并发执行，同时可以共享相同的地址空间和文件资源等，相对于进程，减少创建和切换时的开销。 什么是线程 Thread: 进程当中的一条执行流程 从两个维度来理解进程： 从资源组合的角度：进程把一组相关的资源组合起来，构成了一个资源平台(环境)，包括地址空间(代码段，数据段)，打开的文件等各种资源。 从运行的角度：代码在这个资源平台上的一条执行流程。(这个执行流程既是线程 ) 即：线程 = 进程 - 共享资源 (完成一个控制流的管理) 1. 线程优点： 一个进程中可以同时存在多个线程 各个线程之间可以并发执行 各个线程之间可以共享地址空间和文件等资源 2.线程缺点： You have to explicitly coordinate access to shared date with locks. If you forget a lock, you’ll end up with corrupted data. (共享数据需加锁) Circular dependencies amongst locks can lead to deadlocks. (导致死锁) They are hard to debug with subtle timing issues. (执行时序不确定，难以调试) Callbacks don’t work with locks. (回调不适用于锁) It’s hard to get good performance. (很难有好的表现) They are “too hard for most programmers to use, and even for experts development is painful.” (难以使用) 上述缺点是 1995 年 John Ousterhout 在一个演说中提到的，因为当时时间较早，所以其中有些缺点，比如说难用，回调不适用于锁 (有待考证)，表现不好等，现在可能已经克服了，像 Linux 系统中 NPTL 模型实现的 pthreads 库，以及其他语言实现的多线程库，例如：java 线程库，封装的都很好，使用起来也都十分方便; 但是 共享数据需加锁，死锁, 执行时序不确定，难以调试，这三点依然是现在多线程编程中面临的最大挑战。 Attention：线程和进程比较： 进程是资源分配单位，线程是CPU调度单位； 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈，来达到独立的控制流； 线程同样具有就绪，阻塞和执行三种基本状态，同样具有状态之间的转换关系； 线程能减少并发执行的时间和空间开销：- 线程的创建时间比进程短； - 线程的终止时间比进程短； - 同一进程内的线程切换时间比进程短； - 由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信 线程的实现传统的操作系统主要有三种线程的实现方式:1. 用户线程：在用户空间实现123456789101112POSIX Pthreads， Mach C-threads, Solaris threads在用户空间实现的线程机制，它不依赖于操作系统的内核，由一组用户级线程库函数来完成线程的管理，包括线程的创建，终止，同步和调度等。* 缺点1. 一个线程发起系统调用而阻塞，则整个进程等待2. 当一个线程运行，除非主动交出CPU使用权，否则它所在进程中的其他线程将无法运行3. 由于时间片是分给进程，故与其他进程相比，在多线程执行时，每个线得到的时间片较少，执行会比较慢* 优点1. 无需用户态和内核态切换，速度快2. 允许每个进程拥有自己的调度算法 2. 内核线程：在内核中实现123windwos ，Solaris， Linux指在操作系统内核当中实现的一种线程机制，由操作系统的内核来完成线程的创建，终止和管理，开销较大 3. 轻量级进程：在内核中实现，支持用户线程123Solaris （LightWeight Process）内核支持的用户线程。一个进程可以有一个或者多个轻量级进程，每个轻量级进程由一个单独的内核线程来支持。 Linux 系统线程实现那么最新版本的 Linux 系统中的 pthreads 线程库中的线程是如何实现的呢 ? 我参考了一下书籍 &lt;&lt; Linux 内核设计与实现&gt;&gt; 以及 Linux Programmer&#39;s Manual 当中的描述, 实现流程大致如下： Linux Programmer’s Manual 描述的实现: 1234567891011121314Linux implementations of POSIX threads Over time, two threading implementations have been provided by the GNU C library on Linux: LinuxThreads This is the original Pthreads implementation. Since glibc 2.4, this implementation is no longer supported. NPTL (Native POSIX Threads Library) This is the modern Pthreads implementation. By comparison with LinuxThreads, NPTL provides closer conformance to the requirements of the POSIX.1 specification and better performance when creating large numbers of threads. NPTL is available since glibc 2.3.2, and requires features that are present in the Linux 2.6 kernel. Both of these are so-called 1:1 implementations, meaning that each thread maps to a kernel scheduling entity. Both threading implementations employ the Linux clone(2) system call. In NPTL, thread synchronization primitives (mutexes, thread joining, and so on) are implemented using the Linux futex(2) sys‐ tem call. 在 Linux 2.6 kernel 版本后, 采用的是 NPTL 模型来实现。该模型是一个所谓的 1×1 线程库，其中由用户创建的线程（通过pthread_create() 库函数）与内核中的 可调度实体（Linux中的任务）进行1-1对应，是十分简单的线程实现方式。 假如我们要在一个进程中创建四个线程, 在 Linux 系统中，实现思路是：创建四个进程并分配四个普通的 task_struct (PCB 在代码中的表示) 结构, 然后在建立这个四个进程时，指定它们共享某些资源即可。 也就是说 Linux 系统中创建进程和线程是类似的，最终都是调用 clone()，只是对外封装接口表现不一样，传入参数不一样而已。 参考 https://www.bilibili.com/video/av6538245/?p=2 https://blog.acolyer.org/2014/12/09/why-threads-are-a-bad-idea/ 书籍： &lt;&lt; Linux 内核设计与实现 &gt;&gt; -Robert Love]]></content>
      <tags>
        <tag>多线程编程</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统--进程管理(二)]]></title>
    <url>%2F2018%2F11%2F03%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%BA%8C-2018-11-3%2F</url>
    <content type="text"><![CDATA[进程状态(State) 操作系统通过维护进程状态队列，来对进程进行管理。 状态队列： 由操作系统来维护一组队列，用来表示系统当中所有进程的当前状态； 不同的状态分别用不同的队列来表示(就绪队列，各种类型的阻塞队列)； 每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生改变时，它的PCB从一个队列中脱离出来，加入到另一个队列。 进程的生命周期管理12345678910111213141516171819202122232425* 进程创建 引起进程创建的三个主要事件： * 系统初始化时;(创建init进程，负责创建其他新的进程) * 用户请求创建一个新进程； * 正在运行的进程执行了创建进程的系统调用；* 进程运行 内核选择一个就绪进程，让它占有处理机并执行（涉及相关调度算法，来满足如何选择进程何时来执行）* 进程等待 在以下情况下，进程等待(阻塞)： 1. 请求并等待系统服务，无法马上完成(例如：执行I/O，请求硬盘时) 2. 启动某种操作，无法马上完成(需要等待其他进程完成某个操作才可以执行) 3. 需要的数据没有到达 进程一旦由运行态转换成等待状态就不占有CPU了，那么其他就绪进程就可以占有CPU执行。进程等待(阻塞)只能由进程自己触发， 因为只有进程自己知道才能知道何时需要等待某种事件的发生。* 进程唤起（由阻塞态转换为就绪态） 唤醒进程的原因： 1. 被阻塞进程的需要的资源得到满足 2. 被阻塞进程等待的事件可达 3. 将该进程的PCB插入到就绪队列 进程只能被别的进程或者操作系统唤醒* 进程结束 进程的状态变化模型 进程的三种基本状态：进程在生命结束前处于且仅处于三种基本状态之一，不同系统设置的进程状态数目不同。 运行状态(Running)：当一个进程正在处理机上运行时。 就绪状态(Ready): 一个进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。 等待状态(又称阻塞状态Blocked)：一个进程正在等待某一事件而暂停运行时。如等待某资源，等待输入/输出完成。 进程的挂起模型 进程在挂起状态时，意味着进程没有占有内存空间，处在挂起状态的进程映像在磁盘上。 挂起状态： 阻塞挂起状态(Blocked-suspend)：进程在外存并等待某事件的出现 就绪挂起状态(Ready-suspend)：进程在外存，但只要进入内存即可运行 进程调度算法 FCFS: first come fist server (先来先服务) 12345优点：简单缺点：* 平均等待时间波动较大* 花费时间少的任务可能排在花费时间长的任务后面* 可能导致I/O和CPU之间的重叠处理 SPN/SRT : 短任务优先 1234567按照预测的完成时间来将任务入队。可以是可抢占的或者不可抢占的，可抢占：又叫shortest-Remaining-Time(SRT) (最短剩余时间)优点：不公平，最优平均等待时间缺点：* 优先考虑短时间进程，可能导致饥饿* 需要预知未来，如何预估进程执行时间长短(根据过去预估未来) HRRRN : 最高响应比优先 (在SPN基础上改进) 1234R = (W + S)/S W ：waiting time 等待时间S ：service time 执行时间选择R值最高的进程，充分考虑了进程等待的时间，缓解饥饿现象，不可抢占 Round Robin 轮循调度算法 123456在叫作时间切片的离散单元中分配处理器，时间片结束时，切换到下一个准备好的进程经验规则：维持上下文切换开销处于1%以内，99%的时间用在实际进程执行中优点：公平缺点：平均等待时间较差 MLFQ 多级反馈队列 1动态的根据进程执行的过程，操作系统可以根据进程具有cpu密集型和I/O密集型的特征来动态的调整进程优先级 Fair-share scheduling 公平共享调度 1使得用户的请求在不同的级别享受公平调度，是在进程级别还是用户级别或者用户组级别公平的共享进程的调度]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统--进程管理(一)]]></title>
    <url>%2F2018%2F11%2F02%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B8%80-2018-11-2%2F</url>
    <content type="text"><![CDATA[缅怀 就在昨天，MVP 的呼声响彻标靶中心球馆，步入不惑的玫瑰，拿下了生涯新高 50 分，曾经的天之骄子，风城玫瑰，NBA 历史上最年轻的常规赛 MVP，经过多年坎途，不曾在病魔面前哭泣，而在昨天却低下了头，落下了泪… 感慨万千，脑海中记着的依然是 09 年那一轮史诗级季后赛，还有那个给芝加哥带来无限希望的玫瑰。此刻，向传奇致敬！加油，罗斯！ 进程定义 一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。 说的直接一点，我们编写代码时，一个 mian() 函数的动态执行过程就是一个进程，当然还包括这个 main() 函数执行过程中使用的资源和数据。 进程的组成一个进程应该包括： 程序的代码； 程序处理的数据； 程序计数器中的值，指示下一条将运行的指令； 一组通用的寄存器的当前值，堆，栈； 一组系统资源(如内存资源，文件系统，网络等一系列资源) 总之，进程包含了正在运行的一个程序的所有状态信息。 进程与程序的关系 程序是产生进程的基础 程序的每次运行构成不同的进程 进程是程序功能的体现 通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包含多个程序。 进程与程序的区别 进程是 动态的，程序是静态的：程序是有序代码的集合；进程是程序的执行，进程有核心态用户态 进程是 暂时的，程序是永久的：进程是一个状态变化的过程，程序可长久保存 进程与程序的组成不同：进程的组成包括程序，数据和进程控制块(即进程状态信息) 进程的特点 动态性：可动态的创建，结束进程； 创建接口 fork(), 结束进程： kill 等。 并发性：进程可以被独立调度并占有处理机运行；多核并行，单核一段时间内并发执行； 独立性：不同进程的工作不相互影响；(正确性不受影响，操作系统内存管理，页表管理使得不同进程访问不同的物理内存，相互之间独立不受影响。越过地址空间会产生缺页异常。保证进程独数据独立性。) 制约性：因访问共享数据/资源或者进程间同步产生制约； 进程控制结构(PCB) 进程控制块：操作系统管理控制进程运行所用的信息集合。操作系统用PCB来描述进程的基本情况以及运行变化过程，PCB是进程存在的唯一标志。 使用进程控制块 进程的创建：为该进程生成一个PCB进程终止：回收它的PCB进程的组织管理：通过对PCB的组织管理来实现 对进程的创建，终止和管理都是通过处理PCB来完成。 PCB包含的三大类信息 进程标识信息。如本进程的标识，本进程的产生者标识(父进程标识)；用户标识。 处理机状态信息保存区。保存进程的运行现场信息： 1. 用户可见寄存器，用户程序可以使用数据，地址等寄存器。 2. 控制和状态寄存器，如程序计数器(PC)，程序状态字(PSW)。 3. 栈指针，过程调用/系统调用/中断处理和返回时需要用到它。 进程控制信息： 1. 调度和状态信息，用于操作系统调度进程并占用处理机使用。 2. 进程间通信信息，为支持进程间与通信相关的各种标识，信号，信件等，这些信息存放在接收方的进程控制块里面。 3. 存储管理信息，包含有指向本进程影像存储空间的数据结构。 4. 进程所用的资源，说明由进程打开，使用的系统资源，如打开的文件等。 5. 有关数据结构连接信息，进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB。 PCB的组织方式 链表： 同一状态的进程其 PCB 组成一个链表，多个状态对应多个不同的链表。各状态的进程形成不同的链表：就绪链表，阻塞链表。(一般采用链表，动态插入删除，开销较小) 索引表：同一状态的进程归入一个 index 表(由 index 指向 PCB )，多个状态对应多个不同的 index 表。各状态的进程形成不同的索引表：就绪索引表，阻塞索引表。(如果 PCB 个数比较固定，不会频繁插入删除，使用索引表) 参考链接 https://www.bilibili.com/video/av6538245/?p=2]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统简述]]></title>
    <url>%2F2018%2F10%2F31%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E8%BF%B0-2018-10-31%2F</url>
    <content type="text"><![CDATA[操作系统基本概念 操作系统 (operating system, 缩写 OS)，是指控制和管理整个计算机系统的硬件和软件资源，合理地组织调度计算机的工作和资源的分配的集合，为用户和底层硬件之间的桥梁。对于程序员来说，操作系统是工作场地，是应用程序控制底层硬件接口的提供者。 操作系统启动以 Linux 为例，一开始操作系统是存放在 Disk 上面的，然后再由 BIOS（基本I/O处理系统）检测我们计算机操作系统的各种外设，检测完，如果外设正常，再将一个 bootloader 小程序由 Disk 加载到内存中去，bootloader (512个字节) 负责将操作系统加载到内存，最终操作系统开始正常工作。 操作系统启动后，如何与外设和应用程序交互呢？ 外设是通过中断和I/O来处理的，至于应用程序，是通过系统调用和异常来提供相应功能。中断，异常，系统调用三者就是操作系统同应用程序和底层硬件之间交互手段，三者具体定义如下： 系统调用（来源于应用程序)应用程序主动向操作系统发出服务请求。系统调用会触发”用户态”到”内核态”的一个转换。”用户态”指的是应用程序在运行过程中， cpu 所处的一个特权级状态，权限较低，不能直接访问特殊的机器指令和 I/O ; “内核态”指的是操作系统运行过程中 cpu 所指的一个状态，权限较高，该状态下，操作系统可以执行任何一条指令，包括特权指令，访问 I/O 指令。这种机制使得系统安全性可以得到保证。系统调用付出的代价主要是执行的开销相对普通函数调用较大 (切换堆栈，用户态切换内核态)。Windows 应用 WIN32 APIPOSIX-based systems 应用 POSIX API（包括unix，Linux，mac os x的所有版本） 异常（来源于不良的应用程序）非法指令或者其他坏的处理状态。（如：内存出错） 操作系统需要保存现场，然后处理异常，接着杀死异常程序或重新执行异常程序。 中断（来源于外设）来自不同的硬件设备的计时器和网络中断 。中断向量表中保存有各个外设的中断编号和相应的中断服务例程地址，操作系统收到中断编号，查表，然后转到相应地址执行服务例程，这个时候操作系统需要保存当前处理状态，处理完中断再恢复现场。 操作系统特征 并发 (Concurrence) 并发： 一个时间段内，多个程序在运行。并行：同一个时间点上，多个程序在运行，需要多核cpu来完成。操作系统特征之一就是并发，同时存在多个运行程序，需要通过操作系统来进行调度。 共享 （Sharing) 对于硬件资源，内存资源和相关外设等”同时”访问，共同使用，实际上是互斥共享。 虚拟 （Virtual) 虚拟是指 把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实的，即实际存在的；而后者是虚的，是用户感觉上的事物。用于实现虚拟的技术，称为虚拟技术。在操作系统中利用了多种虚拟技术，分别用来实现虚拟处理器、虚拟内存和虚拟外部设备。 在虚拟处理器技术中，是 通过多道程序设计技术，让多道程序并发执行的方法，来分时使用一个处理器的。此时，虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个中央处理器（CPU) 在专门为它服务。利用多道程序设计技术，把一个物理上的CPU虚拟为多个逻辑上的 CPU，称为虚拟处理器。 类似地，可以通过虚拟存储器技术，将一台机器的物理存储器变为虚拟存储器，以便从逻辑上来扩充存储器的容量。当然,这时用户所感觉到的内存容量是虚的。我们把用户所感觉到的存储器（实际是不存在的）称为虚拟存储器。 还可以通过虚拟设备技术，将一台物理 I/O 设备虚拟为多台逻辑上的I/O设备，并允许每个用户占用一台逻辑上的 I/O 设备，这样便可以 使原来仅允许在一段时间内由一个用户访问的设备（即临界资源)，变为在一段时间内允许多个用户同时访问的共享设备。因此，操作系统的虚拟技术可归纳为：时分复用技术，如处理器的分时共享；空分复用技术，如虚拟存储器 异步 (Asynchronism) 程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知，但只要运行环境相同，操作系统需要保证程序运行结果也相同。异步使得操作系统运行在一种随机的环境下，可能导致进程产生与时间有关的错误 (就像对全局变量的访问顺序不当会导致程序出错一样）。 Linux 系统组成 上图是 Linux 操作系统内核组成图，从中我们可以看到，操作系统主要功能为以下四个，那么后面文章中会一一深入介绍！ 进程管理（Processing management） 内存管理（Memory management） 文件系统（File system） 网络通信（Networking） 参考链接 https://www.bilibili.com/video/av6538245/?p=2https://blog.csdn.net/bigpudding24/article/details/48603301]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于这个博客]]></title>
    <url>%2F2018%2F10%2F27%2F2018-10-29%2F</url>
    <content type="text"><![CDATA[hello 花了两三天时间，搭建了一个自己的博客，在阿里云买了人生中第一个域名 mikeblog.top，基本框架用的是hexo+githubpage，这个网上教程很多，也很详细，我就不介绍详细过程了，在这里十分感谢其他博主的分享，也感谢这两个平台，让我在互联网上有了一个自己的小栖息地，说实话，感觉像有了一个自己的家。第一篇博客，当然是用来解释前世今生，立flag用的，我为什么要弄一个博客呢？这个博客以后是用来干啥的呢？ 博客搭建自己博客的原因大概今年5月份，开始有了持续更新博客的念头，原因主要有两个，不对应该是三个。 原因一一是工作上的原因，工作差不多快两年了，期间接触到的，学习到的东西很多，然后每次想起自己在技术上的积累时，总是这个懂，那个也懂，但是要你很系统的表达出来，却又做不到，显得很凌乱。所以，好记性不如烂笔头，想通过写博客来对自己已掌握的，或者掌握的不牢固的技术点进行总结和提升, 成体系化，并且分享出来，分享也算是一种变相的激励，需要你去对所分享的东西进行 深层次的熟悉和了解，如果能帮助到有缘人，那是极好的。 原因二第二个原因，是想记录下一些关于自己的文字，想要更了解自己，我想应该没有什么是比文字更能描绘一个人的了，记录自己对工作对行业的了解和看法，以及自己三观的演变。 原因三第三个是因为博客园对Markdown的支持实在让我不能忍，还有博客相关的UI界面体验，实在不敢恭维。国内比较出名的技术网站，博客园和CSDN，持续时间久，上面积累的技术博客和资源确实很多，有很多质量也很不错，很多技术大牛都有在上面分享的经历，但是呢，最后都离开了，这肯定是有原因的。 最重要的，当然是 freedom 了，自己的博客没有这么多条条框框，比较自由，可以按照自己的想法来开发集成，加功能，选择自己喜欢的风格，好的开源框架这么多，不用白不用是吧。 博客记录的主要内容我当前干的活，主要是应用软件开发(平台：linux, android), 主要语言C/C++, 脚本语言shell, 主要做逻辑层和基础库这一块，为多个平台提供库和通用API，至于UI框架这一块，接触的比较少，要说接触过的应该就Qt了，但是不深入。后续博客记录的主要内容短期会聚焦在: Linux 系统 ：多进程/多线程, 内存, I/O, 网络 (I/O和网络需加强) C++/C++11/C++17 : STL库分析总结; C++11/17 新增特性分析 编译链接相关： make/cmake, 动态库链接 脚本语言： shell, python git：持续集成 (CI) 当然，因为现在工作上到了迷茫期，正在考虑方向上的事情，所以后面记录的东西也可能会随之改变 ！ 12345678910111213141516171819202122232425/* Add a new node to the list, to head, containing the specified 'value' * pointer as value. * * On error, NULL is returned and no operation is performed (i.e. the * list remains unaltered). * On success the 'list' pointer you pass to the function is returned. */list *listAddNodeHead(list *list, void *value)&#123; listNode *node; if ((node = zmalloc(sizeof(*node))) == NULL) return NULL; node-&gt;value = value; if (list-&gt;len == 0) &#123; list-&gt;head = list-&gt;tail = node; node-&gt;prev = node-&gt;next = NULL; &#125; else &#123; node-&gt;prev = NULL; node-&gt;next = list-&gt;head; list-&gt;head-&gt;prev = node; list-&gt;head = node; &#125; list-&gt;len++; return list;&#125; 测试一下代码显示效果，笑脸。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
