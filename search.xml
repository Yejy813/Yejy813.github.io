<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++ 单元测试框架-gtest]]></title>
    <url>%2F2019%2F01%2F02%2Fgoogletest%2F</url>
    <content type="text"><![CDATA[Unit Test 和 gtest 介绍 单元测试（ Unit Test ，模块测试）是开发者编写的一小段代码，用于检验被测代码的一个很小的、很明确的功能是否正确，通过编写单元测试可以在编码阶段发现程序编码错误，甚至是程序设计错误。 单元测试不但可以增加开发者对于所完成代码的自信，同时，好的单元测试用例往往可以在 回归测试 的过程中，很好地保证之前所发生的修改没有破坏已有的程序逻辑。因此，单元测试不但不会成为开发者的负担，反而可以在保证开发质量的情况下，加速迭代开发的过程。GoogleTest是一个跨平台的(Liunx、Mac OS X、Windows、Cygwin、Windows CE and Symbian) C++ 单元测试框架，GoogleTest由 google 公司发布, 且遵循 New BSD License（可用作商业用途）的开源项目, 为当前比较主流的 C++ 单元测试框架，目前所在公司也在使用。 gtest 安装、导入项目（Linux系统）下载源码我本地使用的系统参数：12bash-4.2$ uname -aLinux yejy 3.10.0-514.el7.x86_64 #1 SMP Tue Nov 22 16:42:41 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux gtest github 地址： https://github.com/google/googletest 下载源码：1bash-4.2$ git clone https://github.com/google/googletest 导入项目简单测试下载源码后，接着就是将其导入到我们的项目中使用，如果你只是想简单测试一下，可以直接编译 gtest 源码，生成相应的静态库，将库和头文件拷贝到系统的头文件和库中，然后就可以直接写代码进行测试了，步骤如下： 12345bash-4.2$ cd googletestbash-4.2$ cmakebash-4.2$ makebash-4.2$ cp libgtest*.a /usr/lib bash-4.2$ cp –a include/gtest /usr/include 写一个简单的测试程序：123456789101112131415#include&lt;gtest/gtest.h&gt;int add(int a, int b)&#123; return a+b;&#125;TEST(testCase, test0)&#123; EXPECT_EQ(add(4,3), 7); // 断言检测两参数是否相等&#125;int main(int argc, char **argv)&#123; testing::InitGoogleTest(&amp;argc, argv); // 初始化，所有测试都是这里启动的 return RUN_ALL_TESTS(); // 运行所有测试用例&#125; 编译代码，当然你可以用 make 或者 cmake 编译都可以，具体输出：123456[==========] Running 1 test from 1 test case.[----------] Global test environment set-up.[----------] 1 test from testCase[ RUN ] testCase.test0[ OK ] testCase.test0 (0 ms)[----------] 1 test from testCase (0 ms total) 工业生产上面这种测试方法比较特殊，等于是把 gtest 库和 gnu c 库一样使用了，正常工作项目中，肯定不会这样用的。 正确的做法是 以第三方库的形式直接将源码引入进项目。可能有人就会说了，为什么一定要将源代码引入其中，而不先编译出静态库，然后导入其中呢，这样编译自己项目的时候不就不用再重新编译了吗？ 这里主要是考虑 跨平台，编译环境会有多种，需要多次编译，因此需要源码导入，同宿主项目一起编译。 我比较熟悉的编译工具是 cmake, 工作中使用的也是这个，该工具也是跨平台的，在编译大型跨平台项目时，很有优势，那这边就大致讲一下引入步骤，如果你对 cmake 很熟悉，那这边就很轻松了。 首先看一下引入后的代码结构，如下图： 重点是这个文件 unit_test/CMakeLists.txt ：1234567891011121314151617181920212223242526file(GLOB SRC_FILES ./*.cpp)file(GLOB HEADER_FILES ./*.h)# 将给定目录添加到编译器用于搜索包含文件的目录中。相对路径被解释为相对于当前源目录。# 相当于gcc命令的-I，告诉编译器到该目录中查找头文件include_directories($&#123;CMAKE_SOURCE_DIR&#125;/src)if(ENABLE_TEST) include_directories( $&#123;CMAKE_SOURCE_DIR&#125;/3rdlib/googletest/googlemock/include $&#123;CMAKE_SOURCE_DIR&#125;/3rdlib/googletest/googletest/include )endif()# 生成可执行文件 posix_thread_test.exx add_executable(posix_thread_test.exx $&#123;SRC_FILES&#125; )# 引入 gtest 库，posixthread 为源代码库target_link_libraries(posix_thread_test.exx gtest posixthread )target_install(posix_thread_test.exx) 导入项目，主要就是看 unit_test/CMakeLists.txt 这个文件了，其他基本变化不大，如果你熟悉 cmake 很容易就能看懂。 至于图中的源码，是最近在封装 Posix-thread 时写的，源码大部分引用了陈硕老师的 muduo 网络库中的线程相关代码。 gtest 具体使用介绍一下断言，断言主要用来做一些逻辑判断，主要有以下两类接口: ASSERT_XXX()： 如果断言失败，则测试处理终止。 EXPECT_XXX()： 非致命性失败，允许继续处理。 Test Fatal NonFatal condition 为真 ASSERT_TRUE(condition) EXPECT_TRUE(condition) condition 为假 ASSERT_FALSE(condition) EXPECT_FALSE(condition) Equal ASSERT_EQ(arg1,arg2) EXPECT_EQ(arg1,arg2) Not Equal ASSERT_NE(arg1,arg2) EXPECT_NE(arg1,arg2) Less Than ASSERT_LT(arg1,arg2) EXPECT_LT(arg1,arg2) Less Than or Equal ASSERT_LE(arg1,arg2) EXPECT_LE(arg1,arg2) Greater Than ASSERT_GT(arg1,arg2) EXPECT_GT(arg1,arg2) Greater Than or Equal ASSERT_GE(arg1,arg2) EXPECT_GE(arg1,arg2) C String Equal ASSERT_STREQ(str1,str2) EXPECT_STREQ(str1,str2) C String Not Equal ASSERT_STRNE(str1,str2) EXPECT_STRNE(str1,str2) C String Case Equal ASSERT_STRCASEEQ(str1,str2) EXPECT_STRCASEEQ(str1,str2) C String Case Not Equal ASSERT_STRCASENE(str1,str2) EXPECT_STRCASENE(str1,str2) Verify that exception is thrown ASSERT_THROW(statement,exception_type) EXPECT_THROW(statement,exception_type) Verify that exception is thrown ASSERT_ANY_THROW(statement) EXPECT_ANY_THROW(statement) Verify that exception is NOT thrown ASSERT_NO_THROW(statement) EXPECT_NO_THROW(statement) 测试代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;gtest/gtest.h&gt;#include &lt;posix_thread.h&gt;void threadFunc()&#123; std::cout &lt;&lt; "tid= "&lt;&lt; PosixThread::CurrentThread::tid() &lt;&lt; std::endl;&#125;TEST(PosixThreadTest, CreateThread)&#123; std::cout &lt;&lt; "pid= " &lt;&lt; ::getpid() &lt;&lt; " tid= " &lt;&lt;PosixThread::CurrentThread::tid() &lt;&lt; std::endl; PosixThread::Thread t1(threadFunc); t1.start(); ASSERT_TRUE(t1.started()); EXPECT_FALSE(t1.started()); // 故意失败 ASSERT_FALSE(t1.started()); // 故意失败 std::cout &lt;&lt; "t1.tid: " &lt;&lt; t1.tid() &lt;&lt; std::endl; std::cout &lt;&lt; "thread name: " &lt;&lt; t1.name().c_str() &lt;&lt; std::endl; t1.join(); std::cout &lt;&lt; "CreateThread end !\n" &lt;&lt; std::endl;&#125;TEST(AtomicTest, AtomicInt64)&#123; std::cout &lt;&lt; "pid= " &lt;&lt; ::getpid() &lt;&lt; " tid= " &lt;&lt;PosixThread::CurrentThread::tid() &lt;&lt; std::endl; PosixThread::AtomicInt64 a0; ASSERT_EQ(a0.get(), 0); ASSERT_EQ(a0.getAndAdd(1), 0); ASSERT_EQ(a0.get(), 1); ASSERT_EQ(a0.addAndGet(2), 3); ASSERT_EQ(a0.get(), 3); ASSERT_EQ(a0.incrementAndGet(), 4); ASSERT_EQ(a0.get(), 4); a0.increment(); ASSERT_EQ(a0.get(), 5); ASSERT_EQ(a0.addAndGet(-3), 2); ASSERT_EQ(a0.getAndSet(100), 2); ASSERT_EQ(a0.get(), 100);&#125; 执行结果：12345678910111213141516171819202122232425262728293031bash-4.2$ ./output/bin/posix_thread_test.exx [==========] Running 2 tests from 2 test cases.[----------] Global test environment set-up.[----------] 1 test from PosixThreadTest[ RUN ] PosixThreadTest.CreateThreadpid= 5297 tid= 5297tid= 5298/home/willy/myshare/thread-pool/unit_test/thread_test.cpp:16: FailureValue of: t1.started() Actual: trueExpected: false/home/willy/myshare/thread-pool/unit_test/thread_test.cpp:17: FailureValue of: t1.started() Actual: trueExpected: false[ FAILED ] PosixThreadTest.CreateThread (0 ms)[----------] 1 test from PosixThreadTest (0 ms total)[----------] 1 test from AtomicTest[ RUN ] AtomicTest.AtomicInt64pid= 5297 tid= 5297[ OK ] AtomicTest.AtomicInt64 (0 ms)[----------] 1 test from AtomicTest (0 ms total)[----------] Global test environment tear-down[==========] 2 tests from 2 test cases ran. (0 ms total)[ PASSED ] 1 test.[ FAILED ] 1 test, listed below:[ FAILED ] PosixThreadTest.CreateThread 1 FAILED TEST 从执行结果，我们可以很清楚的知道测试用例具体执行到哪一步，如果失败了，我们可以看到具体是哪一行代码出问题了，程序预期结果是什么，但是实际结果又是什么，输出十分详细。 我们还可以将测试结果导出到 xml 文件，通过参数：--gtest_output 实现。1234567891011121314151617181920bash-4.2$ ./output/bin/posix_thread_test.exx --gtest_output="xml:./test.xml"bash-4.2$ cat test.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;testsuites tests="2" failures="1" disabled="0" errors="0" timestamp="2019-01-04T21:36:40" time="0" name="AllTests"&gt; &lt;testsuite name="PosixThreadTest" tests="1" failures="1" disabled="0" errors="0" time="0"&gt; &lt;testcase name="CreateThread" status="run" time="0" classname="PosixThreadTest"&gt; &lt;failure message="/home/willy/myshare/thread-pool/unit_test/thread_test.cpp:16&amp;#x0A;Value of: t1.started()&amp;#x0A; Actual: true&amp;#x0A;Expected: false" type=""&gt;&lt;![CDATA[/home/willy/myshare/thread-pool/unit_test/thread_test.cpp:16Value of: t1.started() Actual: trueExpected: false]]&gt;&lt;/failure&gt; &lt;failure message="/home/willy/myshare/thread-pool/unit_test/thread_test.cpp:17&amp;#x0A;Value of: t1.started()&amp;#x0A; Actual: true&amp;#x0A;Expected: false" type=""&gt;&lt;![CDATA[/home/willy/myshare/thread-pool/unit_test/thread_test.cpp:17Value of: t1.started() Actual: trueExpected: false]]&gt;&lt;/failure&gt; &lt;/testcase&gt; &lt;/testsuite&gt; &lt;testsuite name="AtomicTest" tests="1" failures="0" disabled="0" errors="0" time="0"&gt; &lt;testcase name="AtomicInt64" status="run" time="0" classname="AtomicTest" /&gt; &lt;/testsuite&gt;&lt;/testsuites&gt; 此外，在运行可执行目标程序时，可以使用 --gtest_filter 来指定要执行的测试用例，支持字符串正则匹配，主要如下几种常用情况：123456./output/bin/posix_thread_test.exx 没有指定filter，运行所有测试；./output/bin/posix_thread_test.exx --gtest_filter=* 指定filter为*，运行所有测试；./output/bin/posix_thread_test.exx --gtest_filter=PosixThreadTest.* 运行测试用例FooTest的所有测试；./output/bin/posix_thread_test.exx --gtest_filter=*Null*:*Thread* 运行所有全名；./output/bin/posix_thread_test.exx --gtest_filter=PosixThreadTest.*-PosixThreadTest.CreateThread 运行测试用例FooTest的所有测试，但不包括PosixThreadTest.CreateThread。 gtest 还有很多方便你测试的功能，包括 事件机制, 参数化, 死亡测试, 运行参数等，我们点到为止，如果想继续深入，可以参考这位博主的 gtest 系列, 很详细：玩转Google开源C++单元测试框架Google Test系列 googlemock 使用googlemock，是用于编写和使用C++ 模拟类的框架，在我们工作中，主要用来模拟应用程序的一部分，在单元测试用例编写过程中，常常需要编写模拟对象来隔离被测试单元的“下游”或“上游”程序逻辑或环境，从而达到对需要测试的部分进行隔离测试的目的，它可以帮助我们获得更好的系统设计并编写更好的测试。googlemock 同样遵循 New BSD License（可用作商业用途）的开源项目。 在开发过程中，经常出现各联调模块间，进度不一的情况；测试环境非常不稳定，易导致测试失败，导致达不到单元测试的目的，模仿对象提供了解决这些问题的方法：模仿对象符合实际对象的接口，但只包含用来“欺骗”测试对象并跟踪其行为的必要代码。因此，其实现往往比实际实现类简单很多。 官方教程： https://github.com/google/googletest/blob/master/googlemock/docs/ForDummies.md 官方的 Tutorial 讲的很详细，我在github上也找了一个使用例子，很简洁，但是能很好的说明问题，大致代码如下：mail_service.h文件：123456789101112131415161718#ifndef MAIL_SERVICE_HPP#define MAIL_SERVICE_HPP/** \brief Mail service. This represents one of the collaborators of the SUT. * \author David Stutz */// 邮件服务class MailService&#123;public: /** \brief Send a mial. * \param[in] message message to send */ virtual void send(std::string message) = 0; &#125;;#endif /* MAIL_SERVICE_HPP */ order.h文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#ifndef ORDER_HPP#define ORDER_HPP#include &lt;string&gt;#include &lt;memory&gt;#include "warehouse.h"#include "mail_service.h"/** \brief An order of a product with quantity. */// 订单class Order&#123;public: /** \brief Constructor. * \param[in] quantity quantity requested * \param[in] product product name requested */ Order(int quantity, std::string product) &#123; this-&gt;quantity = quantity; this-&gt;product = product; &#125; /** \brief Set the mail service to use. * \param[in] mailService the mail service to attach */ // 设置邮件服务 void setMailService(std::shared_ptr&lt;MailService&gt; mailService) &#123; this-&gt;mailService = mailService; &#125; /** \brief Fill the order given the warehouse. * \param[in] warehouse the warehouse to use * \return whether the operation was successful */ // 判断产品是否有库存，发送邮件通知 bool fill(Warehouse &amp;warehouse) &#123; if (warehouse.hasInventory(quantity, product)) &#123; // ... warehouse.remove(quantity, product); this-&gt;mailService-&gt;send("Order filled."); return true; &#125; else &#123; // ... this-&gt;mailService-&gt;send("Order not filled."); return false; &#125; &#125; private: /** \brief Product name. */ std::string product; /** \brief Quantity requested. */ int quantity; /** \brief Mail service to use. */ std::shared_ptr&lt;MailService&gt; mailService;&#125;;#endif /* ORDER_HPP */ warehouse.h文件：1234567891011121314151617181920212223242526272829#ifndef WAREHOUSE_HPP#define WAREHOUSE_HPP#include &lt;string&gt;/** \brief Warehouse interface. This interface is one of the collaborators of our SUT. * \author David Stutz */class Warehouse&#123;public: /** \brief Check whether the product in the given quantity is on stock. * \param[in] quantity quantity requested * \param[in] product product name * \return whether the warehouse has the product on stock for the given quantity */ // 是否有库存 virtual bool hasInventory(int quantity, std::string product) const = 0; /** \brief Remove the given quantity of the product from the warehouse. * \param[in] quantity quantity to remove * \param[in] product product name to remove */ // 从库存中删除 virtual void remove(int quantity, std::string product) = 0; &#125;;#endif /* WAREHOUSE_HPP */ 主要场景就是处理产品订单，其中库存Warehouse类和邮件服务MailService类，我们只声明一下虚基类，不实现，然后通过模拟对象的方式mock一下Warehouse和MailService，来达到订单类接口测试的正常开展，具体测试代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;gmock/gmock.h&gt;#include "lib/mail_service.h"#include "lib/order.h"#include "lib/warehouse.h"using ::testing::Return;using ::testing::_; // Matcher for parametersclass MockWarehouse : public Warehouse&#123;public: // see https://github.com/google/googletest/blob/master/googlemock/docs/ForDummies.md MOCK_CONST_METHOD2(hasInventory, bool(int, std::string)); MOCK_METHOD2(remove, void(int, std::string));&#125;;class MockMailService : public MailService&#123;public: MockMailService() &#123; &#125; MOCK_METHOD1(send, void(std::string));&#125;;TEST(OrderTest, Fill)&#123; MockWarehouse warehouse; std::shared_ptr&lt;MockMailService&gt; mailService = std::make_shared&lt;MockMailService&gt;(); Order order(50, "Talisker"); order.setMailService(mailService); EXPECT_CALL(warehouse, hasInventory(50, "Talisker")) .Times(1) .WillOnce(Return(true)); EXPECT_CALL(warehouse, remove(50, "Talisker")) .Times(1); EXPECT_CALL(*mailService, send(_)) // Not making assumptions on the message send ... .Times(1); ASSERT_TRUE(order.fill(warehouse));&#125;int main(int argc, char **argv)&#123; testing::InitGoogleMock(&amp;argc, argv); // Runs all tests using Google Test. return RUN_ALL_TESTS();&#125; 测试结果：1234567891011bash-4.2$ ./output/bin/order.exx [==========] Running 1 test from 1 test case.[----------] Global test environment set-up.[----------] 1 test from OrderTest[ RUN ] OrderTest.Fill[ OK ] OrderTest.Fill (0 ms)[----------] 1 test from OrderTest (0 ms total)[----------] Global test environment tear-down[==========] 1 test from 1 test case ran. (1 ms total)[ PASSED ] 1 test. 其中main函数和gtest差不多，只是初始化的是googlemock，我们着重了解的是几个宏的含义: MOCK_METHOD1234MOCK_METHOD#1(#2, #3(#4) )MOCK_CONST_METHOD2(hasInventory, bool(int, std::string));MOCK_METHOD2(remove, void(int, std::string)); 其中#1表示你要mock的方法共有几个参数，#2是你要mock的方法名称，#3表示这个方法的返回值类型，#4是这个方法具体的参数。 EXPECT_CALL1234using ::testing::Return;EXPECT_CALL(warehouse, hasInventory(50, "Talisker")) .Times(1) .WillOnce(Return(true)); 设定期望对象被访问的方式及其响应，其中warehouse为对象，希望hasInventory在传递参数为(50, “Talisker”)时，被调用且仅被调用一次，第一次返回true。 ON_CALL12345ON_CALL(#1, #2(#3)).WillByDefault(Return(#4));ON_CALL(foo, GetSize()) .WillByDefault(Return(1)); // ... other default actions ... 其中#1表示mock对象，#2表示个方法名称，#3表示方法的参数，#4表示参数为#1, #2，#3情况下返回结果。 ON_CALL和EXPECT_CALL的区别? ON_CALL定义了调用mock方法时会发生什么，但并不意味着对被调用方法的任何期望。 EXPECT_CALL不仅定义了行为，还设置了对给定次数（以及在指定顺序时按给定顺序）使用给定参数调用方法的期望。 GoogleMock 为开发者设定 Mock 类行为，跟踪程序运行过程及结果，提供了丰富的支持。但与此同时，应用程序也应该尽量降低应用代码间的耦合度，使得单元测试可以很容易对被测试单元进行隔离。(尽量做到高内聚，低耦合) 总结Googletest 与 GoogleMock，很好的简化了我们的C++单元测试工作，本篇文章对此做了一个总结，让自己对gtest有了一个系统的认识。测试并不只是测试工程师的责任，对于开发工程师，为了保证发布给测试环节的代码具有足够好的质量（ Quality ），为所编写的功能代码编写适量的单元测试是十分必要的。 如果还想更加深入的了解，可查阅官方文档： https://github.com/google/googletest/tree/master/googlemock/docs 参考链接 https://www.ibm.com/developerworks/cn/linux/l-cn-cppunittest/?mhq=gtest&amp;mhsrc=ibmsearch_ahttps://blog.csdn.net/russell_tao/article/details/7344739http://www.cnblogs.com/coderzh/archive/2009/03/31/1426758.htmlhttps://github.com/davidstutz/googlemock-example]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你有困惑吗]]></title>
    <url>%2F2018%2F12%2F15%2F%E4%BD%A0%E6%9C%89%E5%9B%B0%E6%83%91%E5%90%97%2F</url>
    <content type="text"><![CDATA[工程师层级人员讨论会 – 2018-12-7 上周，部门主管黄总和HR组织了一场讨论会，召集了大概20个开发，大概水平都是处于工程师层级，这个层级评定和你工作年龄无关，而是和你的工作产出，负责项目相关。在我看来，过去的大部分都是业务骨干，因为基本涉及部门所有产品线的所有开发人员，有工作两年的，工作4年，5年，8年的。确实，软件开发和年龄其实关系不大，而是和你负责的业务，技术水平相关。如果你负责公司的核心业务开发，只要你能支撑下来，就算你工作年限不长，技术水平不广，不深，但是因为你处在这个位置上，因此你也很有价值，但是话又说回来，如果你工作很多年，还是处于这个层级，那就确实是要考虑一下了，因为你陷入了一个瓶颈，可能工作中80%-90%的时间都是做一些常规项目，而且是做完这一个接着又做下一个。 因此对于多年处于这个阶段的人来说，是安排的工作太简单了，得不到提高，还是干活的人想的太简单，这个需要自身考虑清楚。 今天讨论会主要分为两个阶段，第一阶段，首先大家分为4个小组，然后每个组讨论，将自己工作中遇到的困惑，瓶颈，以及一些需要外部协助的点(包括公司层面，其他部门等)列出来。 总的说下来，大概就是以下几点： 项目周期太紧，需求开发时间安排不合理，整个项目中，产品部需求评审耗费时间较长，需求评审时，测试部也参与，而测试部往往疑问较多，导致评审周期拉的很长。(克服方法：尽量线上解决或者只参与自己负责的需求; 提前熟悉相关需求，做到提前量) 项目中，分配的模块整改，代码重构时间较短。导致重构做的不彻底，挖的不够深，整体性能和设计上，做的效果不明显。(克服方法：尽量早的提出预研，拉长时间周期；如果是影响后续大版本开发的重构，那没办法，必须做) 多线程工作，一个人同一个时间身上负责多个项目。在日常工作中，因为参与项目较多，导致工作经常性的被人打断，在多个项目中切换，效率很低。(克服方法：分析问题和编码，做好整体思路存档标记，问题处理完回来可以无缝切回来；对于插入问题，预先进行分析评估，短时间解决不了，另行安排时间，不纠缠) 工作中做的 90% 多都是常规工作，技术提升的、绩效突破性工作安排较少。(克服方法：自己向上级反馈, 主动提出) 最后一点是我对自己提出的，接触的模块多，技术点也多，但是由于总结意愿不强烈，导致很多东西掌握的不够系统，不够深入，当然也有一部分时间上的限制就是了(项目紧，工作忙) (克服方法：加强写总结的习惯，反省自己) 与外部对接方面工作，推动力不足，主导意愿不强，很多时间往往浪费在沟通和踢皮球上，对工作毫无进展。(克服方法：改变态度，无论是现在公司，还是以后的工作中，对于参与工作，要与担当，积极主动的去推进) 上述大部分遇到的问题，都是很多公司的问题，并不是公司独有，黄总也说面试过很多人，这些问题都是客观存在的，如果你能把这些克服，做好，那提升会很明显，一句话，效率最重要。 第二个阶段，提出四个需求，让大家进行讨论，给出一个大致的想法，思考方式。每个组选择了同一个，如下： 需求1：公司一款产品，之前支持存储5000个联系人，现在客户反馈不够，需要能支持5万个。 最后大家讲了一遍，给出的总体流程和思路如下： 可行性分析，该产品之前支持5000个，现在要升级一个数量级，基于现有系统的内存和CPU频率，是否能够支持这么多联系人的存储、搜索工作。 需求分析，之前方案设计实现背景，是否可以在之前方案上直接进行拓展; 竞品和公司其他产品线是否有相关方案的支持，如果支持，是否可以直接借鉴和复用; 现在是要求5万，后续如果再升级到10万，30万，50万，选择的方案是否可以支持，需要向拓展性上考虑 在原有方案下拓展优化，还是说对整个框架进行重构，如果重构，是要引进什么新的技术吗? 数据库? 如果引入新的技术，那如何保证整个系统的鲁棒性和可移植性，因为后续可能不止你一个产品要用，可能将方案适配到多个平台上去。 方案选择好后，需要同相关涉及模块的开发人员，一起讨论，对外进行评审，排除各个模块的风险 设计文档编写，给出整体的思维导图，理清各模块间交互，保证方案的拓展性和易维护性，方案整体要在时间和空间上进行平衡，保证搜索和存储都较好满足，某些场景可能需要牺牲空间来满足搜索的速度，而某些相反，最后将相关接口评审完毕，进入开发 开发完成后，需要编写相关测试用例，包括引入相关测试框架进行单元测试，性能测试，内存检测等。编写测试导图，以便测试部能够更好的展开测试工作 异常场景考虑，在开发和自测过程中，要将异常场景考虑在内，如果采用的是云端联系人存储，临时拉取方案，那如果向服务器请求时，出现丢失该如何处理；在满载，高负载场景下，是否会有异常，UI表现是否正常；是否要加入相关请求的防抖动处理，一句话，开发人员也要有测试思维，加强异常极限场景考虑。 大概就是上面两个事，总的来说收获是有的，对于测试这一块还需要做的更好，相关开源测试框架和性能工具需要多加使用。总的来说，勤写总结，吾日三省吾身，找到效率瓶颈，提升效率，提升技术水平是没错的。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程间通信-消息队列]]></title>
    <url>%2F2018%2F11%2F24%2F%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-2018-11-24%2F</url>
    <content type="text"><![CDATA[Message Queue 使用场景今天介绍一下消息队列，对此做个总结，酝酿了有一段时间，因为消息队列在开发中占据了一个很重要的地位。 一般这种系统设施，如果你是在 Linux 系统用户空间进行开发(内核开发除外的所有开发)，需要懂得其原理、接口使用、消息框架构建机制、封装系统提供的 MQ 接口来对上层提供服务。如果你是从事内核开发，那还需要将这些系统设施的实现了解清楚。我现在做的是系统应用层开发，就以我现在公司为例，开发的是嵌入式系统设备，之前公司消息机制使用的是 Linux 系统自带的消息队列，System V 那一套，后来因为系统资源确实匮乏，如果直接使用原生的消息队列机制，并发量太高的话，系统性能会下降(因为芯片太低端，而使用消息队列的功能模块在增加)，所以自己开发了一套消息机制，实现思路以及对外接口和原来差别不大。本次主要介绍 System V 和 Posix 消息队列使用和与之相关的设计模式。 消息队列（Message Queue），不仅是分布式系统中重要的组件, 也是我们客户机系统开发中的一个重要组件，特别是我们公司现在开发的系统，可以说完全是由消息驱动的系统，无论是进程间，还是进程内部，消息队列的发布/订阅模式，支撑起了整个系统框架。 首先，消息队列的使用场景主要有以下几个： 异步处理 非核心流程异步化，提高系统响应性能。发布者只需将消息通知出去，然后就可以去做其他事情。 程序解耦 对于不强依赖于非本系统的核心流程，可以放到消息队列中让消息消费者去按需消费，而不影响核心主流程，做到业务功能模块解耦 广播 发布/订阅模式，一个消息，可以多个对象定阅处理 流量削峰与流控 对于网络秒杀活动，消息队列可做缓冲处理 1.请求先入消息队列，而不是由业务处理系统直接处理，做了一次缓冲,极大地减少了业务处理系统的压力； 2.队列长度可以做限制，事实上，秒杀时，后入队列的用户无法秒杀到商品，这些请求可以直接被抛弃，返回活动已结束或商品已售完信息； 消息驱动的系统 避免直接调用下一个系统导致当前系统失败； 每个子系统对于消息的处理方式可以更为灵活，可以选择收到消息时就处理，可以选择定时处理，也可以划分时间段按不同处理速度处理； 通知其他系统做某些事情 以我现在公司的系统为例，上述场景除了流量削峰( 偏服务端 )，其他基本都有在系统中出现。公司开发的是通信终端系统，主要模块分为: GUI, 网络, 声音，协议等, 各模块都是系统中单独的一个进程, 各个进程间需要通信，则通过发消息的方式，十分方便; 同时进程内部也通过消息队列，对相关业务量比较重的核心模块，进行代码重构、解耦, 把一些非核心流程剥离出去，通过发消息的方式通知对应模块进行处理。 封装的接口形式和 windows 端的消息机制接口类似：1234msgPostMsgToThread() // 发送到特定线程msgBroadpostThreadMsg() // 广播etl_RegisterMsgHandle(TM_TIMER, TM_TIMER, &amp;CStatusManager::OnTimerMsgProgress); //订阅 通过上述接口，我们可以很方便的通知其他进程，并携带上相应的数据，完成进程间通信。消息机制完全采用发布/订阅模式。系统一启动，首先各个进程模块进行初始化操作，每个线程/进程会创建一个消息队列，进程中的各个模块按需调用 etl_RegisterMsgHandle() 接口，订阅消息。然后系统中各进程/线程间，会进行消息的定点发送或者广播，收到消息的进程则调用初始化时注册的 handle() 接口进行处理。 发布/订阅模式 (Publish-Subscribe) 首先介绍一下不包含消息队列的发布/订阅模式，我们先引用一下 20 年前的一本经典著作 GoF 中对发布/订阅模式的介绍, 发布/订阅模式别名观察者(observer), 依赖(Dependents), 该模式是一种对象行为型模式. 模式意图： 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。 模式结构类图 (引用自: GOF设计模式解析)主要角色： Subject: 目标 Observer: 观察者 传统的观察者模式的优点： 观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。 观察者模式在观察目标和观察者之间建立一个抽象的耦合。 观察者模式支持广播通信。 观察者模式符合”开闭原则”的要求。 观察目标和观察者之间不是紧密耦合，可以说建立了一个抽象耦合，观察者是知道Subject的，Subject也一直保持对观察者进行记录。然而在包含消息队列的发布/订阅模型中，发布者和订阅者并不知道对方的存在，它们只通过消息代理进行通信，组件是松散耦合的，而且观察者模式大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法。而包含消息队列的发布-订阅模式大多数时候是异步的（使用消息队列）。观察者模式需要在单个应用程序地址空间中实现，而发布-订阅更像交叉应用模式。 传统的观察者模式与包含消息队列的发布/订阅模型模式关系类似下图： POSIX 消息队列简单使用System V API 和 POSIX API 提供了消息队列，我们主要介绍一下 POSIX 特点： POSIX 和 System V 实现中的消息队列都具有内核级持续性 POSIX 主要接口信息：123456789101112131415161718192021222324252627282930313233343536373839404142#include: mqueue.h (sys/stat.h 用于在创建队列时使用权限宏)main types:1. mqd_t: 消息队列描述符2. struct mq_attr: 消息队列属性结构，定义如下： struct mq_attr &#123; long int mq_flags; /* Message queue flags. */ long int mq_maxmsg; /* Maximum number of messages. */ long int mq_msgsize; /* Maximum message size. */ long int mq_curmsgs; /* Number of messages currently queued. */ &#125;functions： mqd_t mq_open(const char *name, int flags, ... [ mode_t mode, struct mq_attr *mq_attr ])description：name消息队列名字; flags 用来表示打开消息队列的权限组合; 如果是以创建方式打开，则需要设置相应 的访问权限mode; 设置消息队列属性 mq_attr.return：返回消息描述符，或者（mqd_t）-1出错functions： int mq_close(mdq_t mqdes) return： 成功返回 0，错误返回 -1functions： int mq_unlink(const char *name)return： 成功返回 0，错误返回 -1functions：int mq_send(mqd_t mqdes, const char *msgbuf, size_t len, unsigned int prio)return： 成功返回 0，错误返回 -1functions：size_t mq_receive(mqd_t mqdes, char *buf, size_t len, unsigned *prio)return： 成功返回 0，或者（mqd_t）-1出错functions： int mq_getattr(mqd_t mqdes, struct mq_attr *mq_attr)return： 成功返回 0，或者（mqd_t）-1出错functions：int mq_setattr(mqd_t mqdes, const struct mq_attr *mqstat, struct mq_attr *omqstat)return： 成功返回 0，或者（mqd_t）-1出错functions：int mq_setattr(mqd_t mqdes, const struct mq_attr *mqstat, struct mq_attr *omqstat)return： 成功返回 0，或者（mqd_t）-1出错functions：int mq_notify(mqd_t mqdes, const struct sigevent *sevp);description： 在有消息时注册通知return：成功返回 0，或者（mqd_t）-1出错注： 编译时需要链接 rt 库 (Link with -lrt.) 模拟使用场景：1234* 模拟场景* 1. 总共三个进程，一个程序负责创建消息队列，一个发送消息，最后一个负责接收* 2. 接收程序使用 mq_notify 注册信号来处理消息从无到有的场景* 具体实现代码如下： cmake 程序 12345678910111213cmake_minimum_required(VERSION 2.8)add_definitions(-std=c++11)project(message_queue C CXX)aux_source_directory(. SRC_FILES)add_executable(message_queue $&#123;SRC_FILES&#125;)target_link_libraries(message_queue rt ) mq_create: 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include "errno.h"#include &lt;fcntl.h&gt; /* For O_* constants */#include &lt;sys/stat.h&gt; /* For mode constants */#include &lt;mqueue.h&gt;#define ERR_EXIT(m) \ do \ &#123; \ perror(m); \ exit(EXIT_FAILURE); \ &#125; while (0);int main(int argc, char * argv[])&#123; mqd_t mqid; mqid = mq_open("/zed", O_CREAT | O_RDWR, 0666, NULL); if (mqid == (mqd_t) - 1) &#123; ERR_EXIT("mq_open"); &#125; struct mq_attr attr; mq_getattr(mqid, &amp;attr); printf("max msg numb: [%ld], mq_msgsize: [%ld] byte, current msg size: [%ld], mq_flags[%ld]", attr.mq_maxmsg, attr.mq_msgsize, attr.mq_curmsgs, attr.mq_flags); mq_close(mqid); return 0;&#125; mq_send: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include "errno.h"#include &lt;fcntl.h&gt; /* For O_* constants */#include &lt;sys/stat.h&gt; /* For mode constants */#include &lt;mqueue.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define ERR_EXIT(m) \ do \ &#123; \ perror(m); \ exit(EXIT_FAILURE); \ &#125; while (0);typedef struct stu&#123; char data[32]; int index;&#125;STU;int main(int argc, char * argv[])&#123; mqd_t mqid; mqid = mq_open("/zed", O_RDONLY); if (mqid == (mqd_t) - 1) &#123; ERR_EXIT("mq_open"); &#125; STU stu; stu.index = 20; strcpy(stu.data, "my name is yejy"); printf("stu.data [%s], stu.index [%d]\n", stu.data, stu.index); mq_send(mqid, (const char*)&amp;stu, sizeof(stu), 1); struct mq_attr attr; mq_getattr(mqid, &amp;attr); printf("max msg numb: [%ld], mq_msgsize: [%ld] byte, current msg size: [%ld], mq_flags[%ld] \n", attr.mq_maxmsg, attr.mq_msgsize, attr.mq_curmsgs, attr.mq_flags); mq_close(mqid); return 0;&#125; mq_receive: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include "errno.h"#include &lt;fcntl.h&gt; /* For O_* constants */#include &lt;sys/stat.h&gt; /* For mode constants */#include &lt;mqueue.h&gt;#include &lt;signal.h&gt;#define ERR_EXIT(m) \ do \ &#123; \ perror(m); \ exit(EXIT_FAILURE); \ &#125; while (0);typedef struct stu&#123; char data[32]; int index;&#125;STU;struct sigevent sigev;mqd_t mqid;size_t size;void handle_sigusr1(int sig)&#123; mq_notify(mqid, &amp;sigev); // need registered again STU stu; unsigned int prio; if(mq_receive(mqid, (char*)&amp;stu, size, &amp;prio) == (mqd_t) -1) &#123; ERR_EXIT("mq_receive"); &#125; printf("data=[%s], index = [%d], prio = [%d]", stu.data, stu.index, prio);&#125;int main(int argc, char * argv[])&#123; mqid = mq_open("/zed", O_RDONLY); if (mqid == (mqd_t) - 1) &#123; ERR_EXIT("mq_open"); &#125; struct mq_attr attr; mq_getattr(mqid, &amp;attr); size = attr.mq_msgsize; printf("max msg numb: [%ld], mq_msgsize: [%ld] byte, current msg size: [%ld], mq_flags[%ld]\n", attr.mq_maxmsg, attr.mq_msgsize, attr.mq_curmsgs, attr.mq_flags); // signal signal(SIGUSR1, handle_sigusr1); sigev.sigev_notify = SIGEV_SIGNAL; sigev.sigev_signo = SIGUSR1; mq_notify(mqid, &amp;sigev); // Message from nothing, notify handle for (;;); // loop keep process execute mq_close(mqid); return 0;&#125; 总结对于相关设计模式需要懂得其原理与实现，毕竟这些是前人总结出来的宝贵经验，对我们的软件设计思维非常有帮助；至于消息队列，主要介绍了一下其思想与用途，以及对 POSIX 的消息队列接口做了一个简单模拟实现，了解了消息队列的基本使用。当然，作为计算机系统中的一个重要组件，在后端开发中，有很多优秀的消息队列中间件，后续有机会从事相关开发，再进行深入了解，通过此次文章总结，如果下次遇到消息队列相关问题和开发任务，应该会比较得心应手。]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>多线程编程</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不一样的周一]]></title>
    <url>%2F2018%2F11%2F19%2F%E9%9A%8F%E7%AC%94-%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%91%A8%E4%B8%80-2018-11-19%2F</url>
    <content type="text"><![CDATA[今天是 2018-11-19 日，周一，和以往的周一不太一样，首先我旁边少了一个人，导师加主管，上周离职了，惊讶加不解。不解的是公司发展到现在不容易，而他做到这个位置同样不易，而且已经不搞技术很久了，年龄也到了不惑有一，如果离开现在公司，外面还有更好的地方可以去吗？在我的印象里，他走的就是传统的程序员模式，从程序员开始，然后做Teamleader，最后是主管，这时候无需码代码，搞技术，整天就是开这个会那个会、需求评审、项目例会等等，忙的不可开交。到了这个时候，他最大的价值就是对公司的业务了如指掌，非常熟悉，基本每个功能点他都可以摸清楚。我在想，到这种地步，应该会一直呆公司吧，毕竟如果离开，成本太大了，去到新公司，要熟悉新业务不说，可能还要重新将拾起许久技术。 当然，他能够对现在业务摸的这么清楚，而且问题分析能力很强，逻辑思维很好，表达能力也强，十分善于沟通，项目管理这一块也很熟悉，所以优点是很明显的，到了新公司，我相信他也可以十分迅速的掌握新公司的业务，走上管理岗位。 第一个导师加主管，而且还是学长，教会了我很多，扮演着引入人的角色，对我十分关照，真的非常感谢。 希望您今后工作顺利，前程似锦！后会有期！ 当然，对我来说，我其实并不喜欢主管之前的状态，完全抛开技术，做管理工作。虽然现在我还比较迷茫，但是大方向还是确定的，我还是要搞技术，只是选哪个方向罢了，我觉得技术对我来说还是比较有吸引力的，毕竟技术改变未来，笑脸！ 今天是周一，像以往一样，我会先在阮一峰老师的博客上，看看有没有什么新鲜事，他是唯一一个可以把技术博客写的如此文艺的人，感觉非常不错。 从中看到印象最深刻的，莫过于计算机科学家 Tim Bray在一篇博客中谈到自己可能退休，但是令人感叹的不是退休，而是他对事物，对工作的态度。 Rea­sons to keep work­ing I get to write soft­ware that fil­ters and routes a mil­lion mes­sages a sec­ond. 编写软件，每秒过滤路由100万个消息 I’m in a po­si­tion where it’s re­al­ly hard for peo­ple not to lis­ten to my opin­ions abouttech­nol­o­gy. I’d be­come amaz­ing­ly un­in­ter­est­ing about fif­teen sec­onds af­ter re­tir­ing. 处于一个别人很难不听取我技术意见的位置 I learn things all the time about how to think about how to use com­put­er­s. 我一直在学习思考如何使用计算机 I get a chance to move the needle, a lit­tle, on the way peo­ple use com­put­er­s. 我有机会在人们使用计算机的方式上移动一针 I like com­put­er­s, and so it makes sense to work for (what I as­sume must be) the world’s largest provider of com­put­ers to peo­ple and busi­ness­es who use them. 我喜欢计算机 现在工作中，我还无法保持这种热情，那我是不是也可以退休了? 非也，我们可以努力培养自己这方面的能力，对事物持续投入热情的能力。虽然，有的时候早上起来还处于 Some morn­ings, I feel like sleep­ing in. 状态，但我相信这只是暂时的 ！ 参考： http://www.ruanyifeng.com/blog/2018/11/weekly-issue-31.htmlhttps://dev.to/acoh3n/why-i-love-java-5c14https://phpocean.com/blog/article/learning-programming-is-different-from-learning-a-programming-language/80]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统-进程互斥和同步]]></title>
    <url>%2F2018%2F11%2F18%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5-2018-11-18%2F</url>
    <content type="text"><![CDATA[背景 为什么会有同步和互斥？ 因为计算机系统中有多个进程存在，多个进程间进行交互，会引起它们对 共享资源的访问，如果这些资源处理不当，就可能出现一些意想不到的情况，比如说 饥饿，死锁等一系列问题。为什么会出现 饥饿，死锁问题，主要还是和进程调度相关。如果进程相对独立，彼此之间没有共享资源，彼此不需要发送数据或者通知对方干某些事情，那么进程和线程的执行过程是确定的，可重复的，那就不存在上述问题。但是如果不独立，彼此间需要进行交互，那么这种情况下，由于 调度系统的管理，有可能一会先调用这个进程，一会又先调用另一个进程，由于进程调度顺序不确定，可能导致对于单个进程而言，执行过程出现不确定性和不可重复性，因此会引入一些很难发现的 bug，导致系统出现不稳定的现象。 上述现象，称为Race Condition(竞态条件)。虽然有上述问题，但是进程间交互，共享资源又是必不可少的，因此我们需要引入同步和互斥来解决上述不确定性问题。 一些基本概念 Atomic Operation (原子操作)原子操作是指一次不存在任何中断或者失败的执行。 Critical Section (临界区) ：满足互斥，前进，有限等待临界区是指进程中的一段需要访问共享资源并且当另一个进程处于相应代码区域时便不会被执行的代码区域。(简单说：访问共享资源的一段代码) Mutual exclusion (互斥)当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源。(简单说：不允许多个进程进入临界区去访问) Dead lock (死锁)两个或以上的进程，在相互等待完成特定任务，而最终没法将自身任务进行下去。(简单说：两个进程需要等待对方的资源而导致无法向下执行) Starvation (饥饿)一个可执行的进程，被调度器持续忽略，以至于虽然处于可执行状态却不被执行。 临界区代码的保护方法 (锁的设计方法) 禁用硬件中断时钟中断，进行进程调度，执行临界区时屏蔽中断 缺点： 临界区执行时间过长，对系统整体执行效率影响很大 多CPU并行执行，屏蔽一个CPU中断不管用，无法解决互斥 基于软件的解决方法除了用在一般操作系统中，也用在分布式系统当中。 皮特森(Peterson)算法flag表示本进程已经准备好了想进去，然后如果两个进程都想进那么就要设立一个turn标志，turn表示如果两个进程都想进去临界区，turn=i就允许i进程进临界区。因为turn只能是一个值，所以也保证了两个进程竞争时只能有一个进去。如果不竞争，那turn无意义。（可使用反证法证明） Dekker算法 针对双线程 Bakery算法 针对n线程临界区问题解决方案 Peterson 算法大致代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;pthread.h&gt;#define true 1#define false 0typedef int bool;bool flag[2];int turn;void procedure0()&#123; while(true) &#123; flag[0] = true; turn = 1; while(flag[1] &amp;&amp; turn == 1)//退出while循环的条件就是，要么另一个线程 //不想要使用关键区，要么此线程拥有访问权限。 &#123; sleep(1); printf("procedure0 is waiting!\n"); &#125; //critical section flag[0] = false; &#125;&#125;void procedure1()&#123; while(true) &#123; flag[1] = true; turn = 0; while(flag[0] &amp;&amp; turn == 0) &#123; sleep(1); printf("procedure1 is waiting!\n"); &#125; //critical section flag[1] = false; &#125;&#125;void main()&#123; pthread_t t1,t2; flag[0] = flag[1] = false; int err; turn = 0; err = pthread_create(&amp;t1,NULL,(void*)procedure0,NULL); if(err != 0) exit(-1); err = pthread_create(&amp;t2,NULL,(void*)procedure1,NULL); if(err != 0 ) exit(-1); pthread_join(t1,NULL); pthread_join(t2,NULL); exit(0);&#125; Dekker 算法大致代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;pthread.h&gt;#define true 1#define false 0typedef int bool;bool flag[2];int turn;void visit(int num)&#123; sleep(1); printf("P%d is visting\n",num);&#125;void P0()&#123; while(true) &#123; flag[0] = true;//P0想使用关键区。 while(flag[1])//检查P1是不是也想用？ &#123; if(turn == 1)//如果P1想用，则查看P1是否具有访问权限？ &#123; flag[0] = false;//如果有，则P0放弃。 while(turn == 1);//检查turn是否属于P1。 flag[0] = true;//P0想使用。 &#125; &#125; visit(0); //访问Critical Partition。 turn = 1; //访问完成，将权限给P1。 flag[0] = false;//P0结束使用。 &#125;&#125;void P1()&#123; while(true) &#123; flag[1] = true; //P1想使用关键区。 while(flag[0]) //检查P0是不是也想用？ &#123; if(turn == 0) //如果P0想用，则查看P0是否具有访问权限？ &#123; flag[1] = false; //如果有，则P1放弃。 while(turn == 0); //检查turn是否属于P0。 flag[1] = true; // P1想使用。 &#125; &#125; visit(1); //访问Critical Partition。 turn = 0; //访问完成，将权限给P0。 flag[1] = false; //P1结束使用。 &#125;&#125;void main()&#123; pthread_t t1,t2; flag[0] = flag[1] = false; turn = 0; int err; err = pthread_create(&amp;t1,NULL,(void*)P0,NULL); if(err != 0) exit(-1); err = pthread_create(&amp;t2,NULL,(void*)P1,NULL); if(err != 0 ) exit(-1); pthread_join(t1,NULL); pthread_join(t2,NULL); exit(0);&#125; 更高级的抽象 (基于硬件原子操作指令，将下述两个流程封装成了机器指令，执行过程中不允许执行中断和切换)Test-and-Set 12345678910111213141516171819202122boolean TestAndSet(boolean *target)&#123; boolean rv = *target; *target = TRUE; return rv;&#125;具体使用例子：class Lock&#123;int value = 0;Acquire();Realease();&#125;;Lock::Acquire()&#123;while(test-and-set(value));//spin (当有进程执行，将value设置成1，其他进程再来执行的时候就一直是1，进入while循环自旋，直到value = 0)&#125;Lock::Realease()&#123;value = 0;&#125; Exchange 123456789101112131415161718void Exchange(boolean *a, boolean *b)&#123; boolean temp = *a; *a = *b; *b = temp;&#125;共享数据： int lock = 0;线程Ti int key; do&#123; key = 1; while(key == 1) Exchange(lock, key); critical section lock = 0; remainder section &#125; 如果觉得进程自旋忙等浪费CPU性能，而且临界区执行时间较长，那可以通过上下文切换，使得等待进程进入阻塞睡眠，当临界区进程执行完，再进行唤醒。是采用忙等还是进行上下文切换让进程进入睡眠，需要看一下临界区执行时间是否很长，如果执行时间长，则让进程进入睡眠。如果临界区执行时间很短，反而上下文切换对CPU损耗时间更长，则采用忙等。 信号量同步机制，临界区多个线程和进程来执行，进入临界区只是做读操作而不是写操作，如果只是读操作，那就没必要只是限制一个进程或者线程执行，可以有多个线程或者进程执行。多个进程或线程那么就要引入信号量来解决这个问题。 数据抽象-&gt; 一个整形(sem)，两个原子操作-&gt; P(): sem减1，如果sem &lt; 0，等待，否则继续执行-&gt; V(): sem加1，如果sem &lt;= 0, 唤醒一个等待的P 信号量特点 信号量是有符号整数一开始我们会设置成一个大于 0 的数，多次进行P()操作，一旦信号量小于0，则执行P()操作的 进程不能再向下执行，该进程就需要挂在该信号量上面。直到有其他进程执行V()操作，而且信 号量还小于等于0，则判断有进程挂在该信号量上面，因此唤醒一个进程 信号量是被保护的变量-&gt; 初始化完成后，唯一改变一个信号量的值得办法是通过P()和V()-&gt; 操作必须是原子的 P() 能够阻塞, V() 不会阻塞 我们假定信号量是 “公平的”FIFO先进先出队列管理挂在信号量上面的进程 两种类型的信号量-&gt; 二进制信号量: 可以是0或者1 (可以完成锁机制功能)-&gt; 一般/计数信号量: 可取任何非负值 (允许多个执行P()操作的进程进入临界区)-&gt; 两者相互表现(给定一个可以实现另一个) 信号量可以用在2个方面-&gt; 互斥-&gt; 条件同步 (调度约束 – 一个线程等待另一个线程的事情发生) 信号量使用 (解决生产者-消费者问题)生产者-消费者正确性要求： 在任何一个时间只能有一个线程操作缓冲区(互斥) 当缓冲区为空，消费者必须等待生产者(调度/同步约束) 当缓冲区满，生产者必须等待消费者(调度/同步约束) 示例伪代码： 123456789101112131415161718192021class BoundedBuffer&#123; mutex = new Semaphore(1); fullBuffers = new Semaphore(0); // 初值为 0 emptyBuffers = new Semaphore(n); // 初值为 n &#125; BoundedBuffer::Deposit(c)&#123; emptyBuffers-&gt;P(); mutex-&gt;P(); Add c to the buffer; mutex-&gt;V(); fullBuffers-&gt;V(); &#125; BoundedBuffer::Remove(c)&#123; fullBuffers-&gt;P(); mutex-&gt;P(); Remove c to the buffer; mutex-&gt;V(); emptyBuffers-&gt;V(); &#125; 信号量的实现大致代码： 1234567891011121314151617181920class Semaphore&#123; int sem; WaitQueue q;&#125;Semaphore::P()&#123; sem--; if(sem &lt; 0)&#123; Add this thread t to q; block(t); &#125;&#125;Semaphore::V()&#123; sem++; if(sem &lt;= 0)&#123; Remove a thread t from q; wakeup(t); &#125;&#125; 管程由于信号量机制的缺点：进程自备同步操作，P(S)和V(S)操作大量分散在各个进程中，不易管理，易发生死锁。因此引入管程的概念，这是一种比信号量更高的抽象。或者说并没有这种实体存在于系统或编程语言中，更多的是一种机制，一种解决方法，但是编程语言和操作系统都提供了实现管程的重要部件条件变量。 管程特点：管程封装了同步操作，对进程隐蔽了同步细节，简化了同步功能的调用界面。用户编写并发程序如同编写顺序(串行)程序。 目的：分离互斥和条件同步的关注 什么是管程：-&gt; 一个锁：指定临界区-&gt; 0或者多个条件变量：等待通知信号量用于管理并发访问共享数据 管程具体的执行流程图进程或线程以队列方式进入临界区前，执行wait(), 如果不能满足条件变量，则将进程或线程挂在相应条件变量队列上，直到有其他进程或线程执行完临界区，执行Signal(), 唤醒相应队列中的进程或线程继续执行。 管程实现其中wait()需要释放 lock，是由于在进入管程接口时，会先加锁，确保同一时刻只能有一个进程或者线程调用。 实现生产者消费者问题 总结主要介绍了锁，信号量，管程(管程依赖于锁和条件变量)。这三种机制可以解决同步互斥问题。需要注意的是，即使是有同步互斥方法来解决这些问题，但是由于不确定性现象的存在，使得对它进行调试分析很困难，出错了需要知道是怎么错的，因为下次重复操作的时候，问题可能不会重复出现，那么这种情况下，就需要我们 仔细的去设计和分析相应的同步互斥的操作过程，才能够解决此类问题。 总的来说，想要用好同步互斥，需要我们仔细的去分析问题，设计相应的操作流程，才能够有效的解决同步互斥的问题。]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>多线程编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统--进程间通信(一)]]></title>
    <url>%2F2018%2F11%2F14%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-2018-11-14%2F</url>
    <content type="text"><![CDATA[IPC 运用范畴 配图与本文无关，纯属有趣 相对于做点什么，我们更想睡懒觉，但是相对于睡觉，我想写总结！今天把博客的 git 分支搞混了，浪费了一点时间。那么今天介绍一下进程间通信(IPC) 。进程间通信，我们从 &lt;&lt; UNIX网络编程卷2：进程间通信 &gt;&gt; 最后一章 Sun RPC 谈起，那为什么呢？ 因为我们去掌握一个东西，肯定是因为它有价值，我们才去学习，如果一些技术现在都不用了，淘汰了，那我们就没有必要去深究，只需学习其思想，浅尝辄止即可。最后一张概述部分是这样介绍的，构筑一个应用程序时，我们首先在以下两者之间作出选择： (1) 构筑一个庞大的单一程序，完成全部工作； (2) 把整个应用程序散步到彼此通信的多个进程中。如果我们选择后者，接下去的抉择是： (2a) 假设所有进程运行在同一台主机上 (允许 IPC 用于这些进程间的通信)； (2b) 假设某些进程会运行在其他主机上 (要求使用进程间某种形式的网络通信)。 这本著作主要关注的是 2a 这种情况，也就是 使用消息传递、共享内存、并可能使用某种形式的同步来进行同一台主机上的进程间 IPC。同一进程内不同线程间的 IPC 以及不同进程内各个线程间的 IPC只是这种情形的特殊情况。 而对于不同部分之间需要网络通信的应用程序则大多数使用 显示网络编程（explicit network programming)方式编写，也就是我们现在流行的 Socket编程。 那么现在是什么情况呢？ 由于互联网大火，导致现在主流热门的进程间通信方式变成了使用 Socket 套接字通信。这个也可以理解，由于互联网就是传统的 C/S(服务器端-客户端)架构，对于客户端开发来说，主要就是移动应用开发、PC端应用开发、Web 浏览器开发，这些是互联网主要的流量入口，应用和浏览器需要通信的对象就是服务器，服务器要做的也是和客户端更好的进行通信，所以如果需要从事互联网的工作，那么对 Socket 编程相对于其他 IPC 手段就需要更熟悉，特别是服务器后台开发，客户端还好，客户端业务逻辑和 UI 体验相对重要，至于一些系统层技术，开发框架都已经封装的很好了，只需掌握使用方法就可以，像android 、 IOS开发。但是如果你是从事系统开发，那么所有的 IPC 方式都需要了解，特别是消息传递、共享内存需要深入了解。 具体的 IPC 手段信号软件中断通知事件处理 例如：SIGFPE, SIGKILL, SIGUSR1, SIGSTOP, SIGCONT接收到信号会发生什么： Catch：指定信号处理函数被调用 Ignore：依靠操作系统的默认操作 example：Abort，memory dump，suspend or resume process Mask：闭塞信号，因此不会发生 可能是暂时的（处理同样类型的信号） 不足：不能传输要交换的任何数据 特点： signals are only delivered between processes when either: 仅在同一个用户的进程间传递，或者超级用户发出信号 the processes involved are run by the same user the raising process is run by a superuser signal types and type names are defined in signal.h 定义在 signal.h 文件 signals are not queued 信号没有排队 handlers “terminate process” (SIG_DFL) and “ignore signal” (SIG_IGN) are already defined in signal.h 常用终止进程和忽略信号定义在 signal.h unix 主要接口信息：12345678910#include: signal.hfunctions：void raise(int sig_type)description：用信号sig_type发信号。functions：void signal(int sig_type, void (*sig_handler)(int signal_type))description：sig_type是signal.h中定义的信号值（或名称）之一。 sig_handles是一个指向带有int参数的函数的指针。当进程被指定类型的信号命中时，此函数将在进程上下文中运行。functions：int kill(pid_t dest_pid, int sig_type)description：向使用PID dest_pid运行的进程发送sig_type类型的信号。 dest_pid的特定类型0和-1 make kill（）分别发送与发送方的同一组执行的所有进程，并发信号通知系统中运行的所有进程（仅适用于超级用户凭据)。 管道和FIFO1.管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。特点： pipes are uni-directional 半双工 with file descriptors, they can only be shared between processes with parent-child relationship 只能用于父子进程间 atomicity is guaranteed for messages shorter than PIPE_BUF bytes 特定大小缓存保持原子性 alf-open pipes are told widowed (or broken) pipes. Writing on them causes a write error, reading from them always returns 0 bytes. 坏的管道，会出现写错误，读取时，返回0字节. unix 主要接口信息：1234#include: unistd.hfunctions： int pipe(int *fd_couple) description：创建一个管道并将其文件描述符存储到fd_couple [0]（读取结束）和fd_couple [1]（写入结束）。 return： 成功返回 0，错误返回 -1 模拟使用场景，实现 Linux 系统调用 popen，主要代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869FILE * vpopen(const char * cmdstring, const char * type)&#123; int pfd[2]; FILE * fp; pid_t pid; if ((type[0] != 'r' &amp;&amp; type[0] != 'w') || type[1] != 0) &#123; errno = EINVAL; return (NULL); &#125; if(pipe(pfd) != 0) &#123; return NULL; &#125; if((pid = vfork()) &lt; 0) // vfork 相对于fork区别是: vfork需要等待子进程执行完后才开始执行，两者共享地址空间 &#123; return NULL; &#125; else if(pid == 0) // 子进程 &#123; if(*type == 'r') &#123; close(pfd[0]); if (pfd[1] != STDOUT_FILENO) &#123; dup2(pfd[1], STDOUT_FILENO); close(pfd[1]); &#125; &#125; else &#123; close(pfd[1]); if (pfd[0] != STDIN_FILENO) &#123; dup2(pfd[0], STDIN_FILENO); close(pfd[0]); &#125; &#125; if(execl("/bin/bash", "bash", "-c", cmdstring, (char *) 0) &lt; 0) &#123; return NULL; &#125; &#125; wait(0); // 等子进程结束，回收子进程 if (*type == 'r') &#123; close(pfd[1]); if ((fp = fdopen(pfd[0], type)) == NULL) &#123; return (NULL); &#125; &#125; else &#123; close(pfd[0]); if ((fp = fdopen(pfd[1], type)) == NULL) &#123; return (NULL); &#125; &#125; return (fp);&#125; 2.有名管道，FIFO，特点： 每个FIFO有一个路径名与之关联，允许无亲缘关系进程间的通信 拥有标准管道的属性和特征 unix 主要接口信息：1234* #include: sys/types.h and sys/stat.h* functions： int mkfifo(char *path, mode_t mode) * description：path是要创建的FIFO文件的（路径+）名称。 mode是文件权限（请参阅umask（2）和chmod（2））* return： 成功返回 0，错误返回非 0 模拟使用场景：1234567* 模拟场景* 1. 在 shell 端使用命令创建有名管道： mkfifo /tmp/named_pipe* 2. 运行该接口* 3. 在 shell 端写入数据到管道 ：echo "hey, this is a message" &gt; /tmp/named_pipe* 4. 测试完毕，删除管道： rm /tmp/named_pipe* * 当然我们也可以自己启动一个任意进程向FIFO管道里面写数据 具体实现代码：123456789101112131415161718192021222324252627282930313233343536373839404142int fifo_read()&#123; int pipe; char ch; static char TmpCh; /* we expect a named pipe has been created * in /tmp/named_pipe . The command * $ mkfifo /tmp/named_pipe * is a friend to get to this point */ pipe = open("/tmp/named_pipe", O_RDONLY); if (pipe &lt; 0) &#123; printf("open fifo error, maybe you should create a fifo first !\n"); exit(1); &#125; /* preparing to read from the pipe... */ printf("Waiting data from the pipe... \n"); /* reading one char a time from the pipe */ while (1) &#123; if (read(pipe, &amp;ch, 1) &lt; 0) &#123; printf("Read the pipe failed! \n"); exit(2); &#125; if(ch != TmpCh) &#123; printf("%c", ch); &#125; TmpCh = ch; &#125; /* leaving the pipe */ close(pipe); return 0;&#125; 总结上述主要对IPC做了一个大体的介绍，以及介绍了信号(signal)和管道两种IPC方式，这两者在Linux系统自带功能实现中用的较多。至于 Posix和 System V的进程间通信方式 消息队列，信号和 共享内存，由于内容较多后面再单独介绍。]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统-线程概述]]></title>
    <url>%2F2018%2F11%2F09%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0-2018-11-9%2F</url>
    <content type="text"><![CDATA[为什么使用线程 我们需要一种新的实体(线程)，既能够满足不同实体之间可以并发执行，同时可以共享相同的地址空间和文件资源等，相对于进程，减少创建和切换时的开销。 什么是线程 Thread: 进程当中的一条执行流程 从两个维度来理解进程： 从资源组合的角度：进程把一组相关的资源组合起来，构成了一个资源平台(环境)，包括地址空间(代码段，数据段)，打开的文件等各种资源。 从运行的角度：代码在这个资源平台上的一条执行流程。(这个执行流程既是线程 ) 即：线程 = 进程 - 共享资源 (完成一个控制流的管理) 1. 线程优点： 一个进程中可以同时存在多个线程 各个线程之间可以并发执行 各个线程之间可以共享地址空间和文件等资源 2.线程缺点： You have to explicitly coordinate access to shared date with locks. If you forget a lock, you’ll end up with corrupted data. (共享数据需加锁) Circular dependencies amongst locks can lead to deadlocks. (导致死锁) They are hard to debug with subtle timing issues. (执行时序不确定，难以调试) Callbacks don’t work with locks. (回调不适用于锁) It’s hard to get good performance. (很难有好的表现) They are “too hard for most programmers to use, and even for experts development is painful.” (难以使用) 上述缺点是 1995 年 John Ousterhout 在一个演说中提到的，因为当时时间较早，所以其中有些缺点，比如说难用，回调不适用于锁 (有待考证)，表现不好等，现在可能已经克服了，像 Linux 系统中 NPTL 模型实现的 pthreads 库，以及其他语言实现的多线程库，例如：java 线程库，封装的都很好，使用起来也都十分方便; 但是 共享数据需加锁，死锁, 执行时序不确定，难以调试，这三点依然是现在多线程编程中面临的最大挑战。 Attention：线程和进程比较： 进程是资源分配单位，线程是CPU调度单位； 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈，来达到独立的控制流； 线程同样具有就绪，阻塞和执行三种基本状态，同样具有状态之间的转换关系； 线程能减少并发执行的时间和空间开销：- 线程的创建时间比进程短； - 线程的终止时间比进程短； - 同一进程内的线程切换时间比进程短； - 由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信 线程的实现传统的操作系统主要有三种线程的实现方式:1. 用户线程：在用户空间实现123456789101112POSIX Pthreads， Mach C-threads, Solaris threads在用户空间实现的线程机制，它不依赖于操作系统的内核，由一组用户级线程库函数来完成线程的管理，包括线程的创建，终止，同步和调度等。* 缺点1. 一个线程发起系统调用而阻塞，则整个进程等待2. 当一个线程运行，除非主动交出CPU使用权，否则它所在进程中的其他线程将无法运行3. 由于时间片是分给进程，故与其他进程相比，在多线程执行时，每个线得到的时间片较少，执行会比较慢* 优点1. 无需用户态和内核态切换，速度快2. 允许每个进程拥有自己的调度算法 2. 内核线程：在内核中实现123windwos ，Solaris， Linux指在操作系统内核当中实现的一种线程机制，由操作系统的内核来完成线程的创建，终止和管理，开销较大 3. 轻量级进程：在内核中实现，支持用户线程123Solaris （LightWeight Process）内核支持的用户线程。一个进程可以有一个或者多个轻量级进程，每个轻量级进程由一个单独的内核线程来支持。 Linux 系统线程实现那么最新版本的 Linux 系统中的 pthreads 线程库中的线程是如何实现的呢 ? 我参考了一下书籍 &lt;&lt; Linux 内核设计与实现&gt;&gt; 以及 Linux Programmer&#39;s Manual 当中的描述, 实现流程大致如下： Linux Programmer’s Manual 描述的实现: 1234567891011121314Linux implementations of POSIX threads Over time, two threading implementations have been provided by the GNU C library on Linux: LinuxThreads This is the original Pthreads implementation. Since glibc 2.4, this implementation is no longer supported. NPTL (Native POSIX Threads Library) This is the modern Pthreads implementation. By comparison with LinuxThreads, NPTL provides closer conformance to the requirements of the POSIX.1 specification and better performance when creating large numbers of threads. NPTL is available since glibc 2.3.2, and requires features that are present in the Linux 2.6 kernel. Both of these are so-called 1:1 implementations, meaning that each thread maps to a kernel scheduling entity. Both threading implementations employ the Linux clone(2) system call. In NPTL, thread synchronization primitives (mutexes, thread joining, and so on) are implemented using the Linux futex(2) sys‐ tem call. 在 Linux 2.6 kernel 版本后, 采用的是 NPTL 模型来实现。该模型是一个所谓的 1×1 线程库，其中由用户创建的线程（通过pthread_create() 库函数）与内核中的 可调度实体（Linux中的任务）进行1-1对应，是十分简单的线程实现方式。 假如我们要在一个进程中创建四个线程, 在 Linux 系统中，实现思路是：创建四个进程并分配四个普通的 task_struct (PCB 在代码中的表示) 结构, 然后在建立这个四个进程时，指定它们共享某些资源即可。 也就是说 Linux 系统中创建进程和线程是类似的，最终都是调用 clone()，只是对外封装接口表现不一样，传入参数不一样而已。 参考 https://www.bilibili.com/video/av6538245/?p=2 https://blog.acolyer.org/2014/12/09/why-threads-are-a-bad-idea/ 书籍： &lt;&lt; Linux 内核设计与实现 &gt;&gt; -Robert Love]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>多线程编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统--进程管理(二)]]></title>
    <url>%2F2018%2F11%2F03%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%BA%8C-2018-11-3%2F</url>
    <content type="text"><![CDATA[进程状态(State) 操作系统通过维护进程状态队列，来对进程进行管理。 状态队列： 由操作系统来维护一组队列，用来表示系统当中所有进程的当前状态； 不同的状态分别用不同的队列来表示(就绪队列，各种类型的阻塞队列)； 每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生改变时，它的PCB从一个队列中脱离出来，加入到另一个队列。 进程的生命周期管理12345678910111213141516171819202122232425* 进程创建 引起进程创建的三个主要事件： * 系统初始化时;(创建init进程，负责创建其他新的进程) * 用户请求创建一个新进程； * 正在运行的进程执行了创建进程的系统调用；* 进程运行 内核选择一个就绪进程，让它占有处理机并执行（涉及相关调度算法，来满足如何选择进程何时来执行）* 进程等待 在以下情况下，进程等待(阻塞)： 1. 请求并等待系统服务，无法马上完成(例如：执行I/O，请求硬盘时) 2. 启动某种操作，无法马上完成(需要等待其他进程完成某个操作才可以执行) 3. 需要的数据没有到达 进程一旦由运行态转换成等待状态就不占有CPU了，那么其他就绪进程就可以占有CPU执行。进程等待(阻塞)只能由进程自己触发， 因为只有进程自己知道才能知道何时需要等待某种事件的发生。* 进程唤起（由阻塞态转换为就绪态） 唤醒进程的原因： 1. 被阻塞进程的需要的资源得到满足 2. 被阻塞进程等待的事件可达 3. 将该进程的PCB插入到就绪队列 进程只能被别的进程或者操作系统唤醒* 进程结束 进程的状态变化模型 进程的三种基本状态：进程在生命结束前处于且仅处于三种基本状态之一，不同系统设置的进程状态数目不同。 运行状态(Running)：当一个进程正在处理机上运行时。 就绪状态(Ready): 一个进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。 等待状态(又称阻塞状态Blocked)：一个进程正在等待某一事件而暂停运行时。如等待某资源，等待输入/输出完成。 进程的挂起模型 进程在挂起状态时，意味着进程没有占有内存空间，处在挂起状态的进程映像在磁盘上。 挂起状态： 阻塞挂起状态(Blocked-suspend)：进程在外存并等待某事件的出现 就绪挂起状态(Ready-suspend)：进程在外存，但只要进入内存即可运行 进程调度算法 FCFS: first come fist server (先来先服务) 12345优点：简单缺点：* 平均等待时间波动较大* 花费时间少的任务可能排在花费时间长的任务后面* 可能导致I/O和CPU之间的重叠处理 SPN/SRT : 短任务优先 1234567按照预测的完成时间来将任务入队。可以是可抢占的或者不可抢占的，可抢占：又叫shortest-Remaining-Time(SRT) (最短剩余时间)优点：不公平，最优平均等待时间缺点：* 优先考虑短时间进程，可能导致饥饿* 需要预知未来，如何预估进程执行时间长短(根据过去预估未来) HRRRN : 最高响应比优先 (在SPN基础上改进) 1234R = (W + S)/S W ：waiting time 等待时间S ：service time 执行时间选择R值最高的进程，充分考虑了进程等待的时间，缓解饥饿现象，不可抢占 Round Robin 轮循调度算法 123456在叫作时间切片的离散单元中分配处理器，时间片结束时，切换到下一个准备好的进程经验规则：维持上下文切换开销处于1%以内，99%的时间用在实际进程执行中优点：公平缺点：平均等待时间较差 MLFQ 多级反馈队列 1动态的根据进程执行的过程，操作系统可以根据进程具有cpu密集型和I/O密集型的特征来动态的调整进程优先级 Fair-share scheduling 公平共享调度 1使得用户的请求在不同的级别享受公平调度，是在进程级别还是用户级别或者用户组级别公平的共享进程的调度]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统--进程管理(一)]]></title>
    <url>%2F2018%2F11%2F02%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B8%80-2018-11-2%2F</url>
    <content type="text"><![CDATA[缅怀 就在昨天，MVP 的呼声响彻标靶中心球馆，步入不惑的玫瑰，拿下了生涯新高 50 分，曾经的天之骄子，风城玫瑰，NBA 历史上最年轻的常规赛 MVP，经过多年坎途，不曾在病魔面前哭泣，而在昨天却低下了头，落下了泪… 感慨万千，脑海中记着的依然是 09 年那一轮史诗级季后赛，还有那个给芝加哥带来无限希望的玫瑰。此刻，向传奇致敬！加油，罗斯！ 进程定义 一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。 说的直接一点，我们编写代码时，一个 mian() 函数的动态执行过程就是一个进程，当然还包括这个 main() 函数执行过程中使用的资源和数据。 进程的组成一个进程应该包括： 程序的代码； 程序处理的数据； 程序计数器中的值，指示下一条将运行的指令； 一组通用的寄存器的当前值，堆，栈； 一组系统资源(如内存资源，文件系统，网络等一系列资源) 总之，进程包含了正在运行的一个程序的所有状态信息。 进程与程序的关系 程序是产生进程的基础 程序的每次运行构成不同的进程 进程是程序功能的体现 通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包含多个程序。 进程与程序的区别 进程是 动态的，程序是静态的：程序是有序代码的集合；进程是程序的执行，进程有核心态用户态 进程是 暂时的，程序是永久的：进程是一个状态变化的过程，程序可长久保存 进程与程序的组成不同：进程的组成包括程序，数据和进程控制块(即进程状态信息) 进程的特点 动态性：可动态的创建，结束进程； 创建接口 fork(), 结束进程： kill 等。 并发性：进程可以被独立调度并占有处理机运行；多核并行，单核一段时间内并发执行； 独立性：不同进程的工作不相互影响；(正确性不受影响，操作系统内存管理，页表管理使得不同进程访问不同的物理内存，相互之间独立不受影响。越过地址空间会产生缺页异常。保证进程独数据独立性。) 制约性：因访问共享数据/资源或者进程间同步产生制约； 进程控制结构(PCB) 进程控制块：操作系统管理控制进程运行所用的信息集合。操作系统用PCB来描述进程的基本情况以及运行变化过程，PCB是进程存在的唯一标志。 使用进程控制块 进程的创建：为该进程生成一个PCB进程终止：回收它的PCB进程的组织管理：通过对PCB的组织管理来实现 对进程的创建，终止和管理都是通过处理PCB来完成。 PCB包含的三大类信息 进程标识信息。如本进程的标识，本进程的产生者标识(父进程标识)；用户标识。 处理机状态信息保存区。保存进程的运行现场信息： 1. 用户可见寄存器，用户程序可以使用数据，地址等寄存器。 2. 控制和状态寄存器，如程序计数器(PC)，程序状态字(PSW)。 3. 栈指针，过程调用/系统调用/中断处理和返回时需要用到它。 进程控制信息： 1. 调度和状态信息，用于操作系统调度进程并占用处理机使用。 2. 进程间通信信息，为支持进程间与通信相关的各种标识，信号，信件等，这些信息存放在接收方的进程控制块里面。 3. 存储管理信息，包含有指向本进程影像存储空间的数据结构。 4. 进程所用的资源，说明由进程打开，使用的系统资源，如打开的文件等。 5. 有关数据结构连接信息，进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB。 PCB的组织方式 链表： 同一状态的进程其 PCB 组成一个链表，多个状态对应多个不同的链表。各状态的进程形成不同的链表：就绪链表，阻塞链表。(一般采用链表，动态插入删除，开销较小) 索引表：同一状态的进程归入一个 index 表(由 index 指向 PCB )，多个状态对应多个不同的 index 表。各状态的进程形成不同的索引表：就绪索引表，阻塞索引表。(如果 PCB 个数比较固定，不会频繁插入删除，使用索引表) 参考链接 https://www.bilibili.com/video/av6538245/?p=2]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统简述]]></title>
    <url>%2F2018%2F10%2F31%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E8%BF%B0-2018-10-31%2F</url>
    <content type="text"><![CDATA[操作系统基本概念 操作系统 (operating system, 缩写 OS)，是指控制和管理整个计算机系统的硬件和软件资源，合理地组织调度计算机的工作和资源的分配的集合，为用户和底层硬件之间的桥梁。对于程序员来说，操作系统是工作场地，是应用程序控制底层硬件接口的提供者。 操作系统启动以 Linux 为例，一开始操作系统是存放在 Disk 上面的，然后再由 BIOS（基本I/O处理系统）检测我们计算机操作系统的各种外设，检测完，如果外设正常，再将一个 bootloader 小程序由 Disk 加载到内存中去，bootloader (512个字节) 负责将操作系统加载到内存，最终操作系统开始正常工作。 操作系统启动后，如何与外设和应用程序交互呢？ 外设是通过中断和I/O来处理的，至于应用程序，是通过系统调用和异常来提供相应功能。中断，异常，系统调用三者就是操作系统同应用程序和底层硬件之间交互手段，三者具体定义如下： 系统调用（来源于应用程序)应用程序主动向操作系统发出服务请求。系统调用会触发”用户态”到”内核态”的一个转换。”用户态”指的是应用程序在运行过程中， cpu 所处的一个特权级状态，权限较低，不能直接访问特殊的机器指令和 I/O ; “内核态”指的是操作系统运行过程中 cpu 所指的一个状态，权限较高，该状态下，操作系统可以执行任何一条指令，包括特权指令，访问 I/O 指令。这种机制使得系统安全性可以得到保证。系统调用付出的代价主要是执行的开销相对普通函数调用较大 (切换堆栈，用户态切换内核态)。Windows 应用 WIN32 APIPOSIX-based systems 应用 POSIX API（包括unix，Linux，mac os x的所有版本） 异常（来源于不良的应用程序）非法指令或者其他坏的处理状态。（如：内存出错） 操作系统需要保存现场，然后处理异常，接着杀死异常程序或重新执行异常程序。 中断（来源于外设）来自不同的硬件设备的计时器和网络中断 。中断向量表中保存有各个外设的中断编号和相应的中断服务例程地址，操作系统收到中断编号，查表，然后转到相应地址执行服务例程，这个时候操作系统需要保存当前处理状态，处理完中断再恢复现场。 操作系统特征 并发 (Concurrence) 并发： 一个时间段内，多个程序在运行。并行：同一个时间点上，多个程序在运行，需要多核cpu来完成。操作系统特征之一就是并发，同时存在多个运行程序，需要通过操作系统来进行调度。 共享 （Sharing) 对于硬件资源，内存资源和相关外设等”同时”访问，共同使用，实际上是互斥共享。 虚拟 （Virtual) 虚拟是指 把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实的，即实际存在的；而后者是虚的，是用户感觉上的事物。用于实现虚拟的技术，称为虚拟技术。在操作系统中利用了多种虚拟技术，分别用来实现虚拟处理器、虚拟内存和虚拟外部设备。 在虚拟处理器技术中，是 通过多道程序设计技术，让多道程序并发执行的方法，来分时使用一个处理器的。此时，虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个中央处理器（CPU) 在专门为它服务。利用多道程序设计技术，把一个物理上的CPU虚拟为多个逻辑上的 CPU，称为虚拟处理器。 类似地，可以通过虚拟存储器技术，将一台机器的物理存储器变为虚拟存储器，以便从逻辑上来扩充存储器的容量。当然,这时用户所感觉到的内存容量是虚的。我们把用户所感觉到的存储器（实际是不存在的）称为虚拟存储器。 还可以通过虚拟设备技术，将一台物理 I/O 设备虚拟为多台逻辑上的I/O设备，并允许每个用户占用一台逻辑上的 I/O 设备，这样便可以 使原来仅允许在一段时间内由一个用户访问的设备（即临界资源)，变为在一段时间内允许多个用户同时访问的共享设备。因此，操作系统的虚拟技术可归纳为：时分复用技术，如处理器的分时共享；空分复用技术，如虚拟存储器 异步 (Asynchronism) 程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知，但只要运行环境相同，操作系统需要保证程序运行结果也相同。异步使得操作系统运行在一种随机的环境下，可能导致进程产生与时间有关的错误 (就像对全局变量的访问顺序不当会导致程序出错一样）。 Linux 系统组成 上图是 Linux 操作系统内核组成图，从中我们可以看到，操作系统主要功能为以下四个，那么后面文章中会一一深入介绍！ 进程管理（Processing management） 内存管理（Memory management） 文件系统（File system） 网络通信（Networking） 参考链接 https://www.bilibili.com/video/av6538245/?p=2https://blog.csdn.net/bigpudding24/article/details/48603301]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于这个博客]]></title>
    <url>%2F2018%2F10%2F27%2F2018-10-29%2F</url>
    <content type="text"><![CDATA[hello 花了两三天时间，搭建了一个自己的博客，在阿里云买了人生中第一个域名 mikeblog.top，基本框架用的是hexo+githubpage，这个网上教程很多，也很详细，我就不介绍详细过程了，在这里十分感谢其他博主的分享，也感谢这两个平台，让我在互联网上有了一个自己的小栖息地，说实话，感觉像有了一个自己的家。第一篇博客，当然是用来解释前世今生，立flag用的，我为什么要弄一个博客呢？这个博客以后是用来干啥的呢？ 博客搭建自己博客的原因大概今年5月份，开始有了持续更新博客的念头，原因主要有两个，不对应该是三个。 原因一一是工作上的原因，工作差不多快两年了，期间接触到的，学习到的东西很多，然后每次想起自己在技术上的积累时，总是这个懂，那个也懂，但是要你很系统的表达出来，却又做不到，显得很凌乱。所以，好记性不如烂笔头，想通过写博客来对自己已掌握的，或者掌握的不牢固的技术点进行总结和提升, 成体系化，并且分享出来，分享也算是一种变相的激励，需要你去对所分享的东西进行 深层次的熟悉和了解，如果能帮助到有缘人，那是极好的。 原因二第二个原因，是想记录下一些关于自己的文字，想要更了解自己，我想应该没有什么是比文字更能描绘一个人的了，记录自己对工作对行业的了解和看法，以及自己三观的演变。 原因三第三个是因为博客园对Markdown的支持实在让我不能忍，还有博客相关的UI界面体验，实在不敢恭维。国内比较出名的技术网站，博客园和CSDN，持续时间久，上面积累的技术博客和资源确实很多，有很多质量也很不错，很多技术大牛都有在上面分享的经历，但是呢，最后都离开了，这肯定是有原因的。 最重要的，当然是 freedom 了，自己的博客没有这么多条条框框，比较自由，可以按照自己的想法来开发集成，加功能，选择自己喜欢的风格，好的开源框架这么多，不用白不用是吧。 博客记录的主要内容我当前干的活，主要是应用软件开发(平台：linux, android), 主要语言C/C++, 脚本语言shell, 主要做逻辑层和基础库这一块，为多个平台提供库和通用API，至于UI框架这一块，接触的比较少，要说接触过的应该就Qt了，但是不深入。后续博客记录的主要内容短期会聚焦在: Linux 系统 ：多进程/多线程, 内存, I/O, 网络 (I/O和网络需加强) C++/C++11/C++17 : STL库分析总结; C++11/17 新增特性分析 编译链接相关： make/cmake, 动态库链接 脚本语言： shell, python git：持续集成 (CI) 当然，因为现在工作上到了迷茫期，正在考虑方向上的事情，所以后面记录的东西也可能会随之改变 ！ 12345678910111213141516171819202122232425/* Add a new node to the list, to head, containing the specified 'value' * pointer as value. * * On error, NULL is returned and no operation is performed (i.e. the * list remains unaltered). * On success the 'list' pointer you pass to the function is returned. */list *listAddNodeHead(list *list, void *value)&#123; listNode *node; if ((node = zmalloc(sizeof(*node))) == NULL) return NULL; node-&gt;value = value; if (list-&gt;len == 0) &#123; list-&gt;head = list-&gt;tail = node; node-&gt;prev = node-&gt;next = NULL; &#125; else &#123; node-&gt;prev = NULL; node-&gt;next = list-&gt;head; list-&gt;head-&gt;prev = node; list-&gt;head = node; &#125; list-&gt;len++; return list;&#125; 测试一下代码显示效果，笑脸。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
