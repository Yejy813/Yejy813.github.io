<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[操作系统--进程管理(二)]]></title>
    <url>%2F2018%2F11%2F03%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%BA%8C-2018-11-3%2F</url>
    <content type="text"><![CDATA[进程状态(State) 操作系统通过维护进程状态队列，来对进程进行管理。 状态队列： 由操作系统来维护一组队列，用来表示系统当中所有进程的当前状态； 不同的状态分别用不同的队列来表示(就绪队列，各种类型的阻塞队列)； 每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生改变时，它的PCB从一个队列中脱离出来，加入到另一个队列。 进程的生命周期管理12345678910111213141516171819202122232425* 进程创建 引起进程创建的三个主要事件： * 系统初始化时;(创建init进程，负责创建其他新的进程) * 用户请求创建一个新进程； * 正在运行的进程执行了创建进程的系统调用；* 进程运行 内核选择一个就绪进程，让它占有处理机并执行（涉及相关调度算法，来满足如何选择进程何时来执行）* 进程等待 在以下情况下，进程等待(阻塞)： 1. 请求并等待系统服务，无法马上完成(例如：执行I/O，请求硬盘时) 2. 启动某种操作，无法马上完成(需要等待其他进程完成某个操作才可以执行) 3. 需要的数据没有到达 进程一旦由运行态转换成等待状态就不占有CPU了，那么其他就绪进程就可以占有CPU执行。进程等待(阻塞)只能由进程自己触发， 因为只有进程自己知道才能知道何时需要等待某种事件的发生。* 进程唤起（由阻塞态转换为就绪态） 唤醒进程的原因： 1. 被阻塞进程的需要的资源得到满足 2. 被阻塞进程等待的事件可达 3. 将该进程的PCB插入到就绪队列 进程只能被别的进程或者操作系统唤醒* 进程结束 进程的状态变化模型 进程的三种基本状态：进程在生命结束前处于且仅处于三种基本状态之一，不同系统设置的进程状态数目不同。 运行状态(Running)：当一个进程正在处理机上运行时。 就绪状态(Ready): 一个进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。 等待状态(又称阻塞状态Blocked)：一个进程正在等待某一事件而暂停运行时。如等待某资源，等待输入/输出完成。 进程的挂起模型 进程在挂起状态时，意味着进程没有占有内存空间，处在挂起状态的进程映像在磁盘上。 挂起状态： 阻塞挂起状态(Blocked-suspend)：进程在外存并等待某事件的出现 就绪挂起状态(Ready-suspend)：进程在外存，但只要进入内存即可运行 进程调度算法 FCFS: first come fist server (先来先服务) 12345优点：简单缺点：* 平均等待时间波动较大* 花费时间少的任务可能排在花费时间长的任务后面* 可能导致I/O和CPU之间的重叠处理 SPN/SRT : 短任务优先 1234567按照预测的完成时间来将任务入队。可以是可抢占的或者不可抢占的，可抢占：又叫shortest-Remaining-Time(SRT) (最短剩余时间)优点：不公平，最优平均等待时间缺点：* 优先考虑短时间进程，可能导致饥饿* 需要预知未来，如何预估进程执行时间长短(根据过去预估未来) HRRRN : 最高响应比优先 (在SPN基础上改进) 1234R = (W + S)/S W ：waiting time 等待时间S ：service time 执行时间选择R值最高的进程，充分考虑了进程等待的时间，缓解饥饿现象，不可抢占 Round Robin 轮循调度算法 123456在叫作时间切片的离散单元中分配处理器，时间片结束时，切换到下一个准备好的进程经验规则：维持上下文切换开销处于1%以内，99%的时间用在实际进程执行中优点：公平缺点：平均等待时间较差 MLFQ 多级反馈队列 1动态的根据进程执行的过程，操作系统可以根据进程具有cpu密集型和I/O密集型的特征来动态的调整进程优先级 Fair-share scheduling 公平共享调度 1使得用户的请求在不同的级别享受公平调度，是在进程级别还是用户级别或者用户组级别公平的共享进程的调度]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统--进程管理(一)]]></title>
    <url>%2F2018%2F11%2F02%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B8%80-2018-11-2%2F</url>
    <content type="text"><![CDATA[缅怀 就在昨天，MVP 的呼声响彻标靶中心球馆，步入不惑的玫瑰，拿下了生涯新高 50 分，曾经的天之骄子，风城玫瑰，NBA 历史上最年轻的常规赛 MVP，经过多年坎途，不曾在病魔面前哭泣，而在昨天却低下了头，落下了泪… 感慨万千，脑海中记着的依然是 09 年那一轮史诗级季后赛，还有那个给芝加哥带来无限希望的玫瑰。此刻，向传奇致敬！加油，罗斯！ 进程定义 一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。 说的直接一点，我们编写代码时，一个 mian() 函数的动态执行过程就是一个进程，当然还包括这个 main() 函数执行过程中使用的资源和数据。 进程的组成一个进程应该包括： 程序的代码； 程序处理的数据； 程序计数器中的值，指示下一条将运行的指令； 一组通用的寄存器的当前值，堆，栈； 一组系统资源(如内存资源，文件系统，网络等一系列资源) 总之，进程包含了正在运行的一个程序的所有状态信息。 进程与程序的关系 程序是产生进程的基础 程序的每次运行构成不同的进程 进程是程序功能的体现 通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包含多个程序。 进程与程序的区别 进程是 动态的，程序是静态的：程序是有序代码的集合；进程是程序的执行，进程有核心态用户态 进程是 暂时的，程序是永久的：进程是一个状态变化的过程，程序可长久保存 进程与程序的组成不同：进程的组成包括程序，数据和进程控制块(即进程状态信息) 进程的特点 动态性：可动态的创建，结束进程； 创建接口 fork(), 结束进程： kill 等。 并发性：进程可以被独立调度并占有处理机运行；多核并行，单核一段时间内并发执行； 独立性：不同进程的工作不相互影响；(正确性不受影响，操作系统内存管理，页表管理使得不同进程访问不同的物理内存，相互之间独立不受影响。越过地址空间会产生缺页异常。保证进程独数据独立性。) 制约性：因访问共享数据/资源或者进程间同步产生制约； 进程控制结构(PCB) 进程控制块：操作系统管理控制进程运行所用的信息集合。操作系统用PCB来描述进程的基本情况以及运行变化过程，PCB是进程存在的唯一标志。 使用进程控制块 进程的创建：为该进程生成一个PCB进程终止：回收它的PCB进程的组织管理：通过对PCB的组织管理来实现 对进程的创建，终止和管理都是通过处理PCB来完成。 PCB包含的三大类信息 进程标识信息。如本进程的标识，本进程的产生者标识(父进程标识)；用户标识。 处理机状态信息保存区。保存进程的运行现场信息： 1. 用户可见寄存器，用户程序可以使用数据，地址等寄存器。 2. 控制和状态寄存器，如程序计数器(PC)，程序状态字(PSW)。 3. 栈指针，过程调用/系统调用/中断处理和返回时需要用到它。 进程控制信息： 1. 调度和状态信息，用于操作系统调度进程并占用处理机使用。 2. 进程间通信信息，为支持进程间与通信相关的各种标识，信号，信件等，这些信息存放在接收方的进程控制块里面。 3. 存储管理信息，包含有指向本进程影像存储空间的数据结构。 4. 进程所用的资源，说明由进程打开，使用的系统资源，如打开的文件等。 5. 有关数据结构连接信息，进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB。 PCB的组织方式 链表： 同一状态的进程其 PCB 组成一个链表，多个状态对应多个不同的链表。各状态的进程形成不同的链表：就绪链表，阻塞链表。(一般采用链表，动态插入删除，开销较小) 索引表：同一状态的进程归入一个 index 表(由 index 指向 PCB )，多个状态对应多个不同的 index 表。各状态的进程形成不同的索引表：就绪索引表，阻塞索引表。(如果 PCB 个数比较固定，不会频繁插入删除，使用索引表) 参考链接 https://www.bilibili.com/video/av6538245/?p=2]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统简述]]></title>
    <url>%2F2018%2F10%2F31%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E8%BF%B0-2018-10-31%2F</url>
    <content type="text"><![CDATA[操作系统基本概念 操作系统 (operating system, 缩写 OS)，是指控制和管理整个计算机系统的硬件和软件资源，合理地组织调度计算机的工作和资源的分配的集合，为用户和底层硬件之间的桥梁。对于程序员来说，操作系统是工作场地，是应用程序控制底层硬件接口的提供者。 操作系统启动以 Linux 为例，一开始操作系统是存放在 Disk 上面的，然后再由 BIOS（基本I/O处理系统）检测我们计算机操作系统的各种外设，检测完，如果外设正常，再将一个 bootloader 小程序由 Disk 加载到内存中去，bootloader (512个字节) 负责将操作系统加载到内存，最终操作系统开始正常工作。 操作系统启动后，如何与外设和应用程序交互呢？ 外设是通过中断和I/O来处理的，至于应用程序，是通过系统调用和异常来提供相应功能。中断，异常，系统调用三者就是操作系统同应用程序和底层硬件之间交互手段，三者具体定义如下： 系统调用（来源于应用程序)应用程序主动向操作系统发出服务请求。系统调用会触发”用户态”到”内核态”的一个转换。”用户态”指的是应用程序在运行过程中， cpu 所处的一个特权级状态，权限较低，不能直接访问特殊的机器指令和 I/O ; “内核态”指的是操作系统运行过程中 cpu 所指的一个状态，权限较高，该状态下，操作系统可以执行任何一条指令，包括特权指令，访问 I/O 指令。这种机制使得系统安全性可以得到保证。系统调用付出的代价主要是执行的开销相对普通函数调用较大 (切换堆栈，用户态切换内核态)。Windows 应用 WIN32 APIPOSIX-based systems 应用 POSIX API（包括unix，Linux，mac os x的所有版本） 异常（来源于不良的应用程序）非法指令或者其他坏的处理状态。（如：内存出错） 操作系统需要保存现场，然后处理异常，接着杀死异常程序或重新执行异常程序。 中断（来源于外设）来自不同的硬件设备的计时器和网络中断 。中断向量表中保存有各个外设的中断编号和相应的中断服务例程地址，操作系统收到中断编号，查表，然后转到相应地址执行服务例程，这个时候操作系统需要保存当前处理状态，处理完中断再恢复现场。 操作系统特征 并发 (Concurrence) 并发： 一个时间段内，多个程序在运行。并行：同一个时间点上，多个程序在运行，需要多核cpu来完成。操作系统特征之一就是并发，同时存在多个运行程序，需要通过操作系统来进行调度。 共享 （Sharing) 对于硬件资源，内存资源和相关外设等”同时”访问，共同使用，实际上是互斥共享。 虚拟 （Virtual) 虚拟是指 把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实的，即实际存在的；而后者是虚的，是用户感觉上的事物。用于实现虚拟的技术，称为虚拟技术。在操作系统中利用了多种虚拟技术，分别用来实现虚拟处理器、虚拟内存和虚拟外部设备。 在虚拟处理器技术中，是 通过多道程序设计技术，让多道程序并发执行的方法，来分时使用一个处理器的。此时，虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个中央处理器（CPU) 在专门为它服务。利用多道程序设计技术，把一个物理上的CPU虚拟为多个逻辑上的 CPU，称为虚拟处理器。 类似地，可以通过虚拟存储器技术，将一台机器的物理存储器变为虚拟存储器，以便从逻辑上来扩充存储器的容量。当然,这时用户所感觉到的内存容量是虚的。我们把用户所感觉到的存储器（实际是不存在的）称为虚拟存储器。 还可以通过虚拟设备技术，将一台物理 I/O 设备虚拟为多台逻辑上的I/O设备，并允许每个用户占用一台逻辑上的 I/O 设备，这样便可以 使原来仅允许在一段时间内由一个用户访问的设备（即临界资源)，变为在一段时间内允许多个用户同时访问的共享设备。因此，操作系统的虚拟技术可归纳为：时分复用技术，如处理器的分时共享；空分复用技术，如虚拟存储器 异步 (Asynchronism) 程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知，但只要运行环境相同，操作系统需要保证程序运行结果也相同。异步使得操作系统运行在一种随机的环境下，可能导致进程产生与时间有关的错误 (就像对全局变量的访问顺序不当会导致程序出错一样）。 Linux 系统组成 上图是 Linux 操作系统内核组成图，从中我们可以看到，操作系统主要功能为以下四个，那么后面文章中会一一深入介绍！ 进程管理（Processing management） 内存管理（Memory management） 文件系统（File system） 网络通信（Networking） 参考链接 https://www.bilibili.com/video/av6538245/?p=2https://blog.csdn.net/bigpudding24/article/details/48603301]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于这个博客]]></title>
    <url>%2F2018%2F10%2F27%2F2018-10-29%2F</url>
    <content type="text"><![CDATA[花了两三天时间，搭建了一个自己的博客，在阿里云买了人生中第一个域名 mikeblog.top，基本框架用的是hexo+githubpage，这个网上教程很多，也很详细，我就不介绍详细过程了，在这里十分感谢其他博主的分享，也感谢这两个平台，让我在互联网上有了一个自己的小栖息地，说实话，感觉像有了一个自己的家。第一篇博客，当然是用来解释前世今生，立flag用的，我为什么要弄一个博客呢？这个博客以后是用来干啥的呢？ 搭建自己博客的原因大概今年5月份，开始有了持续更新博客的念头，原因主要有两个，不对应该是三个。 原因一一是工作上的原因，工作差不多快两年了，期间接触到的，学习到的东西很多，然后每次想起自己在技术上的积累时，总是这个懂，那个也懂，但是要你很系统的表达出来，却又做不到，显得很凌乱。所以，好记性不如烂笔头，想通过写博客来对自己已掌握的，或者掌握的不牢固的技术点进行总结和提升, 成体系化，并且分享出来，分享也算是一种变相的激励，需要你去对所分享的东西进行 深层次的熟悉和了解，如果能帮助到有缘人，那是极好的。 原因二第二个原因，是想记录下一些关于自己的文字，想要更了解自己，我想应该没有什么是比文字更能描绘一个人的了，记录自己对工作对行业的了解和看法，以及自己三观的演变。 原因三第三个是因为博客园对Markdown的支持实在让我不能忍，还有博客相关的UI界面体验，实在不敢恭维。国内比较出名的技术网站，博客园和CSDN，持续时间久，上面积累的技术博客和资源确实很多，有很多质量也很不错，很多技术大牛都有在上面分享的经历，但是呢，最后都离开了，这肯定是有原因的。 最重要的，当然是 freedom 了，自己的博客没有这么多条条框框，比较自由，可以按照自己的想法来开发集成，加功能，选择自己喜欢的风格，好的开源框架这么多，不用白不用是吧。 博客记录的主要内容我当前干的活，主要是应用软件开发(平台：linux, android), 主要语言C/C++, 脚本语言shell, 主要做逻辑层和基础库这一块，为多个平台提供库和通用API，至于UI框架这一块，接触的比较少，要说接触过的应该就Qt了，但是不深入。后续博客记录的主要内容短期会聚焦在: Linux 系统 ：多进程/多线程, 内存, I/O, 网络 (I/O和网络需加强) C++/C++11/C++17 : STL库分析总结; C++11/17 新增特性分析 编译链接相关： make/cmake, 动态库链接 脚本语言： shell, python git：持续集成 (CI) 当然，因为现在工作上到了迷茫期，正在考虑方向上的事情，所以后面记录的东西也可能会随之改变 ！ 12345678910111213141516171819202122232425/* Add a new node to the list, to head, containing the specified 'value' * pointer as value. * * On error, NULL is returned and no operation is performed (i.e. the * list remains unaltered). * On success the 'list' pointer you pass to the function is returned. */list *listAddNodeHead(list *list, void *value)&#123; listNode *node; if ((node = zmalloc(sizeof(*node))) == NULL) return NULL; node-&gt;value = value; if (list-&gt;len == 0) &#123; list-&gt;head = list-&gt;tail = node; node-&gt;prev = node-&gt;next = NULL; &#125; else &#123; node-&gt;prev = NULL; node-&gt;next = list-&gt;head; list-&gt;head-&gt;prev = node; list-&gt;head = node; &#125; list-&gt;len++; return list;&#125; 测试一下代码显示效果，笑脸。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
