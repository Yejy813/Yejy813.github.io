<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用 protobuf 进行数据序列化]]></title>
    <url>%2F2020%2F04%2F25%2F%E4%BD%BF%E7%94%A8-protobuf-%E8%BF%9B%E8%A1%8C%E7%BB%93%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[protobuf 介绍protocol buffers 是Google出品的一种语言无关、平台无关、可扩展的序列化结构数据的方法，主要用于网络数据通信、数据存储等，相对于 xml、json 等结构化数据，它更小，更快，更简单。 protobuf 优点： 语言无关，平台无关，提供了各语言各平台的 protobuf 编译器，可以将写的 .proto 配置文件编译成对应语言的源代码 高效。相比 xml，json，占用空间更小，解析速度更快，表达方式更简单 可灵活扩展, 写好的 .proto 配置文件，后续进行数据扩展时，不会影响旧的源码程序 protobuf 缺点 相对于 xml 和 json，可读性、可理解度上差一些，因为毕竟和程序联系比较紧密，需要进行转化和配置，对于软件工程师来说，这不算缺点。 protobuf 相关资料：如果需要查看官方文档，可以参考 Google 开发者中心和 github 上开源项目。 开发者中心 https://developers.google.cn/protocol-buffers github https://github.com/protocolbuffers/protobuf protobuf 编译器安装官方安装步骤：https://github.com/protocolbuffers/protobuf/blob/master/src/README.md， 按照这个来走一遍就可以了，我安装的是 Linux 系统 protobuf 库，其他系统的上面也有。 C++ 代码测试我们先写一个 .proto 配置文件 protobuf_test.proto:12345678910111213141516171819202122syntax = &quot;proto3&quot;;package tutorial;message Person &#123; string name = 1; int32 id = 2; string email = 3; enum PhoneType &#123; MOBILE = 0; HOME = 1; WORK = 2; &#125; message PhoneNumber &#123; string number = 1; PhoneType type = 2 [default = HOME]; &#125; PhoneNumber phones = 4;&#125; 编译过程中我们使用如下指令，将该文件转换成 C++ 源码, 如果是 cmake，可以使用ADD_CUSTOM_COMMAND写一个自定义指令。 protoc -I=$SRC_DIR –cpp_out=$DST_DIR $SRC_DIR/addressbook.proto 在配置文件目录执行： protoc -I=./ –cpp_out=./ ./protobuf_test.proto 最终生成了 protobuf_test.pb.cc 和 protobuf_test.pb.h文件，主要代码如下：1234567891011121314enum : int &#123; kNumberFieldNumber = 1, kTypeFieldNumber = 2,&#125;;// string number = 1;void clear_number();const std::string&amp; number() const;void set_number(const std::string&amp; value);void set_number(std::string&amp;&amp; value);void set_number(const char* value);void set_number(const char* value, size_t size);std::string* mutable_number();std::string* release_number();void set_allocated_number(std::string* number); 对于 message 每个成员都有一个 set 和 get 接口来设置和获取值。 我们写个测试程序来试用一下，看官方的文档，有几个可选的序列化接口需要注意，这个是将 protobuf 结构化数据转换成我们代码中常见的字符串和输入输出流：1234bool SerializeToString(string* output) const; //serializes the message and stores the bytes in the given string. Note that the bytes are binary, not text; we only use the string class as a convenient container.bool ParseFromString(const string&amp; data); //parses a message from the given string.bool SerializeToOstream(ostream* output) const; //writes the message to the given C++ ostream.bool ParseFromIstream(istream* input); //parses a message from the given C++ istream. 测试代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142#include "protobuf_test.pb.h"#include &lt;iostream&gt;#include &lt;fstream&gt;int main()&#123; tutorial::Person ps; ps.set_name("mike"); // name ps.set_email("xxxxxx@qq.com"); // email ps.set_id(666); // id // set phome number tutorial::Person_PhoneNumber* person_num = new tutorial::Person_PhoneNumber(); person_num-&gt;set_number("12345678910"); person_num-&gt;set_type(tutorial::Person_PhoneType::Person_PhoneType_HOME); ps.set_allocated_phones(person_num); std::string strFile = "person.txt"; std::fstream output(strFile, std::ios::out | std::ios::trunc | std::ios::binary); if (!ps.SerializeToOstream(&amp;output)) &#123; std::cerr &lt;&lt; "Failed to write address book." &lt;&lt; std::endl; return -1; &#125; output.close(); // Serialize from file tutorial::Person ps_from; std::fstream input(strFile, std::ios::in | std::ios::binary); if (!ps_from.ParseFromIstream(&amp;input)) &#123; std::cerr &lt;&lt; "Failed to parse address book." &lt;&lt; std::endl; return -1; &#125; std::cout &lt;&lt; "parse from input stream. name: " &lt;&lt; ps_from.name() &lt;&lt; " email: " &lt;&lt; ps_from.email() &lt;&lt; " phone numb: " &lt;&lt; ps_from.phones().number() &lt;&lt; std::endl; input.close(); return 0;&#125; 打印结果：12bash-4.2$ ./protobuf_testparse from input stream. name: mike email: xxxxxx@qq.com phone numb: 12345678910 上面程序很简单，我们先创建一个 person 的数据结构，然后序列化到输出流保存到文件中，然后我们再创建一个 person 的结构对之前生成的文件进行反序列化，可以正常得到原来的内容。 需要注意的是，代码除了需要依赖 libprotobuf.so 外，还要记得依赖 pthread 库，要不然运行时会报错。 总结思考一下，相对 xml 和 json，protobuf 除了上面列的那些优点外，在代码部署层面其实没有很大的差异，xml 和 json 需要依赖各自开源库来实现序列化操作，之前用的比较多的，json 是 rapidjson库，xml 是 pugixml 库，而protobuf 只是多了安装编译程序，生成对应语言代码这一流程。因此，在开发过程中，如果遇到对性能要求比较高的场景（如高性能服务器相关的RPC等），还是十分推荐使用 protobuf 做为数据序列化工具的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[好久不见]]></title>
    <url>%2F2020%2F04%2F19%2Flong-time-no-see%2F</url>
    <content type="text"><![CDATA[生活还在继续,它不会因为我们伤心了、后悔了、绝望了就停下脚步 –2020 好久不见，真的是好久不见，2020 魔幻开年，短短四个月不到，给人感觉却是邈如旷世。 全球新冠肆虐、科比意外过世、美股四次熔断，大 A 却顶住了压力，2020 势必会被人铭记，希望疫情早日结束，2020 能够低开高走。 我从厦门来到了杭州，上班一周，感觉还行，后面马上就会有新东西继续分享了。到杭州的第一个周末，领导和曹哥特地从上海跑来杭州看我，说要过来给我做做思想工作，怕我一个人在这边受不了，我吐，明明是过来玩的好吧。周六一整天就没停过，杭州博物馆，西湖，一直走一直走，不停的走，过程中仿佛有说不完的话，聊工作，聊生活，聊见闻，聊规划，聊行业，给人感觉一下回到了 2017 年国庆一起去舟山时的情景，也是如此，还是很开心的，离得近就是好，以后见面的机会就多了，也是巧，现在一个做 android 开发，一个做 ios 开发，一个做后端开发，分工相当明确。 杭州的景色让人安心，让人平静，走在其中，莫名的就让你把烦恼抛却脑后，如果三两好友一同，体验更好。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文本分析和格式化脚本-Awk]]></title>
    <url>%2F2019%2F04%2F03%2F%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%84%9A%E6%9C%AC-awk%2F</url>
    <content type="text"><![CDATA[Awk 简介 有时候，我们需要非常强有力的工具，来控制和处理我们的数据文件，达到对文件进行分析、统计、格式化输出的效果，没错，Awk 就是这样一款工具。 awk 命令或 GNU awk 提供了用于处理文本的脚本语言。使用 awk 脚本语言，您可以进行以下操作： 定义变量。使用字符串和算术运算符。使用控制流和循环。生成格式化报告。 当然，我们可以使用 awk 处理包含数百万行的日志文件，以输出可以从中受益的可读报告，除此之外，在Linux下，当你想要对文本进行其他非常细致的处理，awk基本都可以很好的胜任，特别是当它与sed grep 配合起来，可以对文件进行全方位的分析处理。 官方手册: https://www.gnu.org/software/gawk/manual/html_node/index.html#SEC_Contents Awk Options (选项参数)awk 命令使用如下：1$ awk options program file 我们可以携带以下选择参数：12345-F fs To specify a file separator. 分隔符-f file To specify a file that contains awk script. 脚本文件-v var=value To declare a variable. 变量 我们接下来将看到如何使用 awk处理文件和打印结果。 Read Awk Scripts (脚本读取)我们要定义一个 awk 脚本，我们需要使用单引号括起来的大括号，如下所示：1echo 'this is a test' | awk '&#123;print $3&#125;' # 打印 a 使用echo输出一句话，然后通过 | 管道执行 awk 指令，打印出第三个字段（Fileds）。 Using Variables (变量)使用 awk，您可以处理文本文件。 Awk 为找到的每个数据字段分配一些变量： $0 for the whole line. $1 for the first field. $2 for the second field. $n for the nth field. 像空格或制表符这样的空白字符是awk中字段之间的默认分隔符。 我们看下这个示例，看下awk如何处理它：123456789101112[root@yejy myshare]# cat myfile This is a test.This is the second test.This is the thrid test.This is the fourth test.[root@yejy myshare]# [root@yejy myshare]# awk '&#123;print $1&#125;' myfile ThisThisThisThis[root@yejy myshare]# 上面这个示例会打印出每一行的第一个字段（filed）。 有时某些文件中的分隔符不是空格，也不是制表符，而是其他内容。 您可以使用-F选项指定它：1234567891011121314151617181920[root@yejy myshare]# awk -F : &apos;&#123;print $1&#125;&apos; /etc/passwdrootbindaemonadmlpsyncshutdownhaltmailoperatorgamesftpnobodysystemd-bus-proxysystemd-networkdbuspolkitdabrtunbound 这个命令打印 passwd 文件中的第一个字段。 我们使用冒号作为分隔符，因为 passwd 文件使用了它。 Using Multiple Commands (多命令)要运行多个命令，请使用分号分隔它们，如下所示：12-bash-4.2$ echo "hello yejy" | awk '&#123;$2="daianqi"; print $0&#125;'hello daianqi 第一个命令使$2字段等于yejy，第二个命令打印整行。 Reading The Script From a File (文件中读取 awk 脚本)我们可以在文件中写入 awk 脚本，并使用 -f 选项指定该文件执行。1234567891011121314-bash-4.2$ cat testfile &#123; print $1 " home at " $6&#125;-bash-4.2$ awk -F: -f testfile /etc/passwd root home at /rootbin home at /bindaemon home at /sbinadm home at /var/admlp home at /var/spool/lpdsync home at /sbinshutdown home at /sbinhalt home at /sbinmail home at /var/spool/mail 这里我们从 /etc/passwd 打印用户名和他的主路径，当然分隔符是用冒号 -F。 你也可以像这样写 awk 脚本文件：1234&#123; text = $1 " home at " $6 print text &#125; Awk Preprocessing (预处理)如果您需要为结果创建标题, 您可以使用 BEGIN 关键字来实现此目的, 它在处理数据之前运行：123456-bash-4.2$ awk 'BEGIN&#123;print "Report Title"&#125;&#123;print $0&#125;' myfileReport TitleThis is a test.This is the second test.This is the thrid test.This is the fourth test. Awk Postprocessing (后期处理)要在处理数据后运行脚本，请使用END关键字：12345678-bash-4.2$ awk 'BEGIN&#123;print "Report Title"&#125; &#123;print $0&#125; END&#123;print "file footer"&#125;' myfile Report TitleThis is a test.This is the second test.This is the thrid test.This is the fourth test.file footer-bash-4.2$ 这个很有用，我们可以用这个来添加页脚。我们把这些集合在一起，写到一个脚本文件里面：1234567891011121314BEGIN&#123;print "Users and thier corresponding home"print " UserName \t HomePath"print "___________ \t __________"FS=":"&#125;&#123;print $1 " \t " $6&#125;END&#123;print "the end"&#125; 首先，使用 BEGIN 关键字创建顶部。 然后我们定义FS并在末尾打印页脚。 12345678910111213141516-bash-4.2$ awk -f testfile /etc/passwdUsers and thier corresponding home UserName HomePath___________ __________root /rootbin /bindaemon /sbinadm /var/admlp /var/spool/lpdsync /sbinshutdown /sbinhalt /sbinmail /var/spool/mailoperator /rootgames /usr/gamesftp /var/ftp Built-in Variables (内建变量)我们看到数据字段变量 $1，$2，$3 等用于提取数据字段，我们还处理字段分隔符 FS。awk的内建变量其实还有很多。下面列举一些比较常见的： FIELDWIDTHS &emsp;&emsp; Specifies the field width. RS &emsp;&emsp;&emsp;&emsp;&emsp;&emsp; Specifies the record separator. FS &emsp;&emsp;&emsp;&emsp; Specifies the field separator. OFS &emsp;&emsp; Specifies the Output separator. ORS &emsp;&emsp; Specifies the Output separator. 默认情况下，OFS变量是空格，您可以设置 OFS 变量以指定所需的分隔符：12345678910111213141516-bash-4.2$ awk &apos;BEGIN&#123;FS=&quot;:&quot;; OFS=&quot;-&quot;&#125; &#123;print $1,$6,$7&#125;&apos; /etc/passwdroot-/root-/bin/bashbin-/bin-/sbin/nologindaemon-/sbin-/sbin/nologinadm-/var/adm-/sbin/nologinlp-/var/spool/lpd-/sbin/nologinsync-/sbin-/bin/syncshutdown-/sbin-/sbin/shutdownhalt-/sbin-/sbin/haltmail-/var/spool/mail-/sbin/nologinoperator-/root-/sbin/nologingames-/usr/games-/sbin/nologinftp-/var/ftp-/sbin/nologinnobody-/-/sbin/nologinsystemd-bus-proxy-/-/sbin/nologinsystemd-network-/-/sbin/nologin 有时，字段是在没有固定分隔符的情况下分发的。 在这些情况下，FIELDWIDTHS变量解决了这个问题。假如我们有这样一个文件：1234-bash-4.2$ cat myfile 1235.96521 927-8.365236257.8157 看下处理结果：1234-bash-4.2$ awk &apos;BEGIN&#123;FIELDWIDTHS=&quot;3 4 3&quot;&#125; &#123;print $1,$2,$3&#125;&apos; myfile 123 5.96 521927 -8.3 652362 57.8 157 看看输出，输出字段为每行3个，每个字段长度基于FIELDWIDTH指定的内容。 假设您的数据分布在不同的行上，如下所示：123456789-bash-4.2$ cat myfile person Name 123 High Street(222) 466-1234 Another person487 High Street(523) 643-8754 在上面的示例中，awk无法正确处理字段，因为字段是换行符而不是空格分隔。您需要将FS设置为换行符（\n）并将RS设置为空白文本，因此空行将被视为分隔符。123-bash-4.2$ awk 'BEGIN&#123;FS="\n";RS=""&#125; &#123;print $1,$3&#125;' myfile person Name (222) 466-1234Another person (523) 643-8754 是不是很棒，我们可以正确阅读记录(record)和字段(filed)。 More Variables (更多变量)还有一些其他变量可以帮助我们获取更多信息：123456789101112131415ARGC Retrieves the number of passed parameters.ARGV Retrieves the command line parameters.ENVIRON Array of the shell environment variables and corresponding values.FILENAME The file name that is processed by awk.NF Fields count of the line being processed.NR Retrieves total count of processed records.FNR The record which is processed.IGNORECASE To ignore the character case. 看下这条指令：12-bash-4.2$ awk 'BEGIN&#123;print ARGC,ARGV[1]&#125;' myfile2 myfile 其实很好理解，每个进程执行的时候，都会带参数，和C语言的main函数带的参数是一致的。ARGC 参数个数，ARGV 二阶字符数组，打印具体参数。 ENVIRON变量检索shell环境变量，如下所示：12-bash-4.2$ awk 'BEGIN&#123;print ENVIRON["PATH"]&#125;'/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin 我们可以使用没有ENVIRON变量的bash变量，如下所示：12-bash-4.2$ echo | awk -v home=$HOME &apos;&#123;print &quot;my home is &quot; home&#125;&apos;my home is /home/willy NF变量指定记录中的最后一个字段，但不知道其位置：12345678910111213141516-bash-4.2$ awk &apos;BEGIN&#123;FS=&quot;:&quot;; OFS=&quot;-&quot;&#125;&#123;print $1,$(NF-1)&#125;&apos; /etc/passwdroot-/rootbin-/bindaemon-/sbinadm-/var/admlp-/var/spool/lpdsync-/sbinshutdown-/sbinhalt-/sbinmail-/var/spool/mailoperator-/rootgames-/usr/gamesftp-/var/ftpnobody-/systemd-bus-proxy-/systemd-network-/ 让我们看看这个例子来了解 FNR 和 NR 变量之间的区别：12345678910111213-bash-4.2$ awk &apos;BEGIN&#123;FS=&quot;,&quot;&#125;&#123;print $1 &quot;FNR = &quot; FNR &quot; NR = &quot; NR&#125;&apos; myfile myfile person Name FNR = 1 NR = 1123 High StreetFNR = 2 NR = 2(222) 466-1234FNR = 3 NR = 3Another personFNR = 4 NR = 4487 High StreetFNR = 5 NR = 5(523) 643-8754FNR = 6 NR = 6person Name FNR = 1 NR = 7123 High StreetFNR = 2 NR = 8(222) 466-1234FNR = 3 NR = 9Another personFNR = 4 NR = 10487 High StreetFNR = 5 NR = 11(523) 643-8754FNR = 6 NR = 12 在此示例中，awk命令定义了两个输入文件, 相同的文件，但处理了两次, 输出是第一个字段值和FNR和NR变量。很容易可以看出，NR是当前正在处理的record的总序列数，FNR则在到达第二个文件时，FNR变量会变成1，NR不会。 User Defined Variables（自己定义的变量）变量名可以是任何名称，但它不能以数字开头。和shell脚本基本一致，如下所示：12-bash-4.2$ awk &apos;BEGIN&#123;test=&quot;this is a test&quot;; print test&#125;&apos;this is a test Structured Commands（类 C 语言）awk 脚本语言支持 if 条件语句、While、for循环（其中也支持break），以及格式化输出printf，和C语言基本一致，这个就不详细介绍了，注意换行就行，避免出现格式错误。 myfile包含以下内容：1234567891011121314-bash-4.2$ cat myfile 101563345-bash-4.2$ awk &apos;&#123;if($1 &gt; 30)&#123;print $1&#125;&#125;&apos; myfile 3345 如果要加入其它分支，可以这样：12345678910-bash-4.2$ awk &apos;&#123;if($1 &gt; 30)&#123;print $1&#125;else&#123;x = $1 / 2; print x&#125;&#125;&apos; myfile 507.503033045 写法不太美观，如果在文件中写，需要分行。 比如：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 格式化输出awk &apos;BEGIN&#123; x = 100 * 100 printf &quot;The result is: %e\n&quot;, x &#125;&apos;// while 循环awk &apos;&#123; tot = 0 i = 1 while (i &lt; 5) &#123; tot += $i if (i == 3) break i++ &#125; average = tot / 3 print &quot;Average is:&quot;,average &#125; myfile// for循环awk &apos;&#123; total = 0 for (var = 1; var &lt; 5; var++) &#123; total += $var &#125; avg = total / 3 print &quot;Average:&quot;,avg &#125;&apos; myfile Built-In Functions （内建函数）这个内建函数需要我们自己去了解熟悉，awk 为我们提供了数学计算，字符串处理等，如果想深入了解，可以查看官方手册。除了内建函数，我们也可以自定义函数，方式和shell一致。 比较常用的如下：12345数学：sin(x) | cos(x) | sqrt(x) | exp(x) | log(x) | rand()字符串：length() | substr() | sprintf() | match() | tolower() | toupper() 总结总的来说，awk 是一种非常人性化的语言，吸收了C语言的结构控制、格式化输出等特性，很多时候写着写着会感觉是在写C语言，然后又兼具脚本语言的特性（临时解析执行，命名方便、快速开发等），功能也较全面，如果你是在Linux 下从事开发工作，建议你一定要学习一些 awk知识。]]></content>
      <tags>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典排序算法]]></title>
    <url>%2F2019%2F03%2F31%2F%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[经典排序算法 上图是经典排序算法的效率图，大致敲了一遍，堆排序、希尔排序、归并排序，思想真的很巧妙，关键还是看思路。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301#ifndef __SORT_H__#define __SORT_H__#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/** * @file sort.h * * This is an sort algorithm header file, implement 10 main sorting algorithm * * Created by yejy on 2019-03-22 22:02:04 * Copyright (c) yejy. all rights reserved * */class CSoultion&#123;public: /** * @brief 冒泡排序 * * @author yejy * @data 2019-03-22 * * @性能：(交换排序; 时间平均:N^2 , 最坏:N^2 , 最好:N; 空间1; 稳定) * */ void BubbleSort(vector&lt;int&gt; &amp;vec) &#123; int iSize = vec.size(); bool flag = true; for (int i = 0; i &lt; iSize - 1; i++) &#123; for (int j = 0; j &lt; iSize - i - 1; j++) &#123; if (vec[j] &gt; vec[j + 1]) &#123; swap(vec[j], vec[j + 1]); flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125; &#125; /** * @brief 选择排序 * * @author yejy * @data 2019-03-22 * * @性能：(选择排序;时间平均:N^2 , 最坏:N^2 , 最好:N^2 ; 空间1; 稳定) * */ void SelectionSort(vector&lt;int&gt; &amp;vec) &#123; int iSize = vec.size(); for (int i = 0; i &lt; iSize - 1; i++) &#123; for (int j = i + 1; j &lt; iSize; j++) &#123; if (vec[j] &lt; vec[i]) &#123; swap(vec[j], vec[i]); &#125; &#125; &#125; &#125; /** * @brief 快速排序 * * @author yejy * @data 2019-03-22 * * @性能：(交换排序;时间平均:NlogN, 最坏:N^2 , 最好:NlogN ; 空间logN; 不稳定) * */ void QuickSort(vector&lt;int&gt; &amp;vec, int iLow, int iHigh) &#123; if (iLow &gt;= iHigh) &#123; return; &#125; int i = iLow; int j = iHigh; int key = vec[iLow]; // 第一个值作为基准 while (i &lt; j) &#123; while (vec[j] &gt;= key &amp;&amp; i &lt; j) &#123; j--; &#125; if (i &lt; j) &#123; swap(vec[i], vec[j]); &#125; while (vec[i] &lt;= key &amp;&amp; i &lt; j) &#123; i++; &#125; if (i &lt; j) &#123; swap(vec[i], vec[j]); &#125; &#125; QuickSort(vec, iLow, i - 1); QuickSort(vec, i + 1, iHigh); &#125; /** * @brief 插入排序 * * @author yejy * @data 2019-03-22 * * @性能：(插入排序;时间A:N^2 , B:N^2 , E:N;空间1;稳定) * */ void InsertionSort(vector&lt;int&gt; &amp;vec) &#123; int iSize = vec.size(); int iPreIndex; // 前面 index int iCurr; // 当前值 for (int i = 0; i &lt; vec.size() - 1; i++) &#123; iCurr = vec[i + 1]; iPreIndex = i; while (iPreIndex &gt;= 0 &amp;&amp; vec[iPreIndex] &gt; iCurr) &#123; vec[iPreIndex + 1] = vec[iPreIndex]; iPreIndex--; &#125; vec[iPreIndex + 1] = iCurr; &#125; &#125; /** * @brief 希尔排序 * * @author yejy * @data 2019-03-22 * * @性能：(希尔排序;时间A:N 1.3次方 , B:N^2 , E:N;空间1;不稳定) * */ void ShellSort(vector&lt;int&gt; &amp;vec) &#123; int iSize = vec.size(); int iPreIndex; int iCurr; // 先做宽间隔排序，使得序列大致有序，最后再做插入排序 for (int iGap = iSize / 2; iGap &gt; 0; iGap = iGap / 2) &#123; for (int i = 0; i &lt; iSize - iGap; i += iGap) &#123; iCurr = vec[i + iGap]; iPreIndex = i; while (iPreIndex &gt;= 0 &amp;&amp; vec[iPreIndex] &gt; iCurr) &#123; vec[iPreIndex + iGap] = vec[iPreIndex]; iPreIndex -= iGap; &#125; vec[iPreIndex + iGap] = iCurr; &#125; &#125; &#125; /** * @brief 归并排序 * * @author yejy * @data 2019-03-22 * * @性能：(归并排序;时间A:NlogN , B:NlogN , E:NlogN;空间N;稳定) * */ void MergeSort(vector&lt;int&gt; &amp;vec, vector&lt;int&gt; &amp;vecTemp, int iLow, int iHigh) &#123; if (iLow &gt;= iHigh) &#123; return; &#125; int iMid = (iLow + iHigh) / 2; MergeSort(vec, vecTemp, iLow, iMid); MergeSort(vec, vecTemp, iMid + 1, iHigh); Merge(vec, vecTemp, iLow, iMid, iHigh); &#125; void Merge(vector&lt;int&gt; &amp;vec, vector&lt;int&gt; &amp;vecTemp, int iLow, int iMid, int iHigh) &#123; int iLeft = iLow; // 左序列 int iRight = iMid + 1; // 右序列 int t = 0; // 临时数组下标 while (iLeft &lt;= iMid &amp;&amp; iRight &lt;= iHigh) &#123; if (vec[iLeft] &lt;= vec[iRight]) &#123; vecTemp[t++] = vec[iLeft++]; &#125; else &#123; vecTemp[t++] = vec[iRight++]; &#125; &#125; while (iLeft &lt;= iMid) &#123; vecTemp[t++] = vec[iLeft++]; &#125; while (iRight &lt;= iHigh) &#123; vecTemp[t++] = vec[iRight++]; &#125; t = 0; while (iLow &lt;= iHigh) &#123; vec[iLow++] = vecTemp[t++]; &#125; &#125; /** * @brief 堆排序 * * @author yejy * @data 2019-03-22 * * @性能：(堆排序;时间A:NlogN , B:NlogN , E:NlogN;空间1;不稳定) */ void HeapSort(vector&lt;int&gt; &amp;vec) &#123; // 构造大顶堆 BuildMaxHeap(vec); for (int i = vec.size() - 1; i &gt; 0; i--) &#123; swap(vec[0], vec[i]); // 将最大值替换至末尾 AdjustHeap(vec, 0, i); // 调整大顶堆 &#125; &#125; void BuildMaxHeap(vector&lt;int&gt; &amp;vec) &#123; for (int i = vec.size() / 2 - 1; i &gt;= 0; i--) &#123; AdjustHeap(vec, i, vec.size()); &#125; &#125; void AdjustHeap(vector&lt;int&gt; &amp;vec, int i, int iLength) &#123; int iLeft = 2 * i + 1; int iRight = 2 * i + 2; int iLargest = i; if (iLeft &lt; iLength &amp;&amp; vec[iLeft] &gt; vec[iLargest]) &#123; iLargest = iLeft; &#125; if (iRight &lt; iLength &amp;&amp; vec[iRight] &gt; vec[iLargest]) &#123; iLargest = iRight; &#125; if (iLargest != i) &#123; swap(vec[iLargest], vec[i]); AdjustHeap(vec, iLargest, iLength); &#125; &#125;&#125;;#endif 测试代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "sort.h"#include &lt;iostream&gt;int main()&#123; CSoultion soultion; vector&lt;int&gt; vec; cout &lt;&lt; "please input you need sort num: " &lt;&lt; endl; int i; while (1) &#123; cin &gt;&gt; i; if (i == 0) &#123; break; &#125; vec.push_back(i); &#125; cout &lt;&lt; "bubble sort begin: " &lt;&lt; endl; vector&lt;int&gt; vecTemp = vec; soultion.BubbleSort(vecTemp); auto function = [&amp;]() &#123; for(auto elem : vecTemp)&#123; cout &lt;&lt; " " &lt;&lt; elem;&#125; &#125;; // 使用 lambda 引用捕获打印 function(); cout &lt;&lt; endl; cout &lt;&lt; "selection sort begin: " &lt;&lt; endl; vecTemp.clear(); vecTemp = vec; soultion.SelectionSort(vecTemp); function(); cout &lt;&lt; endl; cout &lt;&lt; "quick sort begin: " &lt;&lt; endl; vecTemp.clear(); vecTemp = vec; soultion.QuickSort(vecTemp, 0, vecTemp.size() - 1); function(); cout &lt;&lt; endl; cout &lt;&lt; "insert sort begin: " &lt;&lt; endl; vecTemp.clear(); vecTemp = vec; soultion.InsertionSort(vecTemp); function(); cout &lt;&lt; endl; cout &lt;&lt; "shell sort begin: " &lt;&lt; endl; vecTemp.clear(); vecTemp = vec; soultion.ShellSort(vecTemp); function(); cout &lt;&lt; endl; cout &lt;&lt; "merge sort begin: " &lt;&lt; endl; vecTemp.clear(); vecTemp = vec; vector&lt;int&gt; vecContain = vec; vecContain.clear(); soultion.MergeSort(vecTemp, vecContain, 0, vecTemp.size() - 1); function(); cout &lt;&lt; endl; cout &lt;&lt; "heap sort begin: " &lt;&lt; endl; vecTemp.clear(); vecTemp = vec; soultion.HeapSort(vecTemp); function(); cout &lt;&lt; endl; return 0;&#125; 手动随机输入一组数字，过一遍用例，打印结果如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344-bash-4.2$ valgrind ./a.out ==4743== Memcheck, a memory error detector==4743== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.==4743== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info==4743== Command: ./a.out==4743== please input you need sort num: 774455991126378899110bubble sort begin: 2 3 6 7 11 11 44 55 77 88 99 99selection sort begin: 2 3 6 7 11 11 44 55 77 88 99 99quick sort begin: 2 3 6 7 11 11 44 55 77 88 99 99insert sort begin: 2 3 6 7 11 11 44 55 77 88 99 99shell sort begin: 2 3 6 7 11 11 44 55 77 88 99 99merge sort begin: 2 3 6 7 11 11 44 55 77 88 99 99heap sort begin: 2 3 6 7 11 11 44 55 77 88 99 99==4743== ==4743== HEAP SUMMARY:==4743== in use at exit: 0 bytes in 0 blocks==4743== total heap usage: 7 allocs, 7 frees, 220 bytes allocated==4743== ==4743== All heap blocks were freed -- no leaks are possible==4743== ==4743== For counts of detected and suppressed errors, rerun with: -v==4743== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)-bash-4.2$]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2F2019%2F03%2F15%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[近况 最近实在太忙了，上周末还加了两天班，这两天利用晚上下班时间(并不是正常下班, 你懂的)，把二叉树相关的算法大概敲了一遍，找找感觉。 代码直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375#ifndef __TREE_H__#define __TREE_H__#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;limits.h&gt;using namespace std;// Definition for a binary tree node.class TreeNode&#123;public: TreeNode(int val) : value(val), left(nullptr), right(nullptr) &#123;&#125;public: int value; TreeNode *left; TreeNode *right;&#125;;class Solution&#123;public: using link_type = TreeNode *; // create void CreateTree(link_type&amp; T) &#123; int i; cin &gt;&gt; i; if (i == 0) &#123; T = nullptr; &#125; else &#123; T = new TreeNode(i); CreateTree(T-&gt;left); CreateTree(T-&gt;right); &#125; &#125; // Destory Tree void DestoryTree(link_type T)&#123; if(T == nullptr)&#123; return ; &#125; DestoryTree(T-&gt;left); DestoryTree(T-&gt;right); delete T; T = nullptr; &#125; // 非递归前序遍历 void preTraverseNoRec(link_type T)&#123; if(T == nullptr)&#123; return ; &#125; stack&lt;link_type&gt; stack; link_type curr = T; while(curr || !stack.empty())&#123; while(curr)&#123; cout &lt;&lt; " " &lt;&lt; curr-&gt;value; // 输出 stack.push(curr); curr = curr-&gt;left; &#125; curr = stack.top(); stack.pop(); curr = curr-&gt;right; &#125; &#125; // 前序遍历 void preTraverse(link_type T) &#123; if (T == nullptr) &#123; return; &#125; cout &lt;&lt; " " &lt;&lt; T-&gt;value; preTraverse(T-&gt;left); preTraverse(T-&gt;right); &#125; // 非递归中序遍历 void midTraverseNoRec(link_type T)&#123; if(T == nullptr)&#123; return; &#125; stack&lt;link_type&gt; stack; // 使用栈保存 link_type curr = T; // 当前节点 while(curr || !stack.empty())&#123; // 先遍历左子树入栈 while(curr)&#123; stack.push(curr); curr = curr-&gt;left; &#125; curr = stack.top(); stack.pop(); cout &lt;&lt;" " &lt;&lt; curr-&gt;value; curr = curr-&gt;right; // 使右节点变为左节点 &#125; &#125; // 中序遍历 void midTraverse(link_type T) &#123; if (T == nullptr) &#123; return; &#125; midTraverse(T-&gt;left); cout &lt;&lt; " " &lt;&lt; T-&gt;value; midTraverse(T-&gt;right); &#125; // 非递归后续遍历 void postTraverseNoRec(link_type T)&#123; if(T == nullptr)&#123; return; &#125; stack&lt;link_type&gt; stack; link_type curr = T; link_type last = nullptr; // 保存右节点标志 while(curr || !stack.empty())&#123; while(curr)&#123; stack.push(curr); curr = curr-&gt;left; &#125; curr = stack.top(); if(curr-&gt;right == nullptr || curr-&gt;right == last)&#123; cout &lt;&lt; " " &lt;&lt; curr-&gt;value; // 打印元素 stack.pop(); // 记录上一个访问节点 // 用于判断"访问根节点前，右子树是否访问过" last = curr; curr = nullptr; &#125; else&#123; curr = curr-&gt;right; // 右节点当做左节点处理 &#125; &#125; &#125; // 后续遍历 void postTraverse(link_type T) &#123; if (T == nullptr) &#123; return; &#125; postTraverse(T-&gt;left); postTraverse(T-&gt;right); cout &lt;&lt; " " &lt;&lt; T-&gt;value; &#125; // 层次遍历 void levelTraverse(link_type T)&#123; if(T == nullptr)&#123; return ; &#125; queue&lt;link_type&gt; queue; queue.push(T); link_type curr = nullptr; while(!queue.empty())&#123; curr = queue.front(); queue.pop(); // 输出 cout &lt;&lt; " " &lt;&lt; curr-&gt;value; if(curr-&gt;left != nullptr)&#123; queue.push(curr-&gt;left); &#125; if(curr-&gt;right != nullptr)&#123; queue.push(curr-&gt;right); &#125; &#125; &#125; // 树的深度 int BinaryTreeDepth(link_type T) &#123; if(T == nullptr) &#123; return 0; &#125; return (max(BinaryTreeDepth(T-&gt;left), BinaryTreeDepth(T-&gt;right)) + 1); &#125; // 比较两个树是否相等 bool CompareTwoBinaryTree(link_type TA, link_type TB) &#123; // 均为空 if(TA == nullptr &amp;&amp; TB == nullptr) &#123; return true; &#125; else if(TA == nullptr || TB == nullptr) &#123; return false; &#125; // 比较data if(TA-&gt;value != TB-&gt;value) &#123; return false; &#125; return CompareTwoBinaryTree(TA-&gt;left, TB-&gt;left) &amp;&amp; CompareTwoBinaryTree(TA-&gt;right, TB-&gt;right); &#125; // 二叉树节点个数 int BinaryTreeNodeNumbers(link_type T)&#123; if(T == nullptr)&#123; return 0; &#125; return BinaryTreeNodeNumbers(T-&gt;left) + BinaryTreeNodeNumbers(T-&gt;right) + 1; &#125; // 求二叉树第 K 层节点的个数 int BinaryTreeKLevelSize(link_type T, int k)&#123; if(T == nullptr || k &lt; 0)&#123; return 0; &#125; // 第 0 层 if(k == 0)&#123; return 1; &#125; return BinaryTreeKLevelSize(T-&gt;left, k - 1) + BinaryTreeKLevelSize(T-&gt;right, k - 1); &#125; // 判断二叉树是否为平衡二叉树 bool isAVLTree(link_type T)&#123; if(T == nullptr)&#123; return true; &#125; if(abs(BinaryTreeDepth(T-&gt;left) - BinaryTreeDepth(T-&gt;right)) &gt; 1)&#123; return false; &#125; return isAVLTree(T-&gt;left) &amp;&amp; isAVLTree(T-&gt;right); &#125; // 判断是否为二分查找树 BST bool isValidBST(link_type T)&#123; return isValidBST(T, INT_MIN, INT_MAX); &#125; bool isValidBST(link_type T, int minVal, int maxVal)&#123; if(T == nullptr)&#123; return true; &#125; if(T-&gt;value &lt; minVal || T-&gt;value &gt; maxVal)&#123; return false; &#125; return isValidBST(T-&gt;left, minVal, T-&gt;value) &amp;&amp; isValidBST(T-&gt;right, T-&gt;value, maxVal); &#125; // 非递归断是否为二分查找树 BST (中序非递归) bool isValidBSTNoRec(link_type T)&#123; if(T == nullptr)&#123; return true; &#125; stack&lt;link_type&gt; stack; // 栈 link_type curr = T; // 当前节点 link_type pre = nullptr; // 记录前一个节点 while(curr || !stack.empty())&#123; while(curr)&#123; stack.push(curr); curr = curr-&gt;left; &#125; curr = stack.top(); stack.pop(); if(pre &amp;&amp; pre-&gt;value &gt; curr-&gt;value)&#123; return false; &#125; pre = curr; curr = curr-&gt;right; &#125; return true; &#125; // 求二叉树的镜像 link_type mirrorTree(link_type T)&#123; if(T == nullptr)&#123; return T; &#125; link_type newRoot = new TreeNode(T-&gt;value); newRoot-&gt;left = mirrorTree(T-&gt;right); newRoot-&gt;right = mirrorTree(T-&gt;left); return newRoot; &#125; // 判断两棵树是否互为镜像 bool isMirrorTree(link_type TA, link_type TB)&#123; if(TA == nullptr &amp;&amp; TB == nullptr)&#123; return true; &#125; else if(TA == nullptr || TA == nullptr)&#123; return false; &#125; if(TA-&gt;value != TB-&gt;value)&#123; return false; &#125; return isMirrorTree(TA-&gt;left, TB-&gt;right) &amp;&amp; isMirrorTree(TA-&gt;right, TB-&gt;left); &#125; // 树中两个节点的最低公共祖先节点 link_type getLastCommonParentNode(link_type root, link_type TA, link_type TB)&#123; if(root == nullptr)&#123; return nullptr; &#125; if(root == TA || root == TB)&#123; return root; &#125; link_type commonleft = getLastCommonParentNode(root-&gt;left, TA, TB); link_type commonright = getLastCommonParentNode(root-&gt;right, TA, TB); if(commonleft != nullptr &amp;&amp; commonright != nullptr)&#123; return root; &#125; if(commonleft != nullptr)&#123; return commonleft; &#125; return commonright; &#125; &#125;;#endif // !__TREE_H__ 测试代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;bitset&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;#include "tree.h"using namespace std;int main()&#123; // binary tree TreeNode* root; Solution solution; cout &lt;&lt; "create tree begin!" &lt;&lt; endl; solution.CreateTree(root); // create cout &lt;&lt; endl; cout &lt;&lt; "create tree end!" &lt;&lt; endl; cout &lt;&lt; "preTraverse tree begin!" &lt;&lt; endl; solution.preTraverse(root); // 前序 cout &lt;&lt; endl; cout &lt;&lt; "no recursive preTraverse tree begin!" &lt;&lt; endl; solution.preTraverseNoRec(root); // 非递归前序 cout &lt;&lt; endl; cout &lt;&lt; "midTraverse tree begin!" &lt;&lt; endl; solution.midTraverse(root); // 中序 cout &lt;&lt; endl; cout &lt;&lt; "no recursive midTraverse tree begin!" &lt;&lt; endl; solution.midTraverseNoRec(root); // 非递归中序 cout &lt;&lt; endl; cout &lt;&lt; "postTraverse tree begin!" &lt;&lt; endl; solution.postTraverse(root); // 后序 cout &lt;&lt; endl; cout &lt;&lt; "no recursive postTraverse tree begin!" &lt;&lt; endl; solution.postTraverseNoRec(root); // 非递归后序 cout &lt;&lt; endl; cout &lt;&lt; "levelTraverse tree begin!" &lt;&lt; endl; solution.levelTraverse(root); // 层次 cout &lt;&lt; endl; cout &lt;&lt; "binary tree node numbers: "&lt;&lt; solution.BinaryTreeNodeNumbers(root) &lt;&lt; endl; cout &lt;&lt; "binary tree depth: "&lt;&lt; solution.BinaryTreeDepth(root) &lt;&lt; endl; // 输出二叉树 1.2 层节点个数 cout &lt;&lt; "binary tree 1 level size: " &lt;&lt; solution.BinaryTreeKLevelSize(root, 1) &lt;&lt; endl; cout &lt;&lt; "binary tree 2 level size: " &lt;&lt; solution.BinaryTreeKLevelSize(root, 2) &lt;&lt; endl; cout &lt;&lt; "binary tree is valid BST: " &lt;&lt; solution.isValidBST(root) &lt;&lt; endl; cout &lt;&lt; "binary tree is valid BST no rec: " &lt;&lt; solution.isValidBSTNoRec(root) &lt;&lt; endl; cout &lt;&lt; "binary tree is valid AVL: " &lt;&lt; solution.isAVLTree(root) &lt;&lt; endl; cout &lt;&lt; "binary tree test end！" &lt;&lt; endl; solution.DestoryTree(root); return 0;&#125; 以前序遍历 1-&gt;2-&gt;3-&gt;2-&gt;4-&gt;5 为例，过一遍用例，打印结果如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253[root@yejy binaryTree]# valgrind ./a.out ==18094== Memcheck, a memory error detector==18094== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.==18094== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info==18094== Command: ./a.out==18094== create tree begin!1230020045000create tree end!preTraverse tree begin! 1 2 3 2 4 5no recursive preTraverse tree begin! 1 2 3 2 4 5midTraverse tree begin! 3 2 2 1 5 4no recursive midTraverse tree begin! 3 2 2 1 5 4postTraverse tree begin! 3 2 2 5 4 1no recursive postTraverse tree begin! 3 2 2 5 4 1levelTraverse tree begin! 1 2 4 3 2 5binary tree node numbers: 6binary tree depth: 3binary tree 1 level size: 2binary tree 2 level size: 3binary tree is valid BST: 0binary tree is valid BST no rec: 0binary tree is valid AVL: 1binary tree test end！==18094== ==18094== HEAP SUMMARY:==18094== in use at exit: 0 bytes in 0 blocks==18094== total heap usage: 26 allocs, 26 frees, 5,904 bytes allocated==18094== ==18094== All heap blocks were freed -- no leaks are possible==18094== ==18094== For counts of detected and suppressed errors, rerun with: -v==18094== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) 大概就这样，晚安！！]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 程序异常排查]]></title>
    <url>%2F2019%2F03%2F05%2FLinux-%E7%A8%8B%E5%BA%8F%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[痛并快乐着 今天讲讲C/C++程序的常用调试手段，介绍调试手段之前，我会首先对开发过程中可能遇到的问题进行一个总结，大概可以把问题分为以下几类： 必现的程序逻辑错误概率性错误进程卡死或挂掉，系统变卡，cpu 调度变慢程序正常，程序性能瓶颈分析 三年下来，排查的问题不少，该遇到的都遇到了，不该遇到的也遇到了，只能说五味杂陈。现在的我大概是这样的，一段程序放在我面前，我会从以下几个角度去考虑它。 功能这段程序是用来实现什么功能？ 是否可以满足功能的需求？是否可以对职责场景覆盖全面？ 代码规范变量名、函数名、类名是否简单、精准的表达变量的含义？所有变量命名是否可以保持一致性？缩进，换行，可读性如何？（驼峰、下划线，这个根据公司或者谷歌等的编码规范去做，至于缩进、换行、注释等，可以在经常使用的ide上安装相关格式化插件） 是否涉及动态资源是否有申请动态内存，文件描述符等，执行完是否有正确释放？指针等操作是否规范？ 性能如何是否有一些执行耗时的操作，I/O，网络文件下载，文件解析等，是否可以进行优化？是否会影响到功能体验？使用异步线程执行会更好吗？ 多线程相关是否涉及到多线程，临界区访问是否正常？会引入多线程问题吗？接口可重入吗？会造成死锁吗？ 是否符合常见的设计原则类继承是否符合里氏替换原则？接口做的事情是不是太多了，是否符合单一职责原则？程序是否有其他地方也用到，可以复用吗？是否有重复代码，可以精简吗？ 大概就这些吧，如果都考虑到了，这个程序就完美了吗？ 不不不，程序只是在当前场景下表现正常，也许在某个时刻某个不知名的场景下，还是会出问题，问题原因可能是因为其他模块代码的影响，可能是系统环境变了，可能是某些不知名的原因。。。。 只能说程序出问题的可能性太高了，因此程序调试和排错的手段，就显得异常重要！ 必现的程序逻辑错误对于必现的程序逻辑错误，一开始，我们往往会选择在关键地方加上一些 log 来进行问题排查(有些比较特殊场景只能加 log )，在我看来，采用这种方式可以，前提是你对代码的业务流程已经比较熟悉，然后你为了确认一下自己的判断，去加 log(可以在ide 中设置一些快捷键)，因为你知道 log 加在哪里最关键，而不是漫无目的，否则效率会奇低。 另一种方式当然是使用调试工具，单步调试，随时查看栈中任意数据，Linux 下使用GDB，windows 直接用宇宙第一ide：Visual Studio，至于 android 调试 Native C++ 程序，现在公司是修改完代码、编译，然后用 adb pull 到 android 系统上(公司开发的是android系统软件，不是app), 说实话，实在无语，原因是 android 系统的 ANR 机制，长时间不操作，调试进程会被系统杀掉，这个后面有时间再研究一下，肯定有更好的办法（不能把ANR机制关了吗 ?）。 概率性错误此类错误，那就涉及到场景复现的问题，如果有拿到有效的 log，那还好，可以根据log进行分析，找出问题的根本原因；最怕的就是测试或者客户测反馈一个bug，但是没有效 log和相关配置，然后本地又复现不出来，这种比较麻烦，能做的无非就是复现，或者做一些促进复现的工作，比如写一些测试脚本，然后在代码流程中加入一些有助于问题分析的 log，然后放到反馈的环境下去挂机。 如果最后挂机也没有复现，客户侧也没有再复现，那怎么办，最近就遇到一个，实在太坑了，工厂反馈的bug，100台中大概出现4台，系统升级过程中部分配置没有生效，导致升级上来，系统直接异常，而且完全没有有效的 log。 对于此类概率性问题，之前其实已经有处理过一些，大部分原因都是两个进程/线程的启动时序出现变动，并且两者间又存在依赖导致的, 此类问题相对来说比较难查，因为你要对两个大的模块都要有一个整体的了解，两模块间的关系要分析的很清楚。这种涉及多个模块的问题，比较考验你的代码阅读能力，以及对整体框架的理解。 说回那个比较坑的系统升级配置丢失问题，我详细的查看了一下系统的启动脚本(shell) 以及 该升级模块的代码，然后抛出了几个可能的原因，预约了一个会议室，把部门主管和其他部门的相关模块都拉上，一起讨论分析，因为工厂反馈的，比较着急，要出货（哈哈），大家一起确认完，大概也就这几个原因，比较可能的是，触发升级的进程没有去设置环境变量，升级转换配置的模块在运行的过程中异常挂掉了，升级模块进程有依赖另一个进程，而且两者间需要保证确定的启动优先顺序等，但是不能确定啊，所以我改了下脚本，在两种最可能出现的场景下，让系统循环运行，这种人力做基本不可能，挂了一个周末，问题还是没有复现。 无解了是吗？ 确实是，因为你不知道原因啊，那怎么对症下药呢？ 是的，我们虽然不知道确切的原因，但是我们知道原因就是其中的一个，所以当时做了个容错，保证就算出现由其中任何一个原因导致的该问题，我们都可以用这个容错修改规避掉，其实很简单，在 shell 脚本中加入一个判断就可以了，升级模块代码，需要成功以后，才去设置成功的环境变量，否则下次重启还是需要重新执行配置转换流程，然后还补充了一些关键的log，由于问题概率非常低，容错可以保证客户侧的正常使用，然后如果问题真的出现，也可以及时反馈分析。 进程挂掉，系统变卡系统变卡，就是CPU 调度变慢，那这肯定是哪个程序一直占用CPU，导致其他程序无法被执行。 常见的原因可能是，内存变少，导致系统分配内存的时候，需要频繁的进行内存置换操作，进而导致系统变慢，内存相关可以看下之前的另一篇博客Linux 系统内存分析，如果置换到后面，物理内存和交换空间都用完了，系统将触发oom-killer，把来申请内存的进程直接杀掉了，这也是导致进程挂掉的可能原因之一; 或者某个程序死循环了，而且还没有超过系统设置的默认函数栈大小（ulimit –s, 超过就栈溢出，直接收到系统信号，然后进程直接被杀了），导致系统卡住；最后就是指针误操作(访问非法内存，数组越界也属于此类)，这种算是最基本的错误了，需要无时无刻警惕，有一定经验后，这种错误基本就不会犯了。 对于该类所谓的疑难问题，最困恼我们的无非就是定位，定位到模块，定位到进程/线程，定位到具体代码行。公司当前有几个系统平台采用的方法是对异常信号（signal）注册回调，然后进行堆栈回溯，最后将堆栈保存到本地文件、标准输出、远程服务器等，这样比较方便，实时性也较好(对于一些比较低端的系统，承受不来valgrind等高级工具的，还是不错的选择)，可以看下这篇文章，基本是一样的Android Native Crash。 程序正常，程序性能瓶颈分析工欲善其事，必先利其器！ 在 Linux 系统下，有很多很棒的、来源的性能分析工具，我现在有这样一个想法，如果你开发多平台使用的程序，那么请你把 Linux 作为你编译、调试、性能调优的大本营。你想想编译服务器(Linux)上支持的 20 个线程，同时编译你的程序，那速度简直快到飞起，像我们使用 NDK 到自己的 windows 系统下编译，整份代码编完需要 10 分钟以上，Linux 下直接ndk-build -j20，2~3 分钟就搞定，而且编译服务器所有人共享。 性能调优，你写出来的代码，你如何知道它有没有坑呢？ 怎么知道它是完美的呢？ 我们需要一款计分工具，Linux下常用的有 gprof、google-perftools、valgrind等。我们看一下valgrind，看下它搭配kcachegrind 导出的分析图，可以说是相当细致，里面有各个函数执行的时间占比，调用次数。 下面这个是valgrind + gprof2dot.py + dot 导出图的一部分，太大了，截了关键的一部分，程序是练手的二叉树算法： kcachegrind：https://sourceforge.net/projects/precompiledbin/]]></content>
      <tags>
        <tag>程序调试与问题排查</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 11]]></title>
    <url>%2F2019%2F02%2F23%2FC-11%2F</url>
    <content type="text"><![CDATA[概要 C++ 总共有四个官方版本，都是以 ISO 标准被接受的年份命名的，它们是 C++98, C++03, C++11和C++14。C++98 和 C++03 仅有一些技术细节上的不同，可以统称为 C++98，C++14则是C++11的超集。总的来说，C++11是C++所有版本中跳跃性最大的一个版本，很多人认为相对之前的版本，C++11是一个新语言。工作中，由于系统平台很多，有些较早时间开发的并不支持C++11，gcc编译器是在 4.7 版本中加入的C++11，在android和armv6以上cpu的系统是可以支持的，那今天就结合工作中C++11使用情况，来对C++11的知识进行一个总结。参考书籍主要是&lt;&lt;Effective Modern C++&gt;&gt;，该书作者是Scott Meyers，他的Effective系列书籍，都是同样的配方，熟悉的味道，对所有的特性进行系统的分析，包括实现原理，主要解决问题等，而且挖的很深，很细，往往需要多次阅读，才能完全吸收。 我会结合工程中具体使用场景进行简短分析，同时加入相关测试使用代码，挑选一些平常工作中用的到的特性。 本章内容分为： 语言可用性的强化 语言运行期的强化 标准库扩充：新增容器 标准库扩充：智能指针 系统环境 gcc &ensp;版本 &ensp; 4.8.5 &ensp; 20150623 &ensp; (Red Hat 4.8.5-28) &ensp; (GCC) Linux&ensp; yejy &ensp;3.10.0-514.el7.x86_64&ensp; #1 &ensp;SMP &ensp;Tue&ensp; Nov &ensp;22 &ensp;16:42:41&ensp; UTC &ensp;2016&ensp; x86_64&ensp; x86_64 &ensp;x86_64&ensp; GNU/Linux CMake 编译参数： add_definitions(-std=c++11) 语言可用性的强化nullptr 和 constexprnullptr 的引入主要是为了避免 0 和 NULL 在重载决议中的意外，同时可以提高代码的清晰性。1234567void f(int); // f的三个重载版本void f(bool);void f(void*);f(0); // 调用f(int), 而不是f(void*)f(nullptr); // 调用f(void*), nullptr 会通过隐式转型为裸指针f(NULL); // 可能通不过编译 提高代码清晰性例子：1234567891011auto result = findRecord(/*实参*/);// 按照以前，这个是指针还是整形 ?if(result == 0)&#123; ...&#125;// 必然指针if(result == nullptr)&#123; ...&#125; constexpr 主要作用是，编译器在编译时，constexpr修饰函数如果传入实参是编译期已知的，就把这些表达式直接优化出结果并植入到程序运行时，从而增加程序的性能，并且 constexpr具备 const 属性。 类型推导 (auto 和 decltype)auto 关键字，类型推导，在之前的C++中，auto作为一个存储类型，如果一个变量不是register（寄存器）变量，就是auto了。一个主要使用场景，就是遍历容器：12345678910// 以前unordered_map&lt;char, int&gt; hashMapA;for(unordered_map&lt;char, int&gt;::const_iterator it = hashMapA.begin(); it != hashMapA.begin(); it ++)&#123; ...&#125;// 有了auto以后，代码量可以减少很多for(auto it = hashMapA.begin(); it != hashMapA.begin(); it ++)&#123;&#125; auto 不能用于函数传参，和数组推导。 decltype 关键字是为了解决 auto 关键字只能对变量进⾏类型推导的缺陷而出现的。它的用法和 sizeof 很相似. decltype ( 变量/表 达 式 ) 1234567// nullptrif (std::is_same&lt;decltype(NULL), decltype(0)&gt;::value) std::cout &lt;&lt; "null == 0" &lt;&lt; std::endl;if (std::is_same&lt;decltype(NULL), decltype((void *)0)&gt;::value) std::cout &lt;&lt; "null == (void *)0" &lt;&lt; std::endl;if (std::is_same&lt;decltype(NULL), decltype(nullptr)&gt;::value) std::cout &lt;&lt; "null == nullptr" &lt;&lt; std::endl; 列表初始化C++11 提供了一种统一的初始化方法，在 C++98/03 中我们只能对普通数组和 POD(plain old data，简单来说就是可以用memcpy复制的对象) 类型可以使用列表初始化，如下： 数组的初始化列表： int arr[4] = {1,2,3,4} C++11 将此方法适用性范围进行了放大，列表初始化的方式对：内置类型（int、float、double、char等）、数组、自定义的类、函数参数列表、STL标准模板库等都是有效的。 123456789101112131415// podclass Test1 &#123;public: int a; int b; int c;&#125;;Test1 typic = &#123;0,1,2&#125;;int d&#123;0&#125;;float b&#123;1.2&#125;;std::map&lt;int,std::string&gt; _map&#123;&#123;1,"lxg"&#125;,&#123;2,"the answer"&#125;,&#123;3,"hello world."&#125;&#125;; // c++ 98 不支持 列表初始化在 STL 中的实现则是基于std::initializer_list类型, STL有提供std::initializer_list类型作为参数的构造函数。1234567891011121314151617// vector 可变长参数初始化class initializer_list_Test&#123;public: initializer_list_Test(std::initializer_list&lt;int&gt; list) &#123; for (std::initializer_list&lt;int&gt;::iterator itr = list.begin(); itr != list.end(); itr++) &#123; m_vecTest.push_back(*itr); &#125; &#125; std::vector&lt;int&gt; m_vecTest;&#125;;// initializer_list 可以作为类construct的形参类型，也可以作为普通函数的形参类型initializer_list_Test initializer_Test&#123;0, 1, 2, 3, 4, 5&#125;; 区间 for 迭代主要是提供一种类似脚本语言的遍历循环的方式:12345678910// 以前unordered_map&lt;char, int&gt; hashMapA;for(unordered_map&lt;char, int&gt;::const_iterator it = hashMapA.begin(); it != hashMapA.begin(); it ++)&#123; ...&#125;// 现在for(auto elementB : hashMapA)&#123; ...&#125; 模板别名我们应该尽量避免使用typedef，typedef 可以为类型定义一个新的名称，而没有办法为模板定义一个新的名称，因为模板不是类型， C++11提供了一个using关键字来处理模板别名，该关键字在函数指针使用过程中，也比较容易理解12345678910// 函数指针typedef void(*FP)(int, const std::string&amp;);using FP = void(*)(int, const std::string&amp;); // 使用别名是不是更直观// 模板别名template &lt;typename T&gt;using MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;; // MyAllocList 就是 std::list&lt;T, MyAlloc&lt;T&gt;&gt; 同义词MyAllocList&lt;Widget&gt; lw; // 客户代码 模板变长参数模板参数可以不固定，如果需要对其中数据进行解包，C++11中可以使用递归的方式。123456789101112// 至少包含一个模板参数的模板类template &lt; typename Require , typename ... Args &gt; class Magic ; // 可变模板参数的模板函数template &lt;typename ... Args&gt;void magic(Args ... args)&#123; std::cout &lt;&lt; sizeof ... (args) &lt;&lt; std::endl;&#125;magic(0); // 传入1个实参magic(1,2,3); // 传入3个实参 override 和 final有时候，程序员并不想尝试覆盖父类虚函数，但是又恰好加入了一个具有相同名字的函数。另一个可能的情形是，当基类的虚函数被删除后，子类拥有旧的函数就不再覆盖该虚函数，摇身一变成为了一个普通的类方法，这将造成灾难性的后果，导致函数表现完全不一样了。 C++11 引入了 override 和 final 这两个关键字来防止上述情形的发生。 override 当重载虚函数时，引入 override 关键字将显式的告知编译器进行覆盖，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译：12345678910class Base &#123;public: virtual void foo( int );&#125;;class SubClass : Base &#123;public: virtual void foo( int ) override ; // 合法 virtual void foo( float ) override ; // 非法, 父类没有此虚函数&#125;; final 则是为了防止类被继续继承以及终止虚函数继续覆盖引入的。12345678910111213class Base &#123; virtual void foo () final ;&#125;;class SubClass1 final : Base &#123;&#125;; // 合法class SubClass2 : SubClass1 &#123;&#125;; // 非法 , SubClass1已 finalclass SubClass3 : Base &#123; void foo (); // 非法, foo已 final&#125;; 语言运行期的强化Lambda 表达式什么是C++11 Lambda 函数，如何使用 Lambda 函数。 Lambda函数是C++中的一种匿名函数, 而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。这样的场景其实有很多很多，所以匿名函数⼏乎是现代编程语言的标配。 Lambda 函数其实就像一个普通的函数一样： You can pass arguments to it (可以传参)It can return the result (可以返回结果) 但它没有任何名字。它主要用于我们必须创建非常小的函数, 以作为回调传递给另一个 API的场景 (回调)。 Lambda 语法：1234567// lamda/** [ captures ] &lt;tparams&gt;(optional)(c++20) ( params ) specifiers exception attr -&gt; * ret requires(optional)(c++20) &#123; body &#125; (1) * [ captures ] ( params ) -&gt; ret &#123; body &#125; (2) * [ captures ] ( params ) &#123; body &#125; (3) * [ captures ] &#123; body &#125; (4) */ 解释成中文就是:123[ 捕 获 列 表 ]( 参 数 列 表 ) mutable ( 可 选 ) 异 常 属 性 -&gt; 返 回 类 型 &#123; // 函 数 体&#125; 除了这个捕获列表外，其他应该都很好理解，捕获列表主要含义有以下几个： [] 空捕获列表[name1, name2, . . . ] 捕获一系列变量[&amp;] 引用捕获, 让编译器自行推导捕获列表 （引用即别名，内部修改该变量，会改变闭包外部该捕获变量的值）[=] 值捕获, 让编译器执行推导应用列表 （值捕获为拷贝，内部修改该变量，不会改变闭包外部该捕获变量的值） 12345678910int test_param1 = 56;auto f = [](int param1) &#123; return param1; &#125;;// mutable 允许表达式修改捕获的参数 noexcept 函数不会抛出异常auto test_param2 = [=](int i = 6) mutable noexcept(true)-&gt;int&#123; i += 12; test_param1 += 1; return test_param1 + i;&#125;; std::functionLambda 表达式的本质是一个函数对象，当 Lambda 表达式的捕获列表为空时， Lambda 表达式还能够作为一个函数指针进行传递。 C++11 std::function 是一种通用、多态的函数封装，它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作，它也是对 C++ 中现有的可调用实体的一种类型安全的包裹（相对来说，函数指针的调用不是类型安全的）。换句话说，就是函数的容器，当我们有了函数的容器之后便能够更加方便的将函数、函数指针作为对象进行处理。 12345678910111213141516171819202122232425262728293031323334#include &lt;functional&gt;int test()&#123; int a = 5; return a;&#125;int main()&#123; // std::function std::function&lt;int()&gt; function_Test; function_Test = nullptr; try &#123; function_Test(); // function 为空时进行调用，会出现异常 &#125; catch (std::bad_function_call e) &#123; std::cout &lt;&lt; e.what() &lt;&lt; std::endl; // 输出： bad_function_call &#125; function_Test = test; // 存储函数 std::cout &lt;&lt; function_Test() &lt;&lt; std::endl; function_Test = []() &#123; std::cout &lt;&lt; "i" &lt;&lt; "" &lt;&lt; "j" &lt;&lt; std::endl; return 5; &#125;; // 存储 `Lambda` function_Test(); return 0;&#125; 函数指针可以说是一个相当重要的运行时机制，现在我们可以用 Lambda表达式和 std::function来实现，既正规又清晰。对于实际开发中的回调实现，不同代码层次间的适配工作提供了很好的支持。 std::bind/std::placeholderstd::bind 则是用来绑定函数调用的参数的，它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数，我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;functional&gt;class Test&#123;public: void MemberFunction1() &#123; std::cout &lt;&lt; "member function 1" &lt;&lt; std::endl; &#125; void MemberFunction2(int i) &#123; std::cout &lt;&lt; "member function 2, i = " &lt;&lt; i &lt;&lt; std::endl; &#125; int iMemData = &#123;2000&#125;;&#125;;int main()&#123; // std::bind ; std::placeholders using namespace std::placeholders; // 占位符 Test testClass; // 测试类中的 MemberFunction2，bind 函数时，第一个参数位置先占用，不传入实参 auto bindFunction = std::bind(&amp;Test::MemberFunction2, &amp;testClass, _1); // 传入实参 bindFunction(100); // 直接传入实参 function_Test1 = std::bind(&amp;Test::MemberFunction2, &amp;testClass, 6600); // 调用 bind 函数 function_Test1(); std::function&lt;void()&gt; function_Test2; // bind 函数传入 std::function auto bindFunction2 = std::bind(&amp;Test::MemberFunction2, &amp;testClass, 6600); function_Test2 = bindFunction2; function_Test2(); return 0;&#125; 右值引用在介绍右值引用前，我们先了解一下左值。具体什么是左值呢？ 左值是可以通过地址访问的变量值。 lvalue is anything whose address is accessible. It means we can take address of lvalue using &amp; operator. 因此，右值正好与左值相反。 Rvalue is anything that is not lvalue. It means we cannot take address of rvalue and it also don’t persist beyond the single expression. 我们不能通过 &amp; 运算符来获取右值的地址，而且右值在使用时，不会超出单个表达式。 看下面例子。1234567891011121314151617181920int x = 1;int * ptr3 = &amp;(x+1); // Compile Errorint a = 7; // a is lvalue &amp; 7 is rvalue int b = (a + 2); // b is lvalue &amp; (a+2) is rvalue int c = (a + b) ; // c is lvalue &amp; (a+b) is rvalue int * ptr = &amp;a; // Possible to take address of lvalue //int * ptr3 = &amp;(a + 1); // Compile Error. Can not take address of rvalueint getData()&#123; int data = 0; return data;&#125;int * ptr = &amp;getData(); // Compile error - Cannot take address of rvalue 传统C++中的 Reference变量是始终指向已存在变量的别名，也就是始终指向左值。12int x = 7;int &amp; lvalueRef = x; // lvalueRef is a lvalue reference 右值引用在C++11中引入，右值引用可以执行左值引用无法执行的操作，即右值引用可以引用右值。 Declaring rvalue reference1int &amp;&amp; rvalueRef = (x+1); // rvalueRef is rvalue reference 这里，rvalueRef 是 rvalue reference，它指向一个rvalue，即（x + 1）。 12345int getData()&#123; return 9;&#125;int &amp;&amp; rvalueRef2 = getData(); 那么右值引用的概念基本如上所示，那么C++11中使用右值引用来干什么呢？ 移动语义 没错，就是引入移动语意，上图是原理图。 传统 C++ 通过拷贝构造函数和赋值操作符为类对象设计了拷贝/复制的概念，但为了实现对资源的移动操作，调⽤者必须使用先复制、再析构的方式，否则就需要自己实现移动对象的接口。这个设计是非常反人类的，已经有一个现成的”地”在这里了，为什么要重新开辟另一块相同的”地”，然后还把原来那一块”地”给毁了，这不是吃力不讨好吗？ 移动语意和右值引用，就是为了解决临时对象在内存上的负载，每次我们从函数返回一个对象时，都会创建一个临时对象，最终会被复制。在最后等于我们创建了一个对象的 2 个副本，而我们只需要一个。 移动语意则不会进行复制操作，而是如上图中所示转移内存的控制权，将指针传给当前对象，原来的指针置空。 完美转发一个模板函数，如何能够判断传入的参数是右值还是左值，是该进行右值引用，还是左值处理呢？ 如何才能做到参数完美派发呢？ 首先我们介绍一个规则，引用坍缩/折叠规则：在传统 C++ 中，我们不能够对一个引用类型继续进行引用，但 C++ 由于右值引用的出现而放宽了这一做法，从而产生了引用坍缩/折叠规则，允许我们对引用进行引用，既能左引用，又能右引用。 规则如下：12345678//函数形参类型 实参参数类型 推导后函数形参类型1、 T&amp; + &amp; = T&amp;2、 T&amp; + &amp;&amp; = T&amp;3、 T&amp;&amp; + &amp; = T&amp;4、 T或T&amp;&amp; + &amp;&amp; = T&amp;&amp; 因此，模板函数中实参类型为 T&amp;&amp;不一定能进行右值引用，所谓完美转发，就是为了让我们在传递参数的时候，保持原来的参数类型（左引用保持左引用，右引用保持右引用）。为了解决这个问题，我们使用 std::forward 来进行参数的转发。 std::forward 即没有造成任何多余的拷贝，同时完美转发 (传递) 了函数的实参给了内部调用的其他函数。std::move 单纯的将左值转化为右值。 两者的内部实现都是 static_cast 转型动作， std::forward&lt;T&gt;(v) 和 static_cast&lt;T&amp;&amp;&gt;(v) 是一样的。 我们看一个推导过程：12345template&lt;class A1&gt; void f(A1 &amp;&amp; a1)&#123; return g(static_cast&lt;A1 &amp;&amp;&gt;(a1));&#125; 当传给f一个左值（类型为T）时，由于模板是一个引用类型，因此它被隐式装换为左值引用类型T&amp;，根据推导规则1，模板参数A被推导为T&amp;。这样，在f内部调用F(static_cast&lt;A &amp;&amp;&gt;(a))时，static_cast&lt;A &amp;&amp;&gt;(a)等同于static_cast&lt;T&amp; &amp;&amp;&gt;(a)，根据引用叠加规则第2点，即为static_cast&lt;T&amp;&gt;(a)，这样转发给g的还是一个左值。 当传给f一个右值（类型为T）时，由于模板是一个引用类型，因此它被隐式装换为右值引用类型T&amp;&amp;，根据推导规则2，模板参数A被推导为T。这样，在G内部调用F(static_cast&lt;A &amp;&amp;&gt;(a))时，static_cast&lt;A &amp;&amp;&gt;(a)等同于static_cast&lt;T&amp;&amp;&gt;(a)，这样转发给F的还是一个右值（不具名右值引用是右值）。 可见，引入 std::forward&lt;T&gt;(v) ，配合折叠引入推导规则，是可以做到参数完美转发的。 标准库扩充：新增容器std::unordered_map 和 std::unordered_set我们知道传统 C++ 中的有序容器 std::map/std::set，这些元素内部通过红黑树进行实现，插入和搜索的平均复杂度均为 O(log(size))。在插入元素时候，会根据 &lt; 操作符比较元素大小并判断元素是否相同，并选择合适的位置插入到容器中。当对这个容器中的元素进行遍历时，输出结果会按照 &lt; 操作符的顺序来逐个遍历。 而无序容器中的元素是不进行排序的，内部通过哈希表实现的，插入和搜索元素的平均复杂度为 O(constant)，在不关心容器内部元素顺序时，能够获得显著的性能提升。 C++11引入了两组无序容器：std::unordered_map/std::unordered_multimap 和 std::unordered_set/std::unordered_multiset。 用法与原来的 std::map/std::multimap/std::set/set::multiset 基本类似。 之前应该已经比较熟悉了，就举一个std::unordered_map 使用例子。1234567891011121314151617181920212223242526272829#include &lt;unordered_map&gt;using namespace std;// 元素相同，顺序不同// hash_mapbool isPermutation(string stringA, string stringB)&#123; if(stringA.length() != stringB.length())&#123; return false; &#125; unordered_map&lt;char, int&gt; hashMapA; unordered_map&lt;char, int&gt; hashMapB; for(auto elementA : stringA)&#123; hashMapA[elementA]++; hashMapB[elementA]++; &#125; if(hashMapA.size() != hashMapB.size())&#123; return false; &#125; for(auto elementB : hashMapA)&#123; if(elementB.second != hashMapB[elementB.first])&#123; return false; &#125; &#125; return true;&#125; std::array 和 std::forward_liststd::array 是一个固定大小的数组容器，相比std::vector（堆内存）, 它申请的内存是在栈上的，访问其中元素会更加灵活，性能更高，内存消耗更少。 std::array不能被隐式转换为指针。12345678910void foo( int *p, int len) &#123; return ;&#125;std :: array &lt;int , 4&gt; arr = &#123;1 ,2 ,3 ,4&#125;; // 传入元素类型和个数即可// C风格接口传参// foo (arr , arr . size ()); // 非法 ,无法隐式转换foo (&amp; arr [0] , arr. size ()); std::forward_list 内部实现则是一个单向链表，使用接口和std::list基本类似，相比于std::list来说，如果是一些无需双向迭代的场景，std::forward_list 空间利用率更高。 std::tuple传统 C++ 中的容器，除了 std::pair 外，似乎没有现成的结构能够⽤来存放不同类型的数据（通常我们会自己定义结构）。但 std::pair 的缺陷是显⽽易见的，只能保存两个元素。std::tuple 元组则可以保存多个不同类型的元素。主要接口： std::make_tuple: 构造元组std::get: 获得元组某个位置的值std::tie: 元组拆包 1234567891011121314#include &lt;tuple&gt;// 构造元组auto student = std :: make_tuple (3.8 , 'A', " 张 三 ");// 获得元组某个位置的值std::get &lt;0&gt;(student)// 拆包double gpa;char grade ;std :: string name ;std :: tie(gpa , grade , name) = student; 标准库扩充：智能指针在构造函数的时候申请空间，⽽在析构函数（在离开作⽤域时调⽤）的时候释放空间，也就是我们常说的 RAII 资源获取即初始化技术，智能指针就是使用了该技术。 这一部分，我就不介绍了，因为之前已经分析过了，具体见： unique_ptr: https://www.cnblogs.com/blog-yejy/p/8972858.htmlshared_ptr: https://www.cnblogs.com/blog-yejy/p/9030722.htmlweak_ptr: https://www.cnblogs.com/blog-yejy/p/9727070.html 总结C++11 比之前版本好用很多有没有，语言可用性强化方面的各种修缮，以及新增语法糖，运行期强化部分的 Lambda表达式，右值引用对性能的极大提升，智能指针对资源管理的强化，新增容器对旧有容器的适用场景补充等, C++ 语言正变得越来越好，日久弥新。至于新加入的线程库和正则表达式支持，后续再统一介绍，线程相关总体和陈硕老师的muduo网络库中的封装思路是类似的，使用方式也不会相差太多。 参考 Effective Modern C++高速上手 C++11/14/17https://thispointer.com/c11-tutorial/https://blog.csdn.net/ink_cherry/article/details/74573225]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 对象模型]]></title>
    <url>%2F2019%2F02%2F15%2FC-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[概要 我们知道， C++ 是一个语言联邦，包括 C、Object-Oriented C++、Template C++、STL。OO部分可以说是C++的核心部分，也是最为熟悉与陌生的地方，熟悉是因为每时每刻都在使用，像 C 语言这种过程式的语言，给人感觉总是十分的直接明了，无非就是堆栈建制，函数栈的切换，但是 OO不一样，编译器为我们做了太多的事情，构造，析构，虚函数，继承，多态…或者在member function中加入一些额外参数(this指针)，导致我们去计算对象的空间占用、函数调用的性能时，结果往往是意想不到的。这次就让我们来探索总结一下C++的对象模型，主要参考书籍 &lt;&lt;深度探索 C++ 对象模型&gt;&gt;，作者是C++第一代编译器cfront的编写者之一Lippman，之前看过一遍，工作快三年了，再温故一下，现在看起来感觉轻松很多，我会大致按书中目录顺序进行总结提炼，书总是要越看越薄的，同时，我会使用Linux gcc编译器去测试书中的demo程序，看一下 gcc 编译器究竟是如何设计 C++对象模型的。 本章内容分为： C++ 对象模型的整体设计 C++ 对象模型内存分布(Data member 语意) C++ 对象模型Function语意 RTTI (Runtime Type Identification) 深入理解C++对象模型，主要是让我们在编写相关程序时，能编写出更加高效且不包含错误倾向的代码，同时对C++编程更有信心，引用侯捷老师的话就是，能够做到胸中自有丘壑。 系统环境 gcc &ensp;版本 &ensp; 4.8.5 &ensp; 20150623 &ensp; (Red Hat 4.8.5-28) &ensp; (GCC) Linux&ensp; yejy &ensp;3.10.0-514.el7.x86_64&ensp; #1 &ensp;SMP &ensp;Tue&ensp; Nov &ensp;22 &ensp;16:42:41&ensp; UTC &ensp;2016&ensp; x86_64&ensp; x86_64 &ensp;x86_64&ensp; GNU/Linux 文章中相关模型图片也会借鉴书籍中的，不是我自己不想作图哈，只是已经有现成的，借鉴一下就可以了。UML类图、时序图、流程图、思维导图等，可以很好的让我们理解设计模型，从而发现其中的设计缺陷并完善之，非常有帮助。下面是我在熟悉一个线程池设计时，做的UML类图，图一出来，整体的设计就清晰了。 C++ 对象模型的整体设计对于C++对象模型，书中有提到两个概念来解释： 语言中直接支持面向对象程序设计的部分 对于各种支持的底层实现机制 对于第一点，在各种C++程序书中都有介绍，至于第二点，则是本书介绍的重点，市面上介绍C++面向对象底层实现机制的书籍非常少，好书就更少了。 在C++中，有两种class data members：static 和 nonstatic, 以及三种 class member functions: static 、nonstatic 和 virtual。如下 Class point： 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class point&#123;public: point(float xval); virtual ~point(); float x() const; static int PointCont();public: virtual ostream &amp;print(ostream &amp;os) const; float _x; int _p; static int _point_count;&#125;; 那么编译器是如何构建这个类中的 data members 和 function members呢？ 首先，书中引出了第一个简单对象模型，每个data members 和 function members都有自己的一个 slot(槽)，按声明顺序排列，每个槽里面放的是指向成员的指针，而不是成员本身，这样是为了避免”members 有不同的类型，因而需要不同存储空间”招致的问题, 该模式一个优点就是简单，并且引入了索引或slot的概念。 然后根据前面的slot概念，又提出了表格驱动对象模型，把data members 和 function members分别放到两张table中，对象则持有指向两张表的指针，data members table 中的slot保存数据本身， function members table中的slot保存函数指针，该模型主要是引出了 member function table, 为支持virtual function提供了一个有效的方案。 前面两个模型出现的主要问题，一个是引入指针过多，空间浪费严重，另一个则是添加的索引层次过多，导致数据存取性能较低，C++ 对象模型则在前两种模型基础上，对内存空间和存取时间做了优化，主要缺点是所用到的 class objects 的nonstatic data members有所修改(有可能是增加、移除或更改)，那么应用程序代码同样得重新编译。 在 C++ 对象模型中，Nonstatic data members 被放置于每一个类对象之内，static data members放在类对象之外，然后Static 和 nonstatic function members 也放在了类对象之外。模型图如下： 其中 Virtual functions 通过这两个步骤支持： 1. 每个class 产生一堆指向 virtual functions 的指针，放在表格中，这个表格就是virtual table(vtbl)。2.每一个class object被安插一个指针，指向相关virtual table。通常该指针被称为vptr。vptr的设定和重置都由类的constructor，destructor和copy assignment运算符自动完成。每一个class 所关联的type_info object（用以支持 RTTI）也经由virtual table被指出来，通常放在表格的第一个slot（位置视编译器而定，也可能不在virtual table中）。 那加入继承，如何支持? 书中作者和我们讨论了几种可行的解决方案，并且分析了各自优劣。 1.之前介绍过的简单对象模型。slot中直接包含一个base class subobject（继承关系中，父类所拥有的内容）的地址。主要优点：class object的大小不会因其base classes的改变而受影响 缺点：间接性导致的空间和存取时间上的额外负担 2.base table模型。每一个base class table中内含一个slot包含有相关base class的地址(bptr)，主要优点： 在每一个class object中对于继承都有一致的表现形式：每个class object都需要在固定位置放一个base class table指针，与base class的大小和个数无关 无需改变class object本身，就可以放大、缩小，或者更改base class table 缺点：间接性导致的空间和存取时间上的额外负担 base table示意图: 我们知道当前 C++ 编译器处理一般继承是将父类中的data members（包括父类的vptr）直接放到子类中，缺点是base class一修改，子类就需要重新编译；对于virtual base class则引入间接访问性（引入指针，后续介绍）。如下列一般继承关系： 子类直接获得父类的内容（不是virtual base class），相应的内存分布如下： C++ 对象模型内存分布(Data member 语意)首先，我们自己测试一下C++对象的大小，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Base&#123;public: int ib; char cb; static int is;public: Base() : ib(0), cb('B') &#123;&#125; virtual void af() &#123; cout &lt;&lt; "B::af()" &lt;&lt; endl; &#125; virtual void bf() &#123; cout &lt;&lt; "B::bf()" &lt;&lt; endl; &#125; virtual void cf() &#123; cout &lt;&lt; "B::cf()" &lt;&lt; endl; &#125;&#125;;int Base::is = 10;class Derive : public Base&#123;public: int id; char cd;public: void bf() &#123; cout &lt;&lt; "derive::bf" &lt;&lt; endl; &#125;&#125;;class Empty&#123;&#125;;int main()&#123; int *ptr; cout &lt;&lt; "data size, " &lt;&lt; "int:" &lt;&lt; sizeof(int) &lt;&lt; " " &lt;&lt; "float:" &lt;&lt; sizeof(float) &lt;&lt; " " &lt;&lt; "char:" &lt;&lt; sizeof(char) &lt;&lt; " " &lt;&lt; "ptr:" &lt;&lt; sizeof(ptr) &lt;&lt; " " &lt;&lt; endl; Base b; Derive derive; Empty empty; cout &lt;&lt; "Base class size: " &lt;&lt; sizeof(b) &lt;&lt; endl; cout &lt;&lt; "Derive class size: " &lt;&lt; sizeof(derive) &lt;&lt; endl; cout &lt;&lt; "empty class size: " &lt;&lt; sizeof(empty) &lt;&lt; endl;&#125; 最后打印结果分别为 16 字节和 24 字节、1 字节，知道为什么吗？C++ 对象模型的空间大小主要受到三个因素的影响： 1. 语言本身所造成的额外负担。当语言支持virtual base classes时，就会导致额外负担，需要提供一个指针，它可能指向virtual base class subobject，或者指向一个表格(V-table)。2.编译器对特殊情况提供的优化处理。某些编译器会对empty virtual base class提供特殊支持，通常1个字节大小。3.Alignment的限制。字节对齐影响，数据结构体的总大小通常32位系统为4的倍数，64位系统为8的倍数。 alignment就是将数值调整到某数的整数倍。通常32位系统alignment为4 bytes，64位系统为8 bytes, 以使bus的运输量达到最高效率。 根据上述三条规则，我们可以看出结果是对的， gcc 编译器，对于空的类，会提供 1 字节的空间大小，主要是为了保证在内存中的唯一性，便于区分；基类 Base 的static data member大小不包含在内，int 4 + char 1 + vptr 8 + alignment 3 总共 16 字节；Derive则是在基类的基础上在加了 8 字节，16 + int 4 + char 1 + alignment 3。 如果是多重继承，道理也是类似的。 相应的内存分布： 我们从图中可以看出，多重继承且均存在多态时，会出现多个vptr。 和之前存在较大差异的，主要是虚拟菱形继承，为了保证在每个子类中只存在一份base class subobject内容，编译器不得不为其加入一些间接访问特性（额外指针）。 代码大致如下： 继承关系： 编译器又是如何处理这种情况的呢？书中对该问题进行了探讨，总结起来主要有两种方式。 以指针指向base class的实现模型 该模型存在两个缺点，一是每个对象必须为其每个virtual base class背负一个额外指针。二是由于虚拟继承的串链的加长，导致间接存取层次的增加，意思是如果存在三层虚拟继承，我就需要三次间接存取（经由三个virtual base class）。 为了解决上述第一个问题，微软编译器是引入了一个virtual base class table，object 只需要保存一个指向该表的指针，表中则保存一个或者多个virtual base class。 第二个方法，则是C++之父Bjarne比较喜欢的方法，在virtual function table中放置virtual base class的offset。也是间接调用，只是用的偏移地址。 这大概就是书中对虚拟继承的主要讨论，为了节约空间，就必须引入间接特性，牺牲一些调用性能，现在的编译器对于该问题的实现方式都是大同小异。 C++ 对象模型 Function 语意这一节，我们主要探讨一下C++对象模型中的函数调用，也就是虚函数表(v-table)。 还是上面那部分代码示例，我们做一下其他测试。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Base&#123;public: int ib; char cb; static int is;public: Base() : ib(0), cb('B') &#123;&#125; virtual void f() &#123; cout &lt;&lt; "B::f()" &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; "B::g()" &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; "B::h()" &lt;&lt; endl; &#125;&#125;;int Base::is = 10;class Derive : public Base&#123;public: int id; char cd;public: void g() &#123; cout &lt;&lt; "derive::g" &lt;&lt; endl; &#125;&#125;;int main()&#123; // 检测对象的vptr是在对象尾地址还是首地址 if ((int *)&amp;b == (int *)&amp;b.ib) &#123; cout &lt;&lt; "vPtr is in the end of class object: " &lt;&lt; (int *)&amp;b.ib &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "vPtr is in the head of class object: " &lt;&lt; (int *)&amp;b &lt;&lt; " " &lt;&lt; (int *)&amp;b.ib &lt;&lt; " " &lt;&lt; (int *)&amp;b.cb &lt;&lt; endl; &#125; typedef void (*Func)(void); cout &lt;&lt; "Derive: " &lt;&lt; endl; Base *d = new Derive(); long *vptr = (long *)*(long *)d; // 64 位系统, 指针长度为8字节, 首先获取到 v-table 的首地址 Func f = (Func)vptr[0]; // 通过函数指针转型 Func g = (Func)vptr[1]; Func h = (Func)vptr[2]; f(); g(); h(); cout &lt;&lt; "Base: " &lt;&lt; endl; Base *base = new Base(); long *vptr1 = (long *)*(long *)base; // 基类 v-table Func f1 = (Func)vptr1[0]; Func g1 = (Func)vptr1[1]; Func h1 = (Func)vptr1[2]; f1(); g1(); h1(); return 0;&#125; 我们首先测试一下对象中的vptr是在头部还是尾部，书中虚表指针有的是存放在类对象的头部，有的是存放在尾部, 这个视编译器而定。 程序打印如下：1234567891011vPtr is in the head of class object: 0x7ffef49f9890 0x7ffef49f9898 0x7ffef49f989cDerive: B::f()derive::gB::h()Base: B::f()B::g()B::h() 从打印结果得知 gcc 编译器的vptr是放在对象头部的，而且看最后的打印结果，我们可以知道对象和虚表结构大致如下： 我们还可以通过gdb去打印一下相关虚表的地址，和具体虚函数的地址进行比对，来看一下虚函数表的具体运作。1234(gdb) p (long *)vptr[0]$2 = (long *) 0x400f60 &lt;Base::f()&gt;(gdb) info line 61Line 61 of &quot;main.cpp&quot; starts at address 0x400f60 &lt;Base::f()&gt; and ends at 0x400f6c &lt;Base::f()+12&gt;. 至于多重继承和多重虚拟继承，调用方法类似，只是包含多个vptr，也都是通过vptr索引到相应的V-table，然后执行对应槽中的函数，这些都是在编译期就确定好的。 RTTI (Runtime Type Identification)C++的RTTI机制提供了一个安全的downcast设备， 但只对那些展现多态(也就是使用继承和动态绑定)的类型有效，那么编译器是如何知道这个类是符合多态的呢？ 没错，就是通过声明一个或者多个 virtual functions 来区分，在C++中，一个具备多态性质的 class，正是内含着继承而来的virtual functions。 实现上只需将与符合多态 class相关的RTTI object地址放进virtual table中，通常放在表的第一个位置，gcc下，我们可以通过虚函数表的-1项来访问。 C++ 提供了两个运算符 dynamic_cast 和 typeid 来进行 RTTI 操作。 typid 使用结合虚函数表访问 -1项，进行类型对比，会发现类型是一致的。12345678#include &lt;typeinfo&gt; // 其余代码同前面 // 获得type_info对象的指针，并调用其name成员函数 cout &lt;&lt; "\t[-1]: " &lt;&lt; ((type_info *)(vptr1[-1]))-&gt;name() &lt;&lt; " " &lt;&lt; typeid(base).name() &lt;&lt; endl; 打印如下：1[-1]: 4Base P4Base 打印结果中出现一些其他字符，如4，P4，是由于C++为了保证每一个类在程序中都有一个独一无二的类名，所以会对类名通过一定的规则进行改写，是正常的。 dynamic_cast 转型操作123456789//其余代码同上Base *d = new Derive();// 向下转型，判断是否转型成功// d 要有虚函数，否则会编译出错Derive* dd = dynamic_cast&lt;Derive *&gt;(d);if(NULL != dd)&#123; dd-&gt;g();&#125; 总结整体上看，我们会发现，如果不考虑virtual function和虚拟继承的影响，当数据都在同一个访问标识符下，C++的类与C语言的结构体在对象大小和内存布局上是一致的，C++的封装并没有带来空间时间上的影响。对于虚函数和虚拟继承，我们使用时需要知道它会给我们带来哪些额外负担，以此更好的评估是否需要将其引入，通过上面的总结与分析，C++对象模型应该就大致清楚了。当然&lt;&lt;深度探索 C++ 对象模型&gt;&gt;的书中很多讨论分析方案，虽然最终没有引入到实际中来，但是其分析的思路是很有价值的。 参考 &lt;&lt;深度探索 C++ 对象模型&gt;&gt;https://www.tuicool.com/articles/iUB3Ebihttps://coolshell.cn/articles/12165.htmlhttps://www.cnblogs.com/hushpa/p/5707475.htmlhttps://blog.csdn.net/ljianhui/article/details/46487951]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[春节回家]]></title>
    <url>%2F2019%2F02%2F06%2F%E6%98%A5%E8%8A%82%E5%9B%9E%E5%AE%B6%2F</url>
    <content type="text"><![CDATA[春节回家 小镇上一个新的景点，最近在朋友圈疯狂刷屏，宋风刘家秀美乡村建设点，定位是力争建成省级4A级秀美乡村。 这几天回家过年，感觉家里好冷啊，1月31日在厦门的时候，气温是25度，一到南昌，气温骤降十几度，整个人都不好了，回家后赶紧把提前准备的秋衣秋裤穿上了。 回到小镇，最引入关注的莫过于小镇上多了一个小景点，过年这几天可以说是火到不行，遇谁都说，你有去过那个宋风刘家景点吗？ 朋友圈里面，亲戚、朋友、同学也都各种晒照。 我也在回来第二天就去逛了一圈，走的路可以说比我一整年走的路都多了，整体感觉风景很不错，这片地方好像每年回来都要去走一圈。放几张照片感受一下（图片均来自朋友圈，哈哈）。 是不是感觉很不错，这一块本来风景就很好，依水而居，非常有江南水乡的味道，也许这本来就是乡村该有的模样。 家乡改变回到江西，印象最深的，应该是南昌西客站的长途客运这一块，比以前好太多了，基本可以做到临时自助购票，候车厅完全封闭，不会有外面的”黄牛”到里面拉客了，井然有序。 还有就是国家对孤寡老人的关怀补助这一块，可以说是做的非常不错了，听爷爷说的，和他同岁的一些孤寡老人，国家每年补助6000多，而且还免费给房屋进行修缮，引起爷爷的一阵感慨，现在的人们生活不要太幸福，从这几年各个地方都开始新修祠堂就可以看出来了，人民的获得感确实在提高，哈哈，去年我外婆那边就把祠堂给翻新了一下，老妈作为外嫁子女还贡献了绵薄之力。 hexo 管理说说这两天做的事吧，刚到家，看之前留在家里的那台笔记本电脑已经开不了机了，一直蓝屏，提示磁盘有问题，看到这个，二话不说，直接重装系统，刚开始用的是那种一键 ghost 的系统镜像，然后发现装不了，因为系统的磁盘驱动有问题，访问不了磁盘，然后导致装机软件都跑不起来，最后是用 UltraISO 软碟通这个软件，用U盘做了一个系统盘，直接安装原始的 windows 系统镜像， ok 搞定。 然后就是更新博客了，之前也有想过到其他电脑上要更新博客怎么办？ 这次是在原来博客的 git 发布分支上创建了一个分支 hexo，专门用来存放源文件，后续如果在其他电脑上想更新博客，只需在电脑上装一下nodejs和git，然后到git hub上把hexo分支拉取下来，安装一下npm install, 然后就可以开始更新博客了。 大概以下几步： 安装 nodejs 和 git git clone https://github.com/Yejy813/Yejy813.github.io.git git checkout hexo npm install hexo, npm install, npm install hexo-deployer-git 写博客 推送到git hub 的 hexo 分支。 指令： git add , git commit ，git push orgin hexo 生成发布版本，推送到github。指令：hexo d 总结与新年目标首先，祝愿所有的同学朋友新的一年身体健康，万事如意。 2018总结 工作，今年承担的事情很多，部门主要项目都参与了，并且负责主要模块的开发维护以及部分模块重构、性能优化的工作，相对前两年来说更辛苦一些，但是学到的东西也多了很多；工作上需要做的更好的地方，一个是效率需要进一步提高，工作的安排上需要更合理(多线程工作，这点必须要处理好)。 博客，基本有在不间断的更新，是一个好的开始，持续性需要再加强一点，写博客是唯一一个倒逼我们自己去学习新东西的方式，学习是生命线，这个行业不可能一技终老。 锻炼，后面 4 个月，基本就没有再去锻炼过了，一直工作整个人感觉会很压抑，过年回来前一天，去了一次健身房，锻炼了一次，身体感觉舒服多了。 生活，工作比较忙，然后平时吃饭也是在食堂吃，去年我都没有自己做过饭，平时也不去游泳、锻炼了，唉，主要是因为想要换工作的原因吧，感觉做什么都没心情，书倒是买了不少，也看了不少电子书加纸质书。 总结成一句话，就是 2018 工作还好，生活不易。 2019目标展望 年后，尽快开始面试之旅，三月底前，完成工作变更 (重中之重) 博客需要更新 70 篇，按照每两周三篇左右计算的，工作量合适 锻炼，一周维持两次，就算不力量训练，跑步也行 生活，尽量吧，感情，尽量吧 至于书单之类的，因为现在还在家，所以不能及时总结更新，后续再更新一下吧，新年需要看的书单。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMake]]></title>
    <url>%2F2019%2F01%2F26%2FCMake%2F</url>
    <content type="text"><![CDATA[CMake 介绍 CMake 是一个开源的跨平台工具系列，旨在构建，测试和打包软件。 CMake 用于使用简单的平台和独立于编译器的配置文件来控制软件编译过程，并生成可在你选择的编译器环境中使用的本机 makefile 和工作空间。 CMake 是个开源的跨平台自动化建构系统，它用组态文档控制建构过程（build process）的方式和 Unix 的 Make 相似，只是 CMake 的组态文档取名为 CMakeLists.txt。CMake 并不直接建构出最终的软件，而是产生标准的建构档（如 Unix 的 Makefile 或 Windows Visual C++ 的 projects/workspaces），然后再依一般的建构方式使用。这使得熟悉某个集成开发环境（IDE）的开发者可以用标准的方式建构他的软件。CMake 可以编译源代码、制作程序库、产生适配器（wrapper）、还可以用任意的顺序建构可执行文件。CMake 支持 in-place 建构（二进档和源代码在同一个目录树中）和 out-of-place 建构（二进档在别的目录里），因此可以很容易从同一个源代码目录树中建构出多个二进档。CMake 也支持静态与动态程序库的建构。 CMake 特点主要有： 开放源代码，使用类 BSD 许可发布。 https://cmake.org/licensing 跨平台，并可生成 native 编译配置文件，在 Linux/Unix 平台，生成 makefile，在苹果平台，可以生成 xcode，在 Windows 平台，可以生成 MSVC 的工程文件。 能够管理大型项目。我所在公司的项目代码就是用 CMake 构建的，代码量大概 140 万行。 简化编译构建过程和编译过程。CMake 的工具链非常简单：cmake+make。 高效虑，相对其他构建体系，构建速度上有优势。 可扩展，可以为 CMake 编写特定功能的模块，扩充 CMake 功能。 CMake 缺点 CMake 很简单，但是没有想象中的简单，比如知乎网友神评论：”屠龙的英雄，自己也已经成为了龙”。CMake 编写的过程实际就是编程的过程，我们编写的是 CMakeLists.txt (每个目录一个), 使用的是 “CMake 语言和语法”。 项目构建步骤： 为每个代码目录编写 CmakeLists.txt。 执行命令“cmake PATH”或者“ccmake PATH”生成 Makefile ( PATH 是 CMakeLists.txt 所在的目录 )。 使用 make 命令进行编译。 看构建步骤是不是感觉 CMake 很简单，相对于 MakeFile 编写来说确实如此，想想看, 如果一份代码中包含数十个 Project，然后每个 Project 中文件夹数目也很多，这时候我们如果使用 MakeFile 构建整份代码，那我们需要编写的依赖项会十分繁重且复杂，想想都头大，但是 CMake 却能够通过简单且直观的 cmake-commands 来帮你编写出你想要的 MakeFile 文件，最后只需简单的执行一步 make 指令，便可以完成整份代码的编译。反正我自从开始写 CMake 以后，就不写 MakeFile 了。 CMake 安装CMake 目前已经成为各大 Linux 发行版提供的组件，基本不需要我们手动安装，Linux 系统下，执行 cmake --version，如果可以看到版本号，就说明已经安装, 如果觉得版本太旧，想要更新，可以从官网下载。 https://cmake.org/download/ CMake 官方文档CMake 为我们提供了一个官方文档，其中将 CMake 整体进行了一下内容的划分，该文档可以作为我们的一个帮助手册，仅仅作为查阅指令的功能，因为官方并没有为我们提供使用的 example，而是提供了 CMake 的相关课程和书籍 &lt;&lt; mastering CMake &gt;&gt;，当然这些事需要付费的。 官方文档 (3.13版本)： https://cmake.org/cmake/help/v3.13/index.html 具体目录如下： Command-Line Tools 提供了三种命令行工具，除了cmake，还有测试和打包工具 cmake(1) ctest(1) cpack(1) Interactive Dialogs 交互式对话，一般用命令行工具就够了 cmake-gui(1) ccmake(1) Reference Manuals 参考手册 cmake-buildsystem(7) 构建系统 cmake-commands(7) 指令 cmake-compile-features(7) 编译功能 cmake-developer(7) 为开发人员修改 cmake 源代码树本身以及创作外部维护模块的人员参考 cmake-env-variables(7) 环境变量 cmake-generator-expressions(7) cmake 生成器表达式 cmake-generators(7) cmake 生产器 cmake-language(7) 语言 cmake-modules(7) 模块 cmake-packages(7) 包 cmake-policies(7) 策略 cmake-properties(7) 属性 cmake-qt(7) qt相关 cmake-server(7) 服务器 cmake-toolchains(7) 工具链 cmake-variables(7) 变量 cpack-generators(7) cpack 生成器 Release Notes CMake Release Notes 发布版本说明 列出这个目录，只是为了提醒，我们需要有阅读英文文档的能力，因为开源项目基本都是以英文形式发布的，所以我们必须养成习惯，不懂得地方借助 google 翻译，慢慢就能看懂了。 这边有位博友翻译过，可以参考一下：https://www.cnblogs.com/coderfenghc/archive/2012/06/16/CMake_ch_01.html Hello CMake下面从最简单的程序介绍如何构建 CMake 工程，然后慢慢引入 CMake 的各项特性。 C++代码先使用 CMake 尝试构建单文件的工程，工程只有 main.cpp 一个文件：123456#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; "Hello CMake!" &lt;&lt; std::endl; return 0;&#125; CMakeLists.txt在 main.cpp 的同一目录下，新建一个文本文件，命名为 CMakeLists.txt，内容如下：12345678project(Hello_CMake)cmake_minimum_required (VERSION 2.8.12) set(SRC_FILES main.cpp)add_executable(hellocmake $&#123;SRC_FILES&#125; ) 解释一下上面的 CMake: CMake 中，以命令为单位执行动作，命令不区分大小写。project 命令声明工程的名称，同时会添加一些变量（支持的语言，不写默认支持所有），CMake 管理的每个工程都需要有 project 命令。cmake_minimum_requried 声明最小要求，可以是 CMake的版本，也可以是其他的条件，这里要求使用 CMake 最低版本为2.8.12 。set 命令用来给设置变量，set 的第一个参数为变量名，其后的所有参数都将放入到这个变量中，参数可以有多个，需要注意与命令不同，CMake 的变量是区分大小写的。add_executable 命令可以增加一个目标来生成可执行文件，第一个参数为目标名称，之后的参数为源代码文件列表，源代码可以有多个。例子中使用了变量内容作为源代码，也可以直接填上源代码路径。如果在 CMakeLists.txt 中需要引用变量中的内容，需要使用 ${Var} 来展开，如例子中的 ${SRC_FILES} 将会展开成main.cpp ，如果不使用 ${}，SRC_FILES 将会被当做一般的字符串处理。 编译CMake 支持原地编译和分离编译两种方法编译，分离编译可以使编译中间文件和最终文件和源代码分离，便于源代码的管理，所以CMake 这里介绍分离编译方法。我的源代码和CMakeLists.txt放在cmakedemo目录下。 先将工作目录切换到源代码目录的上一层cd ..创建一个编译目录，并进入该目录mkdir buildcmakedemo &amp;&amp; cd buildcmakedemo在该目录下使用cmake配置工程，生成makefilecmake ../cmakedemo使用make编译工程make在编译目录下就生成了hellocmake，./hellocmake可以执行。cmake命令可以解析CMakeLists.txt生成makefile，还可以传入给项目一些变量，控制编译过程，在后面会详细介绍。 最终的目录结构：12345[root@yejy cmakedemo]# tree.|-- buildcmakedemo # 编译目录`-- cmakedemo # 源代码目录 `-- main.cpp 子目录和库多数工程是分为多个模块的，每个模块处在不同的目录中，CMake 中可以使用命令 add_subdirectory 添加子目录，子目录继承父目录所有的属性和变量。现在为我们的 HelloCMake程序加点料。 在源代码目录新建文件夹 child，在 child 中新建源代码文件 lib.cpp 内容如下123456#include &lt;iostream&gt;void call_child()&#123; std::cout &lt;&lt; "Oh My Lady Gaga!" &lt;&lt; std::endl; return 0;&#125; 在 child 下创建文本文件 CMakeLists.txt，内容如下：12345set(SRC_FILES lib.cpp)add_library(child $&#123;SRC_FILES&#125;) add_library 命令与 add_executable 类似，但生成的是库文件，CMake 默认会生成静态库，如果需要生成动态库，可以目标名后添加 SHARED 关键字，add_library(child SHARED ${SRC_FILES})，这样就会生成动态库。 我们还要为 child 这个库提供一个头文件，在 child 目录下新建一个头文件lib.h，然后在文件中声明call_child()。1void call_child(); 修改 main.cpp 使用 child 库，main.cpp 修改后如下：123456789#include &lt;iostream&gt;#include &lt;lib.h&gt;int main()&#123; std::cout &lt;&lt; "Hello CMake!" &lt;&lt; std::endl; call_child(); return 0;&#125; 为了让编译器知道如何查找头文件 lib.h 和让连接器知道 hellocmake 需要库 child，我们需要修改根目录下的CMakeLists.txt：1234567891011121314151617project(Hello_CMake)cmake_minimum_required(VERSION 2.8.12) set(SRC_FILES main.cpp)# 新增：添加子目录的CMakeLists.txt，以及包含 child 文件目录add_subdirectory(child)include_directories(child)add_executable(hellocmake $&#123;SRC_FILES&#125; ) # 新增：链接 child 库target_link_libraries(hellocmake child ) 解释一下上面的 CMake: 如前面提到的 add_subdirectory 会添加一个子目录到工程中，CMake 会解析子目录中的 CMakeLists.txt 为子目录生成MakeFile。include_directories 命令相当于 gcc 命令的 -I，告诉编译器到该目录中查找头文件。target_link_libraries 命令相当于gcc的-l命令，告诉连接器连接这个库，第一个参数为生成的目标名称，后面可以跟项目中其他库的目标名称或者已经存在的库文件名，查找规则和gcc -l一致。编辑完成后就可以到第三步的编译目录中再次执行 cmake 和 make 生成 hellocmake。这个hellocmake使用child库输出了文本Oh My Lady Gaga!。注：当然，我们也可以使用find_package 交叉编译CMake 会默认使用本机的编译器来配置项目，如果需要交叉编译，需要设定变量 CMAKE_C_COMPILE 和 CMAKE_CXX_COMPILE，可以通过 cmake 命令的 -D 参数传入,-D 参数可以给 CMake 传入变量，格式为 -DVar=Value。切换工作目录到第三步建立的编译目录中。 执行命令:1cmake ../cmakedemo -DCMAKE_C_COMPILER=arm-linux-gnueabi-gcc -DCMAKE_CXX_COMPILER=arm-linux-gnueabi-g++。 执行 make 编译工程，就可以在编译目录得到 arm 平台下的 hellocmake 程序。 CMAKE_C_COMPILE和 CMAKE_CXX_COMPILE 也可以在 CMakeLists.txt 中使用 set命令设定，需要注意的是，由于project 命令会根据这这两个变量设定一些其他的变量，所以它们应该在 project 命令前被设定。 修改源代码目录的 CMakeLists.txt：12345678910111213141516171819# 设置编译平台参数set(CMAKE_C_COMPILER arm-linux-gnueabi-gcc)set(CMAKE_CXX_COMPILER arm-linux-gnueabi-g++)project(Hello_CMake)cmake_minimum_required(VERSION 2.8.12) set(SRC_FILES main.cpp)add_subdirectory(child)include_directories(child)add_executable(hellocmake $&#123;SRC_FILES&#125; ) target_link_libraries(hellocmake child ) 到编译目录下执行 cmake 和 make 也可以得到 arm 平台下的 hellocmake。 CMake 进阶CMake 有一整套完备的编译控制体系，拥有繁多的命令和预置变量，这一节将选取一些较常用的命令做简单介绍，其具体使用和其他未介绍到的可以浏览官方文档。官方文档详细介绍了包括 cmake 命令本身和 CMakeLists.txt 中使用的所有命令和变量。在 cmake 安装包中也有相应的 man 文档，cmake 命令也有--help-command 参数可以查阅各命令的用法。 通用变量1、CMAKE_BUILD_TYPE这个变量可以控制程序的生成模式，可以留空，也可以选择这四种模式：Release，MinSizeRel，Debug，RelWithDebInfo。 Release模式下打开-O2开关。 MinSizeRel模式下打开-Os开关。 Debug模式打开-g开关。 RelWithDebInfo模式同时打开-O2和-g开关。 2、CMAKE_VERBOSE_MAKEFILE控制编译命令是否可见，设置这个变量为 ON 将会在 make 时看到编译命令，所有编译时加入的参数和编译的文件都将打印出来，便于校验 CMakeLists.txt 的正确性。 3、CMAKE_SOURCE_DIR指向工程源代码根目录，如使用 cmake ../cmakedemo 配置工程时，CMAKE_SOURCE_DIR 的值就是 ../cmakedemo的路径。 4、CMAKE_BINARY_DIR指向编译目录，如前一节的例子，CMAKE_BINARY_DIR 的值就是 buildcmakedemo 的路径。 编译阶段命令及变量1、add_definitions添加编译器参数的命令，相当于直接在编译时直接在编译命令上添加参数，需要注意这个命令不影响链接时的参数。如使用 g++ 编译时，添加命令add_definitions(-std=c++11)会让编译时使用&quot;g++ -std=c++11&quot;命令，但是连接时没有&quot;-std=c++11&quot;。 2、CMAKE_C_FLAGS这个命令也是在编译命令上添加参数，与 add_definitions 不同的是这个命令有兄弟命令，可以在不同模式下添加不同的参数： CMAKE_C_FLAGSCMAKE_C_FLAGS_DEBUGCMAKE_C_FLAGS_MINSIZERELCMAKE_C_FLAGS_RELEASECMAKE_C_FLAGS_RELWITHDEBINFO 分别对应所有模式、Debug模式、MinSizeRel模式、Release模式和RelWithDebInfo模式。对应 C++ 语言的变量只要把变量名第二段的C换成CXX即可。 3、configure_file这个命令用于传递CMake变量给语言，在跨平台编译中比较常用。其格式为：1configure_file(&lt;input&gt; &lt;output&gt; [COPYONLY] [ESCAPE_QUOTES] [@ONLY] [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF]]) 命令将会拷贝input到output并将其中的${var}和@var@换成对应CMAKE中的变量。由于在一些语言中${var}已经被占用，所以CMake添加了@var@这种表示方法，在命令中添加关键字@ONLY可以仅替换文件中的@var@，${var}会被忽略。 例如，我们可以在代码中这样定义：12#define HAS_BOOST $&#123;BOOST_FOUND&#125;#define HAS_PTHREAD @PTHREAD_FOUND@ 在CMakeLists.txt中使用命令：1configure_file($&#123;CMAKE_BINARY_DIR&#125;/cfg.h $&#123;CMAKE_SOURCE_DIR&#125;/cfg.in.h) 假设BOOST_FOUND和PTHREAD_FOUND都被定义为1，执行cmake后，构建目录将会生成一个cfg.h文件，内容为：12#define HAS_BOOST 1#define HAS_PTHREAD 1 如果configure_file命令添加了@ONLY则${BOOST_FOUND}将会被忽略，config.h内容则变为：12#define HAS_BOOST $&#123;BOOST_FOUND&#125;#define HAS_PTHREAD 1 4、系统变量 1,CMAKE_MAJOR_VERSION，CMAKE 主版本号，比如 2.4.6 中的 2。2,CMAKE_MINOR_VERSION，CMAKE 次版本号，比如 2.4.6 中的 43,CMAKE_PATCH_VERSION，CMAKE 补丁等级，比如 2.4.6 中的 64,CMAKE_SYSTEM，系统名称，比如 Linux-2.6.22。5,CMAKE_SYSTEM_NAME，不包含版本的系统名，比如 Linux。6,CMAKE_SYSTEM_VERSION，系统版本，比如 2.6.227,CMAKE_SYSTEM_PROCESSOR，处理器名称，比如 i686.8,UNIX，在所有的类 UNIX 平台为 TRUE，包括 OS X 和 cygwin。9,WIN32，在所有的 win32 平台为 TRUE，包括 cygwin。 5、aux_source_directory这个命令可以搜索某个目录所有的源代码文件，添加到变量里，其格式为aux_source_directory(&lt;dir&gt; &lt;variable&gt;)，多次对同一变量使用该命令，可以将不同目录的源代码都保存到变量中。对于一些在同一目录下放有很多源代码的工程，使用这个命令可以很方便地获取所有需要编译的文件。 在前一节的例子中，在源代码根目录使用命令 aux_source_directory(. SRC_FILES)就把main.cpp的路径添加到SRC_FILES变量中。 6、file(GLOB_RECURSE …)file是文件操作命令，有基本的文件功能，这里介绍文件查找功能。file有两种模式可以查找文件，一个是GLOB，另一个是GLOB_RECURSE，GLOB只会查找当前目录下的文件，GLOB_RECURSE会查找当前目录和子目录下的文件。命令格式如下：12file(GLOB variable [RELATIVE path] [globbing expressions]...)file(GLOB_RECURSE variable [RELATIVE path] [FOLLOW_SYMLINKS] [globbing expressions]...) 命令默认会保存文件的绝对路径，如果需要相对路径，可以用关键字RELATIVE加上需要获取相对于哪个目录的路径来获取相对路径，但是官方不推荐获取相对路径。填写 globbing expressions（通配符）可以简单过滤文件。 如前一节的例子，使用 file(GLOB SRC_FILES *.cpp) 可以获取到 main.cpp 的路径，使用 file(GLOB_RECURSE SRC_FILES *.cpp) 可以获取到 main.cpp 和 child/lib.cpp 的路径。 链接阶段命令及变量1、CMAKE_C_LINK_FLAGES与 CMAKE_C_FLAGS 家族类似，模式下的细分变量，其内容将添加在连接器的参数上。 2、link_directories设置库查找位置，相当于 gcc 的 -L，可以同时设置多个目录。 安装阶段命令及变量1、install大型项目中，会编译出来很多个模块，每个模块都在各自的文件夹中，不方便发布，install 命令可以指定目标的安装位置，install 可以安装多种文件，这里只介绍安装 CMake 目标的安装方法，CMake 主要有 add_executable 和 add_library 命令创建的目标，都可以使用:1234install(TARGETS target1 target2 LIBARARY DESTINATION lib ARCHIVE DESTINATION lib/static RUNTIME DESTINATION bin) 这里的安装位置需要加上下面提到的变量 CMAKE_INSTALL_PREFIX ，默认情况下 Linux的 CMAKE_INTALL_PREFIX=/usr，使用 make install 命令将会把可执行文件目标安装到 /usr/bin下。 2、CMAKE_INSTALL_PREFIX工程安装位置，为 install 命令使用目录的前缀，Linux下默认为/usr。 3、CMAKE_INSTALL_RPATH设定安装后可执行文件的运行目录，相当于 gcc 的 -Wl,rpath 在交叉编译时比较常用。 分支结构和逻辑运算cmake有完备的流程控制机制，有一般编程语言常用的if分支结构，也有foreach循环结构，这里介绍一下if分支结构，if用法如下：1234567if(expression) COMMAND(ARGS ...)elseif(expression2) COMMAND(ARGS ...)else(expression) COMMAND(ARGS ...)endif(expression) expressin 填入真值表达式，变量为 0, OFF, NO, FALSE, N, IGNORE, NOTFOUND、以-NOTFOUND结尾或未定义的值为false，其他为 true。 注意: else 和endif的expression可以忽略，但是必须带上括号。if内可以使用比较运算比较两个变量获得真值： 常用的数值运算有:1,EQUAL: 相等2,LESS：小于3,GREATER：大于常用的字符串运算：1,STRLESS：字符串小于。2,STRGREATER：字符串大于3,STREQUAL：字符串等于4,MATCHES：正则表达式匹配此外还有文件比较等功能，可自行查阅官方文档。多条表达式可以使用逻辑运算NOT、AND和OR连接起来，这几个运算符优先级和C语言的逻辑运算符不同，所以推荐使用括号来明确运算顺序。 find_package 查找外部库我们前面已经讲过如何链接外部库，上面提到的方法是显式调用，也就是我们知道库和头文件的位置，直接通过include_directories和target_link_libraries将库文件链接进来。现在我们介绍一下另一种方式find_package。 find_package能查找本机安装的外部库，并获取对应的环境和变量。其常用形式为：1find_package(&lt;package&gt; [version] [REQUIRED]) 我们以Qt库为例，如果需要Qt库，那先要使用命令find_package(Qt4 REQUIRED)来获取Qt的相关变量，由于Qt库是必须的，所以加上REQUIRED关键字。 find_package会调用cmake安装目录的shared目录下的FindQt4.cmake来设置Qt变量，同时添加一些函数和宏。使用这些变量和宏就可以编译Qt工程。 系统中FindQt4.cmake目录:1/usr/local/share/cmake-3.3/Modules/FindQt4.cmake find_package查找Qt成功后，会定义一下常用变量：123QT_FOUND: 是否找到QT_LIBRARIES：Qt所有库的路径，在target_link_libraries时添加。QT_INCLUDES: Qt 头文件路径 对于系统预定义的 Find.cmake 模块，每一个模块都会定义以下几个变量: • &lt; name&gt;_FOUND• &lt; name&gt;_INCLUDE_DIR or &lt; name&gt;_INCLUDES• &lt; name&gt;_LIBRARY or &lt; name&gt;_LIBRARIES其中的name为find_package中的package参数 找到外部模块后，我们便可以将外部模块链接进来： 123456find_package(Qt4 REQUIRED)if(QT_FOUND) include_directories($&#123;QT_INCLUDE_DIR&#125;) target_link_libraries($&#123;project_name&#125; $&#123;QT_LIBRARIES&#125;)end() 实用的 CMake 封装下面列一些实用的 CMake 封装，后续持续更新！ 1、自动检测 C++ 版本参数12345678910111213# using C++ newest feature, auto test Cxx versioninclude(CheckCXXCompilerFlag)foreach(cxx_feature_name "c++20" "c++2a" "c++17" "c++1z" "c++14" "c++1y" "c++11" "c++0x") set(cxx_feature_flag "-std=$&#123;cxx_feature_name&#125;") string(REPLACE "+" "x" cxx_feature_suffix $&#123;cxx_feature_name&#125;) CHECK_CXX_COMPILER_FLAG($&#123;cxx_feature_flag&#125; COMPILER_SUPPORTS_$&#123;cxx_feature_suffix&#125;) if(COMPILER_SUPPORTS_$&#123;cxx_feature_suffix&#125;) set(CMAKE_CXX_FLAGS "$&#123;CMAKE_CXX_FLAGS&#125; $&#123;cxx_feature_flag&#125;") message(STATUS "The compiler $&#123;BUILDTOOL_PREFIX&#125;-g++ has $&#123;cxx_feature_name&#125; support") break() endif()endforeach() 2、库文件安装123456789101112# 设置安装路径set(CMAKE_INSTALL_PREFIX "$&#123;CMAKE_BINARY_DIR&#125;/output")message("Install prefix: $&#123;CMAKE_INSTALL_PREFIX&#125;")# project用的库文件安装函数function(target_install OBJECTS) install(TARGETS $&#123;OBJECTS&#125; RUNTIME DESTINATION bin ARCHIVE DESTINATION lib LIBRARY DESTINATION lib )endfunction() 3、将所有包含CMakeLists.txt的子目录添加进来 123456789101112131415161718192021222324# Add all subdirectories that exist CMakeLists.txtinclude(CMakeParseArguments)function(add_all_subdirectories) cmake_parse_arguments(SUBDIR "" "" "EXCLUDE" $&#123;ARGN&#125;) file(GLOB ALL_FILES *) foreach(subdir $&#123;ALL_FILES&#125;) if((IS_DIRECTORY $&#123;subdir&#125;) AND (EXISTS $&#123;subdir&#125;/CMakeLists.txt)) file(RELATIVE_PATH relPath $&#123;CMAKE_CURRENT_SOURCE_DIR&#125; $&#123;subdir&#125;) if(SUBDIR_EXCLUDE) list(FIND SUBDIR_EXCLUDE $&#123;relPath&#125; _index) if (_index EQUAL -1) add_subdirectory($&#123;subdir&#125;) elseif(CMAKE_DEBUG) message("Exclude [$&#123;relPath&#125;] when add_all_subdirectories") endif() else() add_subdirectory($&#123;subdir&#125;) endif() endif() endforeach()endfunction() 总结CMake 大概就总结到这里，总的来说这个工具还是十分不错的，整体结构清晰明了，后续的话，就着力把一些好的小的功能点，封装成函数或者宏，记录下来，以后碰到需要用了，就可以直接拿来用，基本可以做到一劳永逸。 参考 &lt;&lt; cmake 实践 &gt;&gt;]]></content>
      <tags>
        <tag>编译 (compile)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GDB]]></title>
    <url>%2F2019%2F01%2F23%2FGDB%2F</url>
    <content type="text"><![CDATA[What is GDB? 官方文档： https://sourceware.org/gdb/download/onlinedocs/ GDB 是 GNU 项目的调试器，你可以用 GDB 查看另一个程序在执行过程中的内部内容, 或者在程序崩溃时，查看程序当时正在执行的操作。 (gdb) set print address on(gdb) f 0#0 Request::process (this=0x7fffffffe690) at /home/willy/myshare/thread-pool/DeadLock_Test/main.cpp:8 8 &emsp; PosixThread::MutexLockGuard &lt; PosixThread::MutexLock &gt; lock(mutex_);(gdb) 上述指令表示，当程序显示函数信息时，GDB 会显出函数的参数地址，然后调用 f &lt;n&gt; 或 frame &lt;n&gt;, 表示查看当前栈层的信息。在我看来，查看栈层信息以及打印相关变量的地址，是 GDB 最为有用的地方。 GDB 主要做四件事情(以及支持这些事情的其他事情)，来帮助你捕捉程序中的错误： 1. 启动程序，指定可能影响其行为的任何内容。2. 使程序在指定条件下停止。3. 当程序停止时，检查发生了什么。4. 更改程序中的内容，以便您可以尝试纠正一个错误的影响并继续了解另一个错误。 这些程序可能与 GDB 在同一台机器上，或者另一台机器（远程）或模拟器上执行。 GDB 可以在大多数流行的 UNIX 和 Microsoft Windows 变体上运行，也可以在 Mac OS X 上运行。 What Languages does GDB Support?GDB 支持以下语言（按字母顺序排列）： Ada Assembly C C++ D Fortran Go Objective-C OpenCL Modula-2 Pascal Rust GDB 本机调试首先我们总结一下 GDB 本机调试，也就是可执行程序和 GDB 跑在同一台机器上, 这也是我们最为常见的一种方式。1. 编译 GDB 可调试的程序我用 GDB 主要调试 C/C++ 程序，为了将调试信息加到可执行文件中，我们需要用到 gcc编译器提供的 -g 参数，具体编译方法如下： Make g++&emsp;-g&emsp;-Wall&emsp;hello.cpp&emsp;-o&emsp;hello CMake： set(CMAKE_BUILD_TYPE&emsp;”Debug”)set(CMAKE_CXX_FLAGS_DEBUG&emsp;”$ENV{CXXFLAGS}&emsp;-O0&emsp;-Wall&emsp;-g2&emsp;-ggdb”) #替换 Debug 版本参数 启动下面是程序的启动，启动操作主要有三种： 1.直接加载可执行程序1gdb &lt;program&gt; # program 为你编译的可执行程序 2.调试可执行程序的同时，将 core 文件加入其中12# 注意：core 文件是已经生成的 coredump，如何生成coredump后面介绍。gdb &lt;program&gt; core 3.当你调试正在运行的进程, 可以通过该指令附着（attach）到进程中调试。1gdb &lt;program&gt; &lt;PID&gt; 当然我们也可以执行 gdb 指令，然后通过 file &lt;program&gt;来加载可执行程序的符号。 例如：123456789101112[root@yejy build]# gdb output/bin/dead_lock.exx # 采用方式1, 直接加载可执行程序GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-94.el7Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;...Reading symbols from /home/willy/myshare/thread-pool/build/output/bin/dead_lock.exx...done.(gdb) 设置断点12345678# 在进入指定函数时停住。C++ 可以使用class::function或function(type,type)格式来指定函数名。break &lt;function&gt;# 在源文件filename的linenum行处停住。break filename：linenum# 在源文件filename的function函数的入口处停住。break filename：function 例如：123# 将断点设置在 main 函数(gdb) b main # break简写Breakpoint 1 at 0x40143d: file /home/willy/myshare/thread-pool/DeadLock_Test/main.cpp, line 25. 程序运行与单步调试较常用指令是如下四个：123456789101112# 程序开始运行run# 恢复程序运行，直到程序结束，或是下一个断点到来。ignore-count表示忽略其后的断点次数。continue，c命令意思相同。continue [ignore-count]c [ignore-count]# 单步跟踪，如果有函数调用，会进入该函数, count 表示连续执行count条，然后停止，否则一条一条执行。step &lt;count&gt;# 单步跟踪，如果有函数调用，不会进入该函数，count 同上。next &lt;count&gt; 例如：12345678910(gdb) run # 开始执行Starting program: /home/willy/myshare/thread-pool/build/output/bin/dead_lock.exx [Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib64/libthread_db.so.1&quot;.Breakpoint 1, main (argc=1, argv=0x7fffffffe128) at /home/willy/myshare/thread-pool/DeadLock_Test/main.cpp:2525 char* pBuff = nullptr;Missing separate debuginfos, use: debuginfo-install glibc-2.17-222.el7.x86_64 libgcc-4.8.5-28.el7_5.1.x86_64 libstdc++-4.8.5-28.el7_5.1.x86_64(gdb) n # next简写，执行下一条26 *pBuff = &apos;2&apos;; 分析栈信息当程序运行到断点时，我们需要查看程序在哪里停住了。当程序调用了一个函数，函数的地址，函数参数，函数内的局部变量都会被压入”栈”（Stack）中。我们可以使用 GDB 命令来查看栈中的信息。 1234567891011121314151617181920# 打印当前的函数调用栈的所有信息, n是一个正整数，表示打印栈顶上n层的栈信息, n可为负数，表示栈底。backtrace &lt;n&gt;bt &lt;n&gt;# 查看当前栈，一般来说，程序停止时，最顶层的栈就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是切换当前栈# 例: frame 0，表示栈顶，frame 1，表示栈的第二层。frame &lt;n&gt;f &lt;n&gt;# 这个命令会打印出更为详细的当前栈层的信息# 大多都是运行时的内存地址。比如：函数地址，调用函数的地址，被调用函数的地址，# 目前的函数是由什么样的程序语言写成的、函数参数地址及值、局部变量的地址等等info frameinfo f# 打印出当前函数的参数名及其值。info args# 打印出当前函数中所有局部变量及其值。info locals 测试代码：123456789101112131415161718192021222324252627282930class Request&#123;public: void process() const __attribute__((noinline)) &#123; PosixThread::MutexLockGuard&lt;PosixThread::MutexLock&gt; lock(mutex_); // .. Printf(); &#125; void Printf() const __attribute__((noinline)) &#123; PosixThread::MutexLockGuard&lt;PosixThread::MutexLock&gt; lock(mutex_); // .. &#125;private: mutable PosixThread::MutexLock mutex_;&#125;;int main(int argc, char *argv[])&#123; char* pBuff = nullptr; *pBuff = '2'; Request req; req.process(); return 0;&#125; GDB 调试打印：12345678910111213141516171819202122(gdb) backtrace # 查看所有调用栈#0 main (argc=1, argv=0x7fffffffe128) at /home/willy/myshare/thread-pool/DeadLock_Test/main.cpp:25(gdb) f # 查看当前调用栈#0 main (argc=1, argv=0x7fffffffe128) at /home/willy/myshare/thread-pool/DeadLock_Test/main.cpp:2525 char* pBuff = nullptr;(gdb) info f # 当前调用栈详细信息Stack level 0, frame at 0x7fffffffe050: rip = 0x40143d in main (/home/willy/myshare/thread-pool/DeadLock_Test/main.cpp:25); saved rip 0x7ffff6ded445 source language c++. Arglist at 0x7fffffffe040, args: argc=1, argv=0x7fffffffe128 Locals at 0x7fffffffe040, Previous frame&apos;s sp is 0x7fffffffe050 Saved registers: rbx at 0x7fffffffe038, rbp at 0x7fffffffe040, rip at 0x7fffffffe048(gdb) info args # 函数参数argc = 1argv = 0x7fffffffe128(gdb) info locals # 函数局部变量pBuff = 0x401340 &lt;_start&gt; &quot;1\355I\211\321^H\211\342H\203\344\360PTI\307\300`\030@&quot;req = &#123;mutex_ = &#123;mutex_ = &#123;__data = &#123;__lock = -138651536, __count = 32767, __owner = 15775487, __nusers = 0, __kind = 1, __spins = 0, __elision = 0, __list = &#123; __prev = 0x40183d &lt;__libc_csu_init+77&gt;, __next = 0x7fffffffe040&#125;&#125;, __size = &quot;pX\274\367\377\177\000\000\377\266\360\000\000\000\000\000\001\000\000\000\000\000\000\000=\030@\000\000\000\000\000@\340\377\377\377\177\000&quot;, __align = 140737349703792&#125;, holder_ = 0&#125;&#125; 查看源码12345678# 显示程序第linenum行的周围的源程序。list &lt;linenum&gt;# 显示函数名为function的函数的源程序。list &lt;function&gt;# 设置一次默认显示源代码的行数。set listsize &lt;count&gt; 例如：1234567891011(gdb) list23 int main(int argc, char *argv[])24 &#123;25 char* pBuff = nullptr;26 *pBuff = &apos;2&apos;;27 (gdb) set listsize 2 # 一次显示两行(gdb) list28 Request req;29 req.process();(gdb) 设置显示选项123456789# 当程序显示函数信息时, GDB会显示出函数的参数地址.set print addressset print address on# printf pretty这个选项，那么当GDB显示结构体时会比较漂亮.set print pretty on# 当此选项打开时，GDB将用比较规整的格式来显示虚函数表.set print vtbl &lt;on/off&gt; 例如：12345678910(gdb) show print addressPrinting of addresses is on.(gdb) f # argv 有地址#0 main (argc=1, argv=0x7fffffffe128) at /home/willy/myshare/thread-pool/DeadLock_Test/main.cpp:2525 char* pBuff = nullptr;(gdb) set print address off(gdb) f # argv 无地址#0 main (argc=1, argv=) at /home/willy/myshare/thread-pool/DeadLock_Test/main.cpp:2525 char* pBuff = nullptr;(gdb) GDB 中运行 UNIX 的 shell 程序在 GDB 环境中，我们可以执行 UNIX 的 shell 命令来完成一些操作, 包括 Make/CMake。1shell &lt;command string&gt; 例：12345678910111213(gdb) shell ls # ls指令3rdlib bin CMakeCache.txt CMakeFiles cmake_install.cmake DeadLock_Test install_manifest.txt lib Makefile output src unit_mock unit_test(gdb) shell cmake .. -DENABLE_DEBUG=ON -DENABLE_TEST=ON # 执行cmake指令-- The compiler -g++ has c++1y supportInstall prefix: /home/willy/myshare/thread-pool/build/outputCMAKE_CXX_FLAGS : -std=c++1yCMAKE_CXX_FLAGS_DEBUG : -O0 -Wall -g2 -ggdbCMAKE_CXX_FLAGS_RELEASE : -O3 -WallBuild Type: Debug-- Configuring done-- Generating done-- Build files have been written to: /home/willy/myshare/thread-pool/build(gdb) 调试 coredump 文件Linux 平台下在一个程序崩溃时，它一般会在指定目录下生成一个 core 文件，core 文件仅仅是一个内存映象(同时加上调试信息)，使用 GDB 来查看 core 文件，可以指示出导致程序出错的代码所在文件和行数。 首先我们需要生成 core 文件1.查看当前系统是否能生成 core 文件, 如果显示为 0 则说明当前系统不会生成 core 文件，需要运行 unlimited 操作：12345# 查看当前允许生产 core 文件大小ulimit -c# 将 core 文件大小设置为不限制大小ulimit -c unlimited 2.设置 core 文件输出路径core 文件默认输出到程序运行的目录，也可以更改为其他目录(目录一定要可写)：1echo &quot;/tmp/core&quot; &gt;/proc/sys/kernel/core_pattern 运行以上命令后，core 文件会输出到 /tmp 目录下，名称为 core.进程ID，比如进程308挂掉后生成的 core 文件为/tmp/core.308。 注：运行以上命令的 shell 一定要和运行程序的 shell 是同一个 3.GDB 调试 core 文件我们使用 gdb &lt;program&gt; core 的启动方式来调试，这样等于在问题出现后，现场已经不存在的情况下，我们也可以进行调试，很管用。当然在正常系统环境中生成 coredump 文件的方式各有不同，原理都是获得其函数调用栈地址，然后通过 address2line 具体定位到某个函数，某一行代码。 我们通过例子来说明，我在代码中加入下面两句，导致函数出现段错误：12char* pBuff = nullptr;*pBuff = '2'; 执行程序：123456789101112131415161718192021222324[root@yejy build]# ./output/bin/dead_lock.exx 段错误(吐核)[root@yejy build]# ls /tmp/core.4209 # 生成了一个 core 文件/tmp/core.4209[root@yejy build]# gdb output/bin/dead_lock.exx /tmp/core.4209 # 使用 gdb 执行程序并且调试 core 文件GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-94.el7Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;...Reading symbols from /home/willy/myshare/thread-pool/build/output/bin/dead_lock.exx...done.[New LWP 4209][Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib64/libthread_db.so.1&quot;.Core was generated by `./output/bin/dead_lock.exx&apos;.Program terminated with signal 11, Segmentation fault.#0 0x0000000000401449 in main (argc=1, argv=0x7ffd573c8518) at /home/willy/myshare/thread-pool/DeadLock_Test/main.cpp:26 26 *pBuff = &apos;2&apos;; # 直接就提示 26 行出现段错误Missing separate debuginfos, use: debuginfo-install glibc-2.17-222.el7.x86_64 libgcc-4.8.5-28.el7_5.1.x86_64 libstdc++-4.8.5-28.el7_5.1.x86_64(gdb) 查看 C++ 对象虚函数表我们前面在设置显示选项的时候，有设置显示虚函数表 set print vtbl &lt;on/off&gt;, 那具体是怎么查看呢？步骤如下：1234567891011# 设置可显示set print vtbl on# 打印所有虚函数地址info vtbl pObject# 打印某一个虚函数p /a (*(void ***)pObject)[0]@10 # /a 表示 16 进制打印；10表示打印的虚函数个数# 查看相应地址的符号info symbol 0x80486c8 线程123456# 断点只对指定线程生效，该线程执行到该断点停止后，所有线程会一起停止，方便我们调试。break &lt;linespec&gt; thread &lt;threadno&gt;break &lt;linespec&gt; thread &lt;threadno&gt; if ...# 上面的 threadno 是 gdb 分配的，我们可以通过下面这个查看线程 id。info threads 查阅帮助12345678# 列出 gdb 指令种类help# GDB 指令详细帮助gdb -help# 一般指令help &lt;command&gt; 上述讲解了在工作中最为常用的一些 GDB 指令，总体可以覆盖整个调试流程，当然GDB 还有非常多的其他指令，需要我们去发掘并使用，这个只能祈祷工作中可以多遇到些问题，然后尝试使用 GDB 去解决，这样我们才可以学到更多东西，掌握更多的调试手段。 如果还想更细致的了解 GDB 指令，可以查看如下链接： http://wiki.ubuntu.org.cn/index.php?title=%E7%94%A8GDB%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F&amp;variant=zh-cn GDB 远程调试远程调试过程，真正的调试指令和本地调试基本一致，主要区别在于调试环境不一样，需要事先搭建。我们会用到远端系统使用的gdbserver 和本机使用的 gdb，大概介绍一下整体的流程。 编译 gdbserver 和 gdb这一步需要对 gdb 和 gdbserver 做一下交叉编译，一般相应平台的gdb公司内部都会有编译好的，直接用就可以，如果需要编译，大致流程如下：12345678910111213141. 将gdb-7.6.tar.gz拷贝到虚拟机/opt目录下2. 解压缩：cd /opttar -xzvf ./ gdb-7.6.tar.gz3. 创建gdb build目录（最好一个编译器建立一个build目录，不然容易出错） mkdir -p xxx-gdb/build4. 配置gdb平台参数，生成makefile cd xxx-gdb/build/opt/gdb-7.6/configure --target=arm-linux-gnueabi --prefix=/opt/xxx-gdb注：此处不用定义(--host)，host 是编译 Linux 版本的程序，会默认以 gcc 编译的，target是定义目标系统的版本5. 编译gdb make&amp;&amp; make install# gdbserver类似 环境配置将 GDB 加入到环境变量：123vi /etc/profile在文件的末尾加入以下语句： export PATH=/opt/xxx/bin:/opt/xxx-gdb/bin/:$PATH 保存/etc/profile文件后运行一下. /etc/profile或重新连接shell 具体使用首先在远程调试机器上运行gdbserver，假设是 mnt 目录（该目录一般为挂载目录），2345为任意端口(保证之前没用过就行)，然后Exe.exx 为你需要运行的程序, 指令大概如下：12345/mnt/gdb/gdbserver localhost:2345 /mnt/bin/Exe.exx # 执行完，大概提示这个：Process /mnt/bin/Exe.exx created; pid = 497Listening on port 2345 接着在你的编译机器(可能是虚拟机或者编译服务器)上，使用 gdb 跑你的可执行程序，然后远程连接到远端的 IP:port 就可以了，大致如下所示：123456789101112131415#首先使用你的 xxx-gdb 跑你的程序xxx-gdb # 链接相关库，因为生产中，不可能就一个可执行程序，需要链接大量的动态库和静态库set solib-absolute-prefix /lib/set solib-search-path /lib/# 加载可执行程序符号，Exe.exx 和远程服务器上执行的是同一个file ./bin/Exe.exx# 编译虚拟机(或编译服务器)上的 gdb 与远程机器上的 gdbserver 连接。 10.3.3.243为 IP，2345 为你设置的端口target remote 10.3.3.243:2345# 执行你的程序run 或者 break function （设置断点什么的，或者直接跑） 总之，远程调试主要是加入了一个gdbserver，用做远程系统上的服务程序，来和编译服务器上的 gdb 进行通信，其他调试手段和本机调试基本一致。 总结GDB常用知识大概就是这些，如果都掌握吸收了，一般的生产工作基本没有什么问题，可以很好的解决遇到的问题，当然这只是 GDB 所有内容中的一部分，没有官方文档那样细致，所以如果想要更加深入的了解其他 GDB 指令，请参阅官方文档。 还有就是像前面那篇参考文章中提到的，编写 GDB 脚本来自动调试我们编写的程序，我觉得吧，虽然想法很美好，但是实用性可能不会太高，一个是编写调试脚本的工作成本是一个问题，然后该脚本所适用的调试场景可能也会比较特殊、通用性不够，导致整体成本会比较高。当然如果把编写调试脚本当做一种对 GDB 深入了解的方法，倒是非常不错，这样可以很好的提升我们的 Debug 能力与思维。 参考链接 http://wiki.ubuntu.org.cn/index.php?title=%E7%94%A8GDB%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F&amp;variant=zh-cn]]></content>
      <tags>
        <tag>GNU Software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MakeFile 编写]]></title>
    <url>%2F2019%2F01%2F20%2Fmake%2F</url>
    <content type="text"><![CDATA[程序的编译与链接1234567891011# Top level makefile, the real shit is at src/Makefiledefault: all.DEFAULT: cd src &amp;&amp; $(MAKE) $@install: cd src &amp;&amp; $(MAKE) $@.PHONY: install GNU Make 是一个工具，它从程序的源文件中控制程序的可执行文件和其他非源文件的生成。 C、C++ 程序在编译的时候，首先要把源文件编译成中间代码文件，在 Windows 下也就是 .obj 文件， UNIX 下是 .o 文件，即 Object File，这个动作叫做编译（compile），然后再把大量的 Object File 合成执行文件，这个动作叫作链接（link）。在编译时，编译器只检测程序语法，和函数、变量是否被声明，而在链接程序时，链接器会在所有的 Object File 中找寻函数的实现，如果找不到，就会报链接错误。 make 则是一个工具，MakeFile 类似是一个脚本文件，文件中定义了一系列的规则来告诉 make 需要如何去编译和链接程序。 MakeFile 概述MakeFile 组成Makefile 里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。 1、显式规则。显式规则说明了，如何生成一个或多个的目标文件。这是由 Makefile 的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。2、隐晦规则。由于我们的 make 有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写 Makefile，这是由 make 所支持的。3、变量的定义。在 Makefile 中我们要定义一系列的变量，变量一般都是字符串，这个有点像 C 语言中的宏，当 Makefile 被执行时，其中的变量都会被扩展到相应的引用位置上。4、文件指示。其包括了三个部分，一个是在一个 Makefile 中引用另一个 Makefile，就像 C语言中的 include 一样；另一个是指根据某些情况指定 Makefile 中的有效部分，就像 C 语言中的预编译#if 一样；还有就是定义一个多行的命令。5、注释。 Makefile 中只有行注释，和 UNIX 的 Shell 脚本一样，其注释是用“#”字符。 还有一点需要注意，在 Makefile 中的命令，必须要以[Tab]键开始。 MakeFile 工作方式GNU 的 make 工作时的执行步骤如下： 1、读入所有的 Makefile。2、读入被 include 的其它 Makefile。3、初始化文件中的变量。4、推导隐晦规则，并分析所有规则。5、为所有的目标文件创建依赖关系链。6、根据依赖关系，决定哪些目标要重新生成。7、执行生成命令。 MakeFile 使用书写规则用一个示例来说明 MakeFile 的书写规则，以便给大家一个感性认识。示例来源于 gnu 的 make 使用手册，这个示例中，我们的工程有8个c文件，和3个头文件，我们要写一个 MakeFile 来告诉 make 命令如何编译和链接这几个文件。我们的规则是： 1）如果这个工程没有编译过，那么我们的所有c文件都要编译并被链接。2）如果这个工程的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。3）如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序。 MakeFile 写得够好，所有的这一切，我们只用一个 make 命令就可以完成，make 命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。 MakeFile 的书写规则：1234target ... : prerequisites ...command...... target 也就是一个目标文件，可以是 Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”中会有介绍。prerequisites 就是要生成那个 target 所依赖的文件或是目标。command 也就是 make 需要执行的命令。（任意的 Shell 命令） 这是一个文件的依赖关系，意思是， target 这一个或多个的目标文件依赖于 prerequisites 中的文件，其生成规则定义在 command 中。说白一点就是说， prerequisites 中如果有一个以上的文件比 target 文件要新的话， command 所定义的命令就会被执行。这就是 Makefile 的规则，也就是 Makefile 中最核心的内容。 正如前面所说的，如果一个工程有3个头文件，和8个c文件，我们为了完成前面所述的那三个规则，我们的 Makefile 如下： 反斜杠（\）是换行符的意思，这样比较便于makefile的易读。我们可以把这个内容保存在名字为 “makefile” 或 “Makefile” 的文件中，然后在该目录下直接输入命令 “make” 就可以生成执行文件 edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下 “make clean” 就可以了。 上图中是最原始的写法，其中有很多变量是重复出现的，我们可以新增 变量 以及根据 make 的 自动推导，来简化 Makefile。 引入变量objects： GNU 的 make 很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。 只要 make 看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果 make 找到一个 whatever.o，那么 whatever.c，就会是 whatever.o 的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的 makefile 再也不用写得这么复杂。 最新的 makefile： 编译C时，.o 的目标会自动推导为 .cMakefile 中12main : main.o gcc -o main main.o 会自动变为:12345main : main.o gcc -o main main.omain.o: main.c &lt;-- main.o 这个目标是隐含生成的 gcc -c main.c log 打印我们可以使用 info / warning / error 打印日志。123456789$(error text…)$(warning text…)$(info text…)# To print variables,$(error VAR is $(VAR))$(warning VAR is $(VAR))$(info VAR is $(VAR))# when you use 'error' the make execution will stop after showing the error string 例如：输出： 变量1. 变量赋值 2. 变量替换3. 变量追加值 +=4.变量覆盖5.目标变量 前缀 伪目标“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以 make 无法生成它的依赖关系和决定它是否要执行。为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向 make 说明，不管是否有这个文件，这个目标就是“伪目标”123.PHONY: clean --&gt; 最好加上，以免和文件名冲突clean: rm *.o temp 伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的 Makefile 需要一口气生成若干个可执行文件，但你只想简单地敲一个 make 完事，并且，所有的目标文件都写在一个 Makefile 中，那么你可以使用“伪目标”这个特性：12345678all: prog1 prog2 prog3.PHONY: allprog1: prog1.o utils.o cc -o prog1 prog1.o utils.oprog2: prog2.o cc -o prog2 prog2.oprog3: prog3.o sort.o utils.o cc -o prog3 prog3.o sort.o utils.o 总结MakeFile 主要思想就是依赖关系，判断依赖文件更新，来执行相关 command。MakeFile 对于一些工程结构简单的代码，可以很好的胜任组织编译链接工作，但是当工程非常大的时候(代码目录繁多，层次错综复杂)，手写 MakeFile 会非常麻烦，而且 MakeFile 是类 Unix 平台（平台相关）上的工具，，如果换一个平台(windows、android等)，又需要重新编写其他编译链接脚本，因此，在开发生产中，建议使用跨平台编译工具 CMake。 主要参考书籍 &lt;&lt; 跟我一起写 MakeFile &gt;&gt; 官方文档：http://www.gnu.org/software/make/manual/make.html#Reading]]></content>
      <tags>
        <tag>编译 (compile)</tag>
        <tag>GNU Software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 多线程编程]]></title>
    <url>%2F2019%2F01%2F12%2FC-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[多线程编程123456789101112131415161718192021class MutexLock&#123;public: MutexLock(); ~MutexLock(); MutexLock(const MutexLock &amp;mutex) = delete; MutexLock &amp;operator=(const MutexLock &amp;mutex) = delete; void lock(); void unlock(); bool IsLockedByThisThread() const; pthread_mutex_t *getPthreadMutex();private: friend class Condition;private: pthread_mutex_t mutex_; pid_t holder_;&#125;; 这段时间，主要在分析和整理多线程相关的内容，主要是因为工作中我有负责部门基础库的开发维护，其中就包括线程库，然后近期要在组内做异步这一块的分享，所以也希望趁这个机会对这一块知识进行系统的梳理，然后自己也将 posix-thread 线程重新使用了一下，加深印象，基本覆盖到了相关关键接口的使用。加上之前已经对 线程概念，以及 同步和互斥 做了一下总结，所以整体来说，对多线程已经有了一个比较系统的认识。 具体C代码见： https://github.com/Yejy813/posix-thread C++ 封装 Posix-thread最近把陈硕老师 muduo 网络库中多线程部分的代码阅读了一遍，同时把其中的 MutexLock, MutexLockGuard, Condition, AtomicIntegerT, CountDownLatch, Thread 等多线程构件代码敲了一编，同时写了一些测试程序，并将封装思路和注意点加入到注释中，相当于对多线程做了一个总结，加深了对多线程的理解。 具体C++代码见： https://github.com/Yejy813/posix-thread-cplusplus 总结通过 posix-thread 的使用和封装，你会发现，其实多线程相关工具接口的使用并不难，只要我们提前制定好使用规则，将异步操作模块化的提供给业务层使用，提供一种异步机制，内部可能是使用线程池等方式对所有线程进行管理，就可以很好的降低多线程的使用难度，以此更好的避免多线程相关的问题；那么提供完异步机制，那就只剩一个问题，如果我们在异步中对共享资源进行访问，如何做到同步互斥，以及尽可能高的效率，这又是我们需要考虑的另一个问题，用 互斥锁，自旋锁，原子操作，还是条件变量，或者是由这些底层同步机制衍生出来的，更高级的同步构件，这些是需要我们仔细的去思考和设计的。 多线程的概念和实现就先分析这么多，后续会对 C++ 11 中提供的线程库以及 Java 多线程相关的知识进行关注和深入学习，C++ 11 中的多线程库，我觉得会是一个趋势，首先它是官方的，跨平台的，资料相应会较多，而且统一，所以会更好些 ，当然封装一套多线程库也不难，现在各个公司如果还是使用 Linux 原生的线程接口，那么各自都会根据业务需求，做不同程度的封装，这是历史原因造成的，但是我们要向前看；至于 java 多线程，主要是其对一些多线程工具类的封装思路，是值得借鉴的，C++ 多线程相关确实需要向 java 语言学习，毕竟 C++ 语言直到 C++11 才提供自己的线程库。]]></content>
      <tags>
        <tag>多线程编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 单元测试框架-gtest]]></title>
    <url>%2F2019%2F01%2F02%2Fgoogletest%2F</url>
    <content type="text"><![CDATA[Unit Test 和 gtest 介绍 单元测试（ Unit Test ，模块测试）是开发者编写的一小段代码，用于检验被测代码的一个很小的、很明确的功能是否正确，通过编写单元测试可以在编码阶段发现程序编码错误，甚至是程序设计错误。 单元测试不但可以增加开发者对于所完成代码的自信，同时，好的单元测试用例往往可以在 回归测试 的过程中，很好地保证之前所发生的修改没有破坏已有的程序逻辑。因此，单元测试不但不会成为开发者的负担，反而可以在保证开发质量的情况下，加速迭代开发的过程。GoogleTest是一个跨平台的(Liunx、Mac OS X、Windows、Cygwin、Windows CE and Symbian) C++ 单元测试框架，GoogleTest由 google 公司发布, 且遵循 New BSD License（可用作商业用途）的开源项目, 为当前比较主流的 C++ 单元测试框架，目前所在公司也在使用。 gtest 安装、导入项目（Linux系统）下载源码我本地使用的系统参数：12bash-4.2$ uname -aLinux yejy 3.10.0-514.el7.x86_64 #1 SMP Tue Nov 22 16:42:41 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux gtest github 地址： https://github.com/google/googletest 下载源码：1bash-4.2$ git clone https://github.com/google/googletest 导入项目简单测试下载源码后，接着就是将其导入到我们的项目中使用，如果你只是想简单测试一下，可以直接编译 gtest 源码，生成相应的静态库，将库和头文件拷贝到系统的头文件和库中，然后就可以直接写代码进行测试了，步骤如下： 12345bash-4.2$ cd googletestbash-4.2$ cmakebash-4.2$ makebash-4.2$ cp libgtest*.a /usr/lib bash-4.2$ cp –a include/gtest /usr/include 写一个简单的测试程序：123456789101112131415#include&lt;gtest/gtest.h&gt;int add(int a, int b)&#123; return a+b;&#125;TEST(testCase, test0)&#123; EXPECT_EQ(add(4,3), 7); // 断言检测两参数是否相等&#125;int main(int argc, char **argv)&#123; testing::InitGoogleTest(&amp;argc, argv); // 初始化，所有测试都是这里启动的 return RUN_ALL_TESTS(); // 运行所有测试用例&#125; 编译代码，当然你可以用 make 或者 cmake 编译都可以，具体输出：123456[==========] Running 1 test from 1 test case.[----------] Global test environment set-up.[----------] 1 test from testCase[ RUN ] testCase.test0[ OK ] testCase.test0 (0 ms)[----------] 1 test from testCase (0 ms total) 工业生产上面这种测试方法比较特殊，等于是把 gtest 库和 gnu c 库一样使用了，正常工作项目中，肯定不会这样用的。 正确的做法是 以第三方库的形式直接将源码引入进项目。可能有人就会说了，为什么一定要将源代码引入其中，而不先编译出静态库，然后导入其中呢，这样编译自己项目的时候不就不用再重新编译了吗？ 这里主要是考虑 跨平台，编译环境会有多种，需要多次编译，因此需要源码导入，同宿主项目一起编译。 我比较熟悉的编译工具是 cmake, 工作中使用的也是这个，该工具也是跨平台的，在编译大型跨平台项目时，很有优势，那这边就大致讲一下引入步骤，如果你对 cmake 很熟悉，那这边就很轻松了。 首先看一下引入后的代码结构，如下图： 重点是这个文件 unit_test/CMakeLists.txt ：1234567891011121314151617181920212223242526file(GLOB SRC_FILES ./*.cpp)file(GLOB HEADER_FILES ./*.h)# 将给定目录添加到编译器用于搜索包含文件的目录中。相对路径被解释为相对于当前源目录。# 相当于gcc命令的-I，告诉编译器到该目录中查找头文件include_directories($&#123;CMAKE_SOURCE_DIR&#125;/src)if(ENABLE_TEST) include_directories( $&#123;CMAKE_SOURCE_DIR&#125;/3rdlib/googletest/googlemock/include $&#123;CMAKE_SOURCE_DIR&#125;/3rdlib/googletest/googletest/include )endif()# 生成可执行文件 posix_thread_test.exx add_executable(posix_thread_test.exx $&#123;SRC_FILES&#125; )# 引入 gtest 库，posixthread 为源代码库target_link_libraries(posix_thread_test.exx gtest posixthread )target_install(posix_thread_test.exx) 导入项目，主要就是看 unit_test/CMakeLists.txt 这个文件了，其他基本变化不大，如果你熟悉 cmake 很容易就能看懂。 至于图中的源码，是最近在封装 Posix-thread 时写的，源码大部分引用了陈硕老师的 muduo 网络库中的线程相关代码。 gtest 具体使用介绍一下断言，断言主要用来做一些逻辑判断，主要有以下两类接口: ASSERT_XXX()： 如果断言失败，则测试处理终止。 EXPECT_XXX()： 非致命性失败，允许继续处理。 Test Fatal NonFatal condition 为真 ASSERT_TRUE(condition) EXPECT_TRUE(condition) condition 为假 ASSERT_FALSE(condition) EXPECT_FALSE(condition) Equal ASSERT_EQ(arg1,arg2) EXPECT_EQ(arg1,arg2) Not Equal ASSERT_NE(arg1,arg2) EXPECT_NE(arg1,arg2) Less Than ASSERT_LT(arg1,arg2) EXPECT_LT(arg1,arg2) Less Than or Equal ASSERT_LE(arg1,arg2) EXPECT_LE(arg1,arg2) Greater Than ASSERT_GT(arg1,arg2) EXPECT_GT(arg1,arg2) Greater Than or Equal ASSERT_GE(arg1,arg2) EXPECT_GE(arg1,arg2) C String Equal ASSERT_STREQ(str1,str2) EXPECT_STREQ(str1,str2) C String Not Equal ASSERT_STRNE(str1,str2) EXPECT_STRNE(str1,str2) C String Case Equal ASSERT_STRCASEEQ(str1,str2) EXPECT_STRCASEEQ(str1,str2) C String Case Not Equal ASSERT_STRCASENE(str1,str2) EXPECT_STRCASENE(str1,str2) Verify that exception is thrown ASSERT_THROW(statement,exception_type) EXPECT_THROW(statement,exception_type) Verify that exception is thrown ASSERT_ANY_THROW(statement) EXPECT_ANY_THROW(statement) Verify that exception is NOT thrown ASSERT_NO_THROW(statement) EXPECT_NO_THROW(statement) 测试代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;gtest/gtest.h&gt;#include &lt;posix_thread.h&gt;void threadFunc()&#123; std::cout &lt;&lt; "tid= "&lt;&lt; PosixThread::CurrentThread::tid() &lt;&lt; std::endl;&#125;TEST(PosixThreadTest, CreateThread)&#123; std::cout &lt;&lt; "pid= " &lt;&lt; ::getpid() &lt;&lt; " tid= " &lt;&lt;PosixThread::CurrentThread::tid() &lt;&lt; std::endl; PosixThread::Thread t1(threadFunc); t1.start(); ASSERT_TRUE(t1.started()); EXPECT_FALSE(t1.started()); // 故意失败 ASSERT_FALSE(t1.started()); // 故意失败 std::cout &lt;&lt; "t1.tid: " &lt;&lt; t1.tid() &lt;&lt; std::endl; std::cout &lt;&lt; "thread name: " &lt;&lt; t1.name().c_str() &lt;&lt; std::endl; t1.join(); std::cout &lt;&lt; "CreateThread end !\n" &lt;&lt; std::endl;&#125;TEST(AtomicTest, AtomicInt64)&#123; std::cout &lt;&lt; "pid= " &lt;&lt; ::getpid() &lt;&lt; " tid= " &lt;&lt;PosixThread::CurrentThread::tid() &lt;&lt; std::endl; PosixThread::AtomicInt64 a0; ASSERT_EQ(a0.get(), 0); ASSERT_EQ(a0.getAndAdd(1), 0); ASSERT_EQ(a0.get(), 1); ASSERT_EQ(a0.addAndGet(2), 3); ASSERT_EQ(a0.get(), 3); ASSERT_EQ(a0.incrementAndGet(), 4); ASSERT_EQ(a0.get(), 4); a0.increment(); ASSERT_EQ(a0.get(), 5); ASSERT_EQ(a0.addAndGet(-3), 2); ASSERT_EQ(a0.getAndSet(100), 2); ASSERT_EQ(a0.get(), 100);&#125; 执行结果：12345678910111213141516171819202122232425262728293031bash-4.2$ ./output/bin/posix_thread_test.exx [==========] Running 2 tests from 2 test cases.[----------] Global test environment set-up.[----------] 1 test from PosixThreadTest[ RUN ] PosixThreadTest.CreateThreadpid= 5297 tid= 5297tid= 5298/home/willy/myshare/thread-pool/unit_test/thread_test.cpp:16: FailureValue of: t1.started() Actual: trueExpected: false/home/willy/myshare/thread-pool/unit_test/thread_test.cpp:17: FailureValue of: t1.started() Actual: trueExpected: false[ FAILED ] PosixThreadTest.CreateThread (0 ms)[----------] 1 test from PosixThreadTest (0 ms total)[----------] 1 test from AtomicTest[ RUN ] AtomicTest.AtomicInt64pid= 5297 tid= 5297[ OK ] AtomicTest.AtomicInt64 (0 ms)[----------] 1 test from AtomicTest (0 ms total)[----------] Global test environment tear-down[==========] 2 tests from 2 test cases ran. (0 ms total)[ PASSED ] 1 test.[ FAILED ] 1 test, listed below:[ FAILED ] PosixThreadTest.CreateThread 1 FAILED TEST 从执行结果，我们可以很清楚的知道测试用例具体执行到哪一步，如果失败了，我们可以看到具体是哪一行代码出问题了，程序预期结果是什么，但是实际结果又是什么，输出十分详细。 我们还可以将测试结果导出到 xml 文件，通过参数：--gtest_output 实现。1234567891011121314151617181920bash-4.2$ ./output/bin/posix_thread_test.exx --gtest_output="xml:./test.xml"bash-4.2$ cat test.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;testsuites tests="2" failures="1" disabled="0" errors="0" timestamp="2019-01-04T21:36:40" time="0" name="AllTests"&gt; &lt;testsuite name="PosixThreadTest" tests="1" failures="1" disabled="0" errors="0" time="0"&gt; &lt;testcase name="CreateThread" status="run" time="0" classname="PosixThreadTest"&gt; &lt;failure message="/home/willy/myshare/thread-pool/unit_test/thread_test.cpp:16&amp;#x0A;Value of: t1.started()&amp;#x0A; Actual: true&amp;#x0A;Expected: false" type=""&gt;&lt;![CDATA[/home/willy/myshare/thread-pool/unit_test/thread_test.cpp:16Value of: t1.started() Actual: trueExpected: false]]&gt;&lt;/failure&gt; &lt;failure message="/home/willy/myshare/thread-pool/unit_test/thread_test.cpp:17&amp;#x0A;Value of: t1.started()&amp;#x0A; Actual: true&amp;#x0A;Expected: false" type=""&gt;&lt;![CDATA[/home/willy/myshare/thread-pool/unit_test/thread_test.cpp:17Value of: t1.started() Actual: trueExpected: false]]&gt;&lt;/failure&gt; &lt;/testcase&gt; &lt;/testsuite&gt; &lt;testsuite name="AtomicTest" tests="1" failures="0" disabled="0" errors="0" time="0"&gt; &lt;testcase name="AtomicInt64" status="run" time="0" classname="AtomicTest" /&gt; &lt;/testsuite&gt;&lt;/testsuites&gt; 此外，在运行可执行目标程序时，可以使用 --gtest_filter 来指定要执行的测试用例，支持字符串正则匹配，主要如下几种常用情况：123456./output/bin/posix_thread_test.exx 没有指定filter，运行所有测试；./output/bin/posix_thread_test.exx --gtest_filter=* 指定filter为*，运行所有测试；./output/bin/posix_thread_test.exx --gtest_filter=PosixThreadTest.* 运行测试用例FooTest的所有测试；./output/bin/posix_thread_test.exx --gtest_filter=*Null*:*Thread* 运行所有全名；./output/bin/posix_thread_test.exx --gtest_filter=PosixThreadTest.*-PosixThreadTest.CreateThread 运行测试用例FooTest的所有测试，但不包括PosixThreadTest.CreateThread。 gtest 还有很多方便你测试的功能，包括 事件机制, 参数化, 死亡测试, 运行参数等，我们点到为止，如果想继续深入，可以参考这位博主的 gtest 系列, 很详细：玩转Google开源C++单元测试框架Google Test系列 googlemock 使用googlemock，是用于编写和使用C++ 模拟类的框架，在我们工作中，主要用来模拟应用程序的一部分，在单元测试用例编写过程中，常常需要编写模拟对象来隔离被测试单元的“下游”或“上游”程序逻辑或环境，从而达到对需要测试的部分进行隔离测试的目的，它可以帮助我们获得更好的系统设计并编写更好的测试。googlemock 同样遵循 New BSD License（可用作商业用途）的开源项目。 在开发过程中，经常出现各联调模块间，进度不一的情况；测试环境非常不稳定，易导致测试失败，导致达不到单元测试的目的，模仿对象提供了解决这些问题的方法：模仿对象符合实际对象的接口，但只包含用来“欺骗”测试对象并跟踪其行为的必要代码。因此，其实现往往比实际实现类简单很多。 官方教程： https://github.com/google/googletest/blob/master/googlemock/docs/ForDummies.md 官方的 Tutorial 讲的很详细，我在github上也找了一个使用例子，很简洁，但是能很好的说明问题，大致代码如下：mail_service.h文件：123456789101112131415161718#ifndef MAIL_SERVICE_HPP#define MAIL_SERVICE_HPP/** \brief Mail service. This represents one of the collaborators of the SUT. * \author David Stutz */// 邮件服务class MailService&#123;public: /** \brief Send a mial. * \param[in] message message to send */ virtual void send(std::string message) = 0; &#125;;#endif /* MAIL_SERVICE_HPP */ order.h文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#ifndef ORDER_HPP#define ORDER_HPP#include &lt;string&gt;#include &lt;memory&gt;#include "warehouse.h"#include "mail_service.h"/** \brief An order of a product with quantity. */// 订单class Order&#123;public: /** \brief Constructor. * \param[in] quantity quantity requested * \param[in] product product name requested */ Order(int quantity, std::string product) &#123; this-&gt;quantity = quantity; this-&gt;product = product; &#125; /** \brief Set the mail service to use. * \param[in] mailService the mail service to attach */ // 设置邮件服务 void setMailService(std::shared_ptr&lt;MailService&gt; mailService) &#123; this-&gt;mailService = mailService; &#125; /** \brief Fill the order given the warehouse. * \param[in] warehouse the warehouse to use * \return whether the operation was successful */ // 判断产品是否有库存，发送邮件通知 bool fill(Warehouse &amp;warehouse) &#123; if (warehouse.hasInventory(quantity, product)) &#123; // ... warehouse.remove(quantity, product); this-&gt;mailService-&gt;send("Order filled."); return true; &#125; else &#123; // ... this-&gt;mailService-&gt;send("Order not filled."); return false; &#125; &#125; private: /** \brief Product name. */ std::string product; /** \brief Quantity requested. */ int quantity; /** \brief Mail service to use. */ std::shared_ptr&lt;MailService&gt; mailService;&#125;;#endif /* ORDER_HPP */ warehouse.h文件：1234567891011121314151617181920212223242526272829#ifndef WAREHOUSE_HPP#define WAREHOUSE_HPP#include &lt;string&gt;/** \brief Warehouse interface. This interface is one of the collaborators of our SUT. * \author David Stutz */class Warehouse&#123;public: /** \brief Check whether the product in the given quantity is on stock. * \param[in] quantity quantity requested * \param[in] product product name * \return whether the warehouse has the product on stock for the given quantity */ // 是否有库存 virtual bool hasInventory(int quantity, std::string product) const = 0; /** \brief Remove the given quantity of the product from the warehouse. * \param[in] quantity quantity to remove * \param[in] product product name to remove */ // 从库存中删除 virtual void remove(int quantity, std::string product) = 0; &#125;;#endif /* WAREHOUSE_HPP */ 主要场景就是处理产品订单，其中库存Warehouse类和邮件服务MailService类，我们只声明一下虚基类，不实现，然后通过模拟对象的方式mock一下Warehouse和MailService，来达到订单类接口测试的正常开展，具体测试代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;gmock/gmock.h&gt;#include "lib/mail_service.h"#include "lib/order.h"#include "lib/warehouse.h"using ::testing::Return;using ::testing::_; // Matcher for parametersclass MockWarehouse : public Warehouse&#123;public: // see https://github.com/google/googletest/blob/master/googlemock/docs/ForDummies.md MOCK_CONST_METHOD2(hasInventory, bool(int, std::string)); MOCK_METHOD2(remove, void(int, std::string));&#125;;class MockMailService : public MailService&#123;public: MockMailService() &#123; &#125; MOCK_METHOD1(send, void(std::string));&#125;;TEST(OrderTest, Fill)&#123; MockWarehouse warehouse; std::shared_ptr&lt;MockMailService&gt; mailService = std::make_shared&lt;MockMailService&gt;(); Order order(50, "Talisker"); order.setMailService(mailService); EXPECT_CALL(warehouse, hasInventory(50, "Talisker")) .Times(1) .WillOnce(Return(true)); EXPECT_CALL(warehouse, remove(50, "Talisker")) .Times(1); EXPECT_CALL(*mailService, send(_)) // Not making assumptions on the message send ... .Times(1); ASSERT_TRUE(order.fill(warehouse));&#125;int main(int argc, char **argv)&#123; testing::InitGoogleMock(&amp;argc, argv); // Runs all tests using Google Test. return RUN_ALL_TESTS();&#125; 测试结果：1234567891011bash-4.2$ ./output/bin/order.exx [==========] Running 1 test from 1 test case.[----------] Global test environment set-up.[----------] 1 test from OrderTest[ RUN ] OrderTest.Fill[ OK ] OrderTest.Fill (0 ms)[----------] 1 test from OrderTest (0 ms total)[----------] Global test environment tear-down[==========] 1 test from 1 test case ran. (1 ms total)[ PASSED ] 1 test. 其中main函数和gtest差不多，只是初始化的是googlemock，我们着重了解的是几个宏的含义: MOCK_METHOD1234MOCK_METHOD#1(#2, #3(#4) )MOCK_CONST_METHOD2(hasInventory, bool(int, std::string));MOCK_METHOD2(remove, void(int, std::string)); 其中#1表示你要mock的方法共有几个参数，#2是你要mock的方法名称，#3表示这个方法的返回值类型，#4是这个方法具体的参数。 EXPECT_CALL1234using ::testing::Return;EXPECT_CALL(warehouse, hasInventory(50, "Talisker")) .Times(1) .WillOnce(Return(true)); 设定期望对象被访问的方式及其响应，其中warehouse为对象，希望hasInventory在传递参数为(50, “Talisker”)时，被调用且仅被调用一次，第一次返回true。 ON_CALL12345ON_CALL(#1, #2(#3)).WillByDefault(Return(#4));ON_CALL(foo, GetSize()) .WillByDefault(Return(1)); // ... other default actions ... 其中#1表示mock对象，#2表示个方法名称，#3表示方法的参数，#4表示参数为#1, #2，#3情况下返回结果。 ON_CALL和EXPECT_CALL的区别? ON_CALL定义了调用mock方法时会发生什么，但并不意味着对被调用方法的任何期望。 EXPECT_CALL不仅定义了行为，还设置了对给定次数（以及在指定顺序时按给定顺序）使用给定参数调用方法的期望。 GoogleMock 为开发者设定 Mock 类行为，跟踪程序运行过程及结果，提供了丰富的支持。但与此同时，应用程序也应该尽量降低应用代码间的耦合度，使得单元测试可以很容易对被测试单元进行隔离。(尽量做到高内聚，低耦合) 总结Googletest 与 GoogleMock，很好的简化了我们的C++单元测试工作，本篇文章对此做了一个总结，让自己对gtest有了一个系统的认识。测试并不只是测试工程师的责任，对于开发工程师，为了保证发布给测试环节的代码具有足够好的质量（ Quality ），为所编写的功能代码编写适量的单元测试是十分必要的。 如果还想更加深入的了解，可查阅官方文档： https://github.com/google/googletest/tree/master/googlemock/docs 参考链接 https://www.ibm.com/developerworks/cn/linux/l-cn-cppunittest/?mhq=gtest&amp;mhsrc=ibmsearch_ahttps://blog.csdn.net/russell_tao/article/details/7344739http://www.cnblogs.com/coderzh/archive/2009/03/31/1426758.htmlhttps://github.com/davidstutz/googlemock-example]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你有困惑吗]]></title>
    <url>%2F2018%2F12%2F15%2F%E4%BD%A0%E6%9C%89%E5%9B%B0%E6%83%91%E5%90%97%2F</url>
    <content type="text"><![CDATA[工程师层级人员讨论会 – 2018-12-7 上周，部门主管黄总和HR组织了一场讨论会，召集了大概20个开发，大概水平都是处于工程师层级，这个层级评定和你工作年龄无关，而是和你的工作产出，负责项目相关。在我看来，过去的大部分都是业务骨干，因为基本涉及部门所有产品线的所有开发人员，有工作两年的，工作4年，5年，8年的。确实，软件开发和年龄其实关系不大，而是和你负责的业务，技术水平相关。如果你负责公司的核心业务开发，只要你能支撑下来，就算你工作年限不长，技术水平不广，不深，但是因为你处在这个位置上，因此你也很有价值，但是话又说回来，如果你工作很多年，还是处于这个层级，那就确实是要考虑一下了，因为你陷入了一个瓶颈，可能工作中80%-90%的时间都是做一些常规项目，而且是做完这一个接着又做下一个。 因此对于多年处于这个阶段的人来说，是安排的工作太简单了，得不到提高，还是干活的人想的太简单，这个需要自身考虑清楚。 今天讨论会主要分为两个阶段，第一阶段，首先大家分为4个小组，然后每个组讨论，将自己工作中遇到的困惑，瓶颈，以及一些需要外部协助的点(包括公司层面，其他部门等)列出来。 总的说下来，大概就是以下几点： 项目周期太紧，需求开发时间安排不合理，整个项目中，产品部需求评审耗费时间较长，需求评审时，测试部也参与，而测试部往往疑问较多，导致评审周期拉的很长。(克服方法：尽量线上解决或者只参与自己负责的需求; 提前熟悉相关需求，做到提前量) 项目中，分配的模块整改，代码重构时间较短。导致重构做的不彻底，挖的不够深，整体性能和设计上，做的效果不明显。(克服方法：尽量早的提出预研，拉长时间周期；如果是影响后续大版本开发的重构，那没办法，必须做) 多线程工作，一个人同一个时间身上负责多个项目。在日常工作中，因为参与项目较多，导致工作经常性的被人打断，在多个项目中切换，效率很低。(克服方法：分析问题和编码，做好整体思路存档标记，问题处理完回来可以无缝切回来；对于插入问题，预先进行分析评估，短时间解决不了，另行安排时间，不纠缠) 工作中做的 90% 多都是常规工作，技术提升的、绩效突破性工作安排较少。(克服方法：自己向上级反馈, 主动提出) 最后一点是我对自己提出的，接触的模块多，技术点也多，但是由于总结意愿不强烈，导致很多东西掌握的不够系统，不够深入，当然也有一部分时间上的限制就是了(项目紧，工作忙) (克服方法：加强写总结的习惯，反省自己) 与外部对接方面工作，推动力不足，主导意愿不强，很多时间往往浪费在沟通和踢皮球上，对工作毫无进展。(克服方法：改变态度，无论是现在公司，还是以后的工作中，对于参与工作，要与担当，积极主动的去推进) 上述大部分遇到的问题，都是很多公司的问题，并不是公司独有，黄总也说面试过很多人，这些问题都是客观存在的，如果你能把这些克服，做好，那提升会很明显，一句话，效率最重要。 第二个阶段，提出四个需求，让大家进行讨论，给出一个大致的想法，思考方式。每个组选择了同一个，如下： 需求1：公司一款产品，之前支持存储5000个联系人，现在客户反馈不够，需要能支持5万个。 最后大家讲了一遍，给出的总体流程和思路如下： 可行性分析，该产品之前支持5000个，现在要升级一个数量级，基于现有系统的内存和CPU频率，是否能够支持这么多联系人的存储、搜索工作。 需求分析，之前方案设计实现背景，是否可以在之前方案上直接进行拓展; 竞品和公司其他产品线是否有相关方案的支持，如果支持，是否可以直接借鉴和复用; 现在是要求5万，后续如果再升级到10万，30万，50万，选择的方案是否可以支持，需要向拓展性上考虑 在原有方案下拓展优化，还是说对整个框架进行重构，如果重构，是要引进什么新的技术吗? 数据库? 如果引入新的技术，那如何保证整个系统的鲁棒性和可移植性，因为后续可能不止你一个产品要用，可能将方案适配到多个平台上去。 方案选择好后，需要同相关涉及模块的开发人员，一起讨论，对外进行评审，排除各个模块的风险 设计文档编写，给出整体的思维导图，理清各模块间交互，保证方案的拓展性和易维护性，方案整体要在时间和空间上进行平衡，保证搜索和存储都较好满足，某些场景可能需要牺牲空间来满足搜索的速度，而某些相反，最后将相关接口评审完毕，进入开发 开发完成后，需要编写相关测试用例，包括引入相关测试框架进行单元测试，性能测试，内存检测等。编写测试导图，以便测试部能够更好的展开测试工作 异常场景考虑，在开发和自测过程中，要将异常场景考虑在内，如果采用的是云端联系人存储，临时拉取方案，那如果向服务器请求时，出现丢失该如何处理；在满载，高负载场景下，是否会有异常，UI表现是否正常；是否要加入相关请求的防抖动处理，一句话，开发人员也要有测试思维，加强异常极限场景考虑。 大概就是上面两个事，总的来说收获是有的，对于测试这一块还需要做的更好，相关开源测试框架和性能工具需要多加使用。总的来说，勤写总结，吾日三省吾身，找到效率瓶颈，提升效率，提升技术水平是没错的。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程间通信-消息队列]]></title>
    <url>%2F2018%2F11%2F24%2F%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-2018-11-24%2F</url>
    <content type="text"><![CDATA[Message Queue 使用场景今天介绍一下消息队列，对此做个总结，酝酿了有一段时间，因为消息队列在开发中占据了一个很重要的地位。 一般这种系统设施，如果你是在 Linux 系统用户空间进行开发(内核开发除外的所有开发)，需要懂得其原理、接口使用、消息框架构建机制、封装系统提供的 MQ 接口来对上层提供服务。如果你是从事内核开发，那还需要将这些系统设施的实现了解清楚。我现在做的是系统应用层开发，就以我现在公司为例，开发的是嵌入式系统设备，之前公司消息机制使用的是 Linux 系统自带的消息队列，System V 那一套，后来因为系统资源确实匮乏，如果直接使用原生的消息队列机制，并发量太高的话，系统性能会下降(因为芯片太低端，而使用消息队列的功能模块在增加)，所以自己开发了一套消息机制，实现思路以及对外接口和原来差别不大。本次主要介绍 System V 和 Posix 消息队列使用和与之相关的设计模式。 消息队列（Message Queue），不仅是分布式系统中重要的组件, 也是我们客户机系统开发中的一个重要组件，特别是我们公司现在开发的系统，可以说完全是由消息驱动的系统，无论是进程间，还是进程内部，消息队列的发布/订阅模式，支撑起了整个系统框架。 首先，消息队列的使用场景主要有以下几个： 异步处理 非核心流程异步化，提高系统响应性能。发布者只需将消息通知出去，然后就可以去做其他事情。 程序解耦 对于不强依赖于非本系统的核心流程，可以放到消息队列中让消息消费者去按需消费，而不影响核心主流程，做到业务功能模块解耦 广播 发布/订阅模式，一个消息，可以多个对象定阅处理 流量削峰与流控 对于网络秒杀活动，消息队列可做缓冲处理 1.请求先入消息队列，而不是由业务处理系统直接处理，做了一次缓冲,极大地减少了业务处理系统的压力； 2.队列长度可以做限制，事实上，秒杀时，后入队列的用户无法秒杀到商品，这些请求可以直接被抛弃，返回活动已结束或商品已售完信息； 消息驱动的系统 避免直接调用下一个系统导致当前系统失败； 每个子系统对于消息的处理方式可以更为灵活，可以选择收到消息时就处理，可以选择定时处理，也可以划分时间段按不同处理速度处理； 通知其他系统做某些事情 以我现在公司的系统为例，上述场景除了流量削峰( 偏服务端 )，其他基本都有在系统中出现。公司开发的是通信终端系统，主要模块分为: GUI, 网络, 声音，协议等, 各模块都是系统中单独的一个进程, 各个进程间需要通信，则通过发消息的方式，十分方便; 同时进程内部也通过消息队列，对相关业务量比较重的核心模块，进行代码重构、解耦, 把一些非核心流程剥离出去，通过发消息的方式通知对应模块进行处理。 封装的接口形式和 windows 端的消息机制接口类似：1234msgPostMsgToThread() // 发送到特定线程msgBroadpostThreadMsg() // 广播etl_RegisterMsgHandle(TM_TIMER, TM_TIMER, &amp;CStatusManager::OnTimerMsgProgress); //订阅 通过上述接口，我们可以很方便的通知其他进程，并携带上相应的数据，完成进程间通信。消息机制完全采用发布/订阅模式。系统一启动，首先各个进程模块进行初始化操作，每个线程/进程会创建一个消息队列，进程中的各个模块按需调用 etl_RegisterMsgHandle() 接口，订阅消息。然后系统中各进程/线程间，会进行消息的定点发送或者广播，收到消息的进程则调用初始化时注册的 handle() 接口进行处理。 发布/订阅模式 (Publish-Subscribe) 首先介绍一下不包含消息队列的发布/订阅模式，我们先引用一下 20 年前的一本经典著作 GoF 中对发布/订阅模式的介绍, 发布/订阅模式别名观察者(observer), 依赖(Dependents), 该模式是一种对象行为型模式. 模式意图： 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。 模式结构类图 (引用自: GOF设计模式解析)主要角色： Subject: 目标 Observer: 观察者 传统的观察者模式的优点： 观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。 观察者模式在观察目标和观察者之间建立一个抽象的耦合。 观察者模式支持广播通信。 观察者模式符合”开闭原则”的要求。 观察目标和观察者之间不是紧密耦合，可以说建立了一个抽象耦合，观察者是知道Subject的，Subject也一直保持对观察者进行记录。然而在包含消息队列的发布/订阅模型中，发布者和订阅者并不知道对方的存在，它们只通过消息代理进行通信，组件是松散耦合的，而且观察者模式大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法。而包含消息队列的发布-订阅模式大多数时候是异步的（使用消息队列）。观察者模式需要在单个应用程序地址空间中实现，而发布-订阅更像交叉应用模式。 传统的观察者模式与包含消息队列的发布/订阅模型模式关系类似下图： POSIX 消息队列简单使用System V API 和 POSIX API 提供了消息队列，我们主要介绍一下 POSIX 特点： POSIX 和 System V 实现中的消息队列都具有内核级持续性 POSIX 主要接口信息：123456789101112131415161718192021222324252627282930313233343536373839404142#include: mqueue.h (sys/stat.h 用于在创建队列时使用权限宏)main types:1. mqd_t: 消息队列描述符2. struct mq_attr: 消息队列属性结构，定义如下： struct mq_attr &#123; long int mq_flags; /* Message queue flags. */ long int mq_maxmsg; /* Maximum number of messages. */ long int mq_msgsize; /* Maximum message size. */ long int mq_curmsgs; /* Number of messages currently queued. */ &#125;functions： mqd_t mq_open(const char *name, int flags, ... [ mode_t mode, struct mq_attr *mq_attr ])description：name消息队列名字; flags 用来表示打开消息队列的权限组合; 如果是以创建方式打开，则需要设置相应 的访问权限mode; 设置消息队列属性 mq_attr.return：返回消息描述符，或者（mqd_t）-1出错functions： int mq_close(mdq_t mqdes) return： 成功返回 0，错误返回 -1functions： int mq_unlink(const char *name)return： 成功返回 0，错误返回 -1functions：int mq_send(mqd_t mqdes, const char *msgbuf, size_t len, unsigned int prio)return： 成功返回 0，错误返回 -1functions：size_t mq_receive(mqd_t mqdes, char *buf, size_t len, unsigned *prio)return： 成功返回 0，或者（mqd_t）-1出错functions： int mq_getattr(mqd_t mqdes, struct mq_attr *mq_attr)return： 成功返回 0，或者（mqd_t）-1出错functions：int mq_setattr(mqd_t mqdes, const struct mq_attr *mqstat, struct mq_attr *omqstat)return： 成功返回 0，或者（mqd_t）-1出错functions：int mq_setattr(mqd_t mqdes, const struct mq_attr *mqstat, struct mq_attr *omqstat)return： 成功返回 0，或者（mqd_t）-1出错functions：int mq_notify(mqd_t mqdes, const struct sigevent *sevp);description： 在有消息时注册通知return：成功返回 0，或者（mqd_t）-1出错注： 编译时需要链接 rt 库 (Link with -lrt.) 模拟使用场景：1234* 模拟场景* 1. 总共三个进程，一个程序负责创建消息队列，一个发送消息，最后一个负责接收* 2. 接收程序使用 mq_notify 注册信号来处理消息从无到有的场景* 具体实现代码如下： cmake 程序 12345678910111213cmake_minimum_required(VERSION 2.8)add_definitions(-std=c++11)project(message_queue C CXX)aux_source_directory(. SRC_FILES)add_executable(message_queue $&#123;SRC_FILES&#125;)target_link_libraries(message_queue rt ) mq_create: 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include "errno.h"#include &lt;fcntl.h&gt; /* For O_* constants */#include &lt;sys/stat.h&gt; /* For mode constants */#include &lt;mqueue.h&gt;#define ERR_EXIT(m) \ do \ &#123; \ perror(m); \ exit(EXIT_FAILURE); \ &#125; while (0);int main(int argc, char * argv[])&#123; mqd_t mqid; mqid = mq_open("/zed", O_CREAT | O_RDWR, 0666, NULL); if (mqid == (mqd_t) - 1) &#123; ERR_EXIT("mq_open"); &#125; struct mq_attr attr; mq_getattr(mqid, &amp;attr); printf("max msg numb: [%ld], mq_msgsize: [%ld] byte, current msg size: [%ld], mq_flags[%ld]", attr.mq_maxmsg, attr.mq_msgsize, attr.mq_curmsgs, attr.mq_flags); mq_close(mqid); return 0;&#125; mq_send: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include "errno.h"#include &lt;fcntl.h&gt; /* For O_* constants */#include &lt;sys/stat.h&gt; /* For mode constants */#include &lt;mqueue.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define ERR_EXIT(m) \ do \ &#123; \ perror(m); \ exit(EXIT_FAILURE); \ &#125; while (0);typedef struct stu&#123; char data[32]; int index;&#125;STU;int main(int argc, char * argv[])&#123; mqd_t mqid; mqid = mq_open("/zed", O_RDONLY); if (mqid == (mqd_t) - 1) &#123; ERR_EXIT("mq_open"); &#125; STU stu; stu.index = 20; strcpy(stu.data, "my name is yejy"); printf("stu.data [%s], stu.index [%d]\n", stu.data, stu.index); mq_send(mqid, (const char*)&amp;stu, sizeof(stu), 1); struct mq_attr attr; mq_getattr(mqid, &amp;attr); printf("max msg numb: [%ld], mq_msgsize: [%ld] byte, current msg size: [%ld], mq_flags[%ld] \n", attr.mq_maxmsg, attr.mq_msgsize, attr.mq_curmsgs, attr.mq_flags); mq_close(mqid); return 0;&#125; mq_receive: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include "errno.h"#include &lt;fcntl.h&gt; /* For O_* constants */#include &lt;sys/stat.h&gt; /* For mode constants */#include &lt;mqueue.h&gt;#include &lt;signal.h&gt;#define ERR_EXIT(m) \ do \ &#123; \ perror(m); \ exit(EXIT_FAILURE); \ &#125; while (0);typedef struct stu&#123; char data[32]; int index;&#125;STU;struct sigevent sigev;mqd_t mqid;size_t size;void handle_sigusr1(int sig)&#123; mq_notify(mqid, &amp;sigev); // need registered again STU stu; unsigned int prio; if(mq_receive(mqid, (char*)&amp;stu, size, &amp;prio) == (mqd_t) -1) &#123; ERR_EXIT("mq_receive"); &#125; printf("data=[%s], index = [%d], prio = [%d]", stu.data, stu.index, prio);&#125;int main(int argc, char * argv[])&#123; mqid = mq_open("/zed", O_RDONLY); if (mqid == (mqd_t) - 1) &#123; ERR_EXIT("mq_open"); &#125; struct mq_attr attr; mq_getattr(mqid, &amp;attr); size = attr.mq_msgsize; printf("max msg numb: [%ld], mq_msgsize: [%ld] byte, current msg size: [%ld], mq_flags[%ld]\n", attr.mq_maxmsg, attr.mq_msgsize, attr.mq_curmsgs, attr.mq_flags); // signal signal(SIGUSR1, handle_sigusr1); sigev.sigev_notify = SIGEV_SIGNAL; sigev.sigev_signo = SIGUSR1; mq_notify(mqid, &amp;sigev); // Message from nothing, notify handle for (;;); // loop keep process execute mq_close(mqid); return 0;&#125; 总结对于相关设计模式需要懂得其原理与实现，毕竟这些是前人总结出来的宝贵经验，对我们的软件设计思维非常有帮助；至于消息队列，主要介绍了一下其思想与用途，以及对 POSIX 的消息队列接口做了一个简单模拟实现，了解了消息队列的基本使用。当然，作为计算机系统中的一个重要组件，在后端开发中，有很多优秀的消息队列中间件，后续有机会从事相关开发，再进行深入了解，通过此次文章总结，如果下次遇到消息队列相关问题和开发任务，应该会比较得心应手。]]></content>
      <tags>
        <tag>多线程编程</tag>
        <tag>操作系统</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不一样的周一]]></title>
    <url>%2F2018%2F11%2F19%2F%E9%9A%8F%E7%AC%94-%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%91%A8%E4%B8%80-2018-11-19%2F</url>
    <content type="text"><![CDATA[今天是 2018-11-19 日，周一，和以往的周一不太一样，首先我旁边少了一个人，导师加主管，上周离职了，惊讶加不解。不解的是公司发展到现在不容易，而他做到这个位置同样不易，而且已经不搞技术很久了，年龄也到了不惑有一，如果离开现在公司，外面还有更好的地方可以去吗？在我的印象里，他走的就是传统的程序员模式，从程序员开始，然后做Teamleader，最后是主管，这时候无需码代码，搞技术，整天就是开这个会那个会、需求评审、项目例会等等，忙的不可开交。到了这个时候，他最大的价值就是对公司的业务了如指掌，非常熟悉，基本每个功能点他都可以摸清楚。我在想，到这种地步，应该会一直呆公司吧，毕竟如果离开，成本太大了，去到新公司，要熟悉新业务不说，可能还要重新将拾起许久技术。 当然，他能够对现在业务摸的这么清楚，而且问题分析能力很强，逻辑思维很好，表达能力也强，十分善于沟通，项目管理这一块也很熟悉，所以优点是很明显的，到了新公司，我相信他也可以十分迅速的掌握新公司的业务，走上管理岗位。 第一个导师加主管，而且还是学长，教会了我很多，扮演着引入人的角色，对我十分关照，真的非常感谢。 希望您今后工作顺利，前程似锦！后会有期！ 当然，对我来说，我其实并不喜欢主管之前的状态，完全抛开技术，做管理工作。虽然现在我还比较迷茫，但是大方向还是确定的，我还是要搞技术，只是选哪个方向罢了，我觉得技术对我来说还是比较有吸引力的，毕竟技术改变未来，笑脸！ 今天是周一，像以往一样，我会先在阮一峰老师的博客上，看看有没有什么新鲜事，他是唯一一个可以把技术博客写的如此文艺的人，感觉非常不错。 从中看到印象最深刻的，莫过于计算机科学家 Tim Bray在一篇博客中谈到自己可能退休，但是令人感叹的不是退休，而是他对事物，对工作的态度。 Rea­sons to keep work­ing I get to write soft­ware that fil­ters and routes a mil­lion mes­sages a sec­ond. 编写软件，每秒过滤路由100万个消息 I’m in a po­si­tion where it’s re­al­ly hard for peo­ple not to lis­ten to my opin­ions abouttech­nol­o­gy. I’d be­come amaz­ing­ly un­in­ter­est­ing about fif­teen sec­onds af­ter re­tir­ing. 处于一个别人很难不听取我技术意见的位置 I learn things all the time about how to think about how to use com­put­er­s. 我一直在学习思考如何使用计算机 I get a chance to move the needle, a lit­tle, on the way peo­ple use com­put­er­s. 我有机会在人们使用计算机的方式上移动一针 I like com­put­er­s, and so it makes sense to work for (what I as­sume must be) the world’s largest provider of com­put­ers to peo­ple and busi­ness­es who use them. 我喜欢计算机 现在工作中，我还无法保持这种热情，那我是不是也可以退休了? 非也，我们可以努力培养自己这方面的能力，对事物持续投入热情的能力。虽然，有的时候早上起来还处于 Some morn­ings, I feel like sleep­ing in. 状态，但我相信这只是暂时的 ！ 参考： http://www.ruanyifeng.com/blog/2018/11/weekly-issue-31.htmlhttps://dev.to/acoh3n/why-i-love-java-5c14https://phpocean.com/blog/article/learning-programming-is-different-from-learning-a-programming-language/80]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统-进程互斥和同步]]></title>
    <url>%2F2018%2F11%2F18%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5-2018-11-18%2F</url>
    <content type="text"><![CDATA[背景 为什么会有同步和互斥？ 因为计算机系统中有多个进程存在，多个进程间进行交互，会引起它们对 共享资源的访问，如果这些资源处理不当，就可能出现一些意想不到的情况，比如说 饥饿，死锁等一系列问题。为什么会出现 饥饿，死锁问题，主要还是和进程调度相关。如果进程相对独立，彼此之间没有共享资源，彼此不需要发送数据或者通知对方干某些事情，那么进程和线程的执行过程是确定的，可重复的，那就不存在上述问题。但是如果不独立，彼此间需要进行交互，那么这种情况下，由于 调度系统的管理，有可能一会先调用这个进程，一会又先调用另一个进程，由于进程调度顺序不确定，可能导致对于单个进程而言，执行过程出现不确定性和不可重复性，因此会引入一些很难发现的 bug，导致系统出现不稳定的现象。 上述现象，称为Race Condition(竞态条件)。虽然有上述问题，但是进程间交互，共享资源又是必不可少的，因此我们需要引入同步和互斥来解决上述不确定性问题。 一些基本概念 Atomic Operation (原子操作)原子操作是指一次不存在任何中断或者失败的执行。 Critical Section (临界区) ：满足互斥，前进，有限等待临界区是指进程中的一段需要访问共享资源并且当另一个进程处于相应代码区域时便不会被执行的代码区域。(简单说：访问共享资源的一段代码) Mutual exclusion (互斥)当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源。(简单说：不允许多个进程进入临界区去访问) Dead lock (死锁)两个或以上的进程，在相互等待完成特定任务，而最终没法将自身任务进行下去。(简单说：两个进程需要等待对方的资源而导致无法向下执行) Starvation (饥饿)一个可执行的进程，被调度器持续忽略，以至于虽然处于可执行状态却不被执行。 临界区代码的保护方法 (锁的设计方法) 禁用硬件中断时钟中断，进行进程调度，执行临界区时屏蔽中断 缺点： 临界区执行时间过长，对系统整体执行效率影响很大 多CPU并行执行，屏蔽一个CPU中断不管用，无法解决互斥 基于软件的解决方法除了用在一般操作系统中，也用在分布式系统当中。 皮特森(Peterson)算法flag表示本进程已经准备好了想进去，然后如果两个进程都想进那么就要设立一个turn标志，turn表示如果两个进程都想进去临界区，turn=i就允许i进程进临界区。因为turn只能是一个值，所以也保证了两个进程竞争时只能有一个进去。如果不竞争，那turn无意义。（可使用反证法证明） Dekker算法 针对双线程 Bakery算法 针对n线程临界区问题解决方案 Peterson 算法大致代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;pthread.h&gt;#define true 1#define false 0typedef int bool;bool flag[2];int turn;void procedure0()&#123; while(true) &#123; flag[0] = true; turn = 1; while(flag[1] &amp;&amp; turn == 1)//退出while循环的条件就是，要么另一个线程 //不想要使用关键区，要么此线程拥有访问权限。 &#123; sleep(1); printf("procedure0 is waiting!\n"); &#125; //critical section flag[0] = false; &#125;&#125;void procedure1()&#123; while(true) &#123; flag[1] = true; turn = 0; while(flag[0] &amp;&amp; turn == 0) &#123; sleep(1); printf("procedure1 is waiting!\n"); &#125; //critical section flag[1] = false; &#125;&#125;void main()&#123; pthread_t t1,t2; flag[0] = flag[1] = false; int err; turn = 0; err = pthread_create(&amp;t1,NULL,(void*)procedure0,NULL); if(err != 0) exit(-1); err = pthread_create(&amp;t2,NULL,(void*)procedure1,NULL); if(err != 0 ) exit(-1); pthread_join(t1,NULL); pthread_join(t2,NULL); exit(0);&#125; Dekker 算法大致代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;pthread.h&gt;#define true 1#define false 0typedef int bool;bool flag[2];int turn;void visit(int num)&#123; sleep(1); printf("P%d is visting\n",num);&#125;void P0()&#123; while(true) &#123; flag[0] = true;//P0想使用关键区。 while(flag[1])//检查P1是不是也想用？ &#123; if(turn == 1)//如果P1想用，则查看P1是否具有访问权限？ &#123; flag[0] = false;//如果有，则P0放弃。 while(turn == 1);//检查turn是否属于P1。 flag[0] = true;//P0想使用。 &#125; &#125; visit(0); //访问Critical Partition。 turn = 1; //访问完成，将权限给P1。 flag[0] = false;//P0结束使用。 &#125;&#125;void P1()&#123; while(true) &#123; flag[1] = true; //P1想使用关键区。 while(flag[0]) //检查P0是不是也想用？ &#123; if(turn == 0) //如果P0想用，则查看P0是否具有访问权限？ &#123; flag[1] = false; //如果有，则P1放弃。 while(turn == 0); //检查turn是否属于P0。 flag[1] = true; // P1想使用。 &#125; &#125; visit(1); //访问Critical Partition。 turn = 0; //访问完成，将权限给P0。 flag[1] = false; //P1结束使用。 &#125;&#125;void main()&#123; pthread_t t1,t2; flag[0] = flag[1] = false; turn = 0; int err; err = pthread_create(&amp;t1,NULL,(void*)P0,NULL); if(err != 0) exit(-1); err = pthread_create(&amp;t2,NULL,(void*)P1,NULL); if(err != 0 ) exit(-1); pthread_join(t1,NULL); pthread_join(t2,NULL); exit(0);&#125; 更高级的抽象 (基于硬件原子操作指令，将下述两个流程封装成了机器指令，执行过程中不允许执行中断和切换)Test-and-Set 12345678910111213141516171819202122boolean TestAndSet(boolean *target)&#123; boolean rv = *target; *target = TRUE; return rv;&#125;具体使用例子：class Lock&#123;int value = 0;Acquire();Realease();&#125;;Lock::Acquire()&#123;while(test-and-set(value));//spin (当有进程执行，将value设置成1，其他进程再来执行的时候就一直是1，进入while循环自旋，直到value = 0)&#125;Lock::Realease()&#123;value = 0;&#125; Exchange 123456789101112131415161718void Exchange(boolean *a, boolean *b)&#123; boolean temp = *a; *a = *b; *b = temp;&#125;共享数据： int lock = 0;线程Ti int key; do&#123; key = 1; while(key == 1) Exchange(lock, key); critical section lock = 0; remainder section &#125; 如果觉得进程自旋忙等浪费CPU性能，而且临界区执行时间较长，那可以通过上下文切换，使得等待进程进入阻塞睡眠，当临界区进程执行完，再进行唤醒。是采用忙等还是进行上下文切换让进程进入睡眠，需要看一下临界区执行时间是否很长，如果执行时间长，则让进程进入睡眠。如果临界区执行时间很短，反而上下文切换对CPU损耗时间更长，则采用忙等。 信号量同步机制，临界区多个线程和进程来执行，进入临界区只是做读操作而不是写操作，如果只是读操作，那就没必要只是限制一个进程或者线程执行，可以有多个线程或者进程执行。多个进程或线程那么就要引入信号量来解决这个问题。 数据抽象-&gt; 一个整形(sem)，两个原子操作-&gt; P(): sem减1，如果sem &lt; 0，等待，否则继续执行-&gt; V(): sem加1，如果sem &lt;= 0, 唤醒一个等待的P 信号量特点 信号量是有符号整数一开始我们会设置成一个大于 0 的数，多次进行P()操作，一旦信号量小于0，则执行P()操作的 进程不能再向下执行，该进程就需要挂在该信号量上面。直到有其他进程执行V()操作，而且信 号量还小于等于0，则判断有进程挂在该信号量上面，因此唤醒一个进程 信号量是被保护的变量-&gt; 初始化完成后，唯一改变一个信号量的值得办法是通过P()和V()-&gt; 操作必须是原子的 P() 能够阻塞, V() 不会阻塞 我们假定信号量是 “公平的”FIFO先进先出队列管理挂在信号量上面的进程 两种类型的信号量-&gt; 二进制信号量: 可以是0或者1 (可以完成锁机制功能)-&gt; 一般/计数信号量: 可取任何非负值 (允许多个执行P()操作的进程进入临界区)-&gt; 两者相互表现(给定一个可以实现另一个) 信号量可以用在2个方面-&gt; 互斥-&gt; 条件同步 (调度约束 – 一个线程等待另一个线程的事情发生) 信号量使用 (解决生产者-消费者问题)生产者-消费者正确性要求： 在任何一个时间只能有一个线程操作缓冲区(互斥) 当缓冲区为空，消费者必须等待生产者(调度/同步约束) 当缓冲区满，生产者必须等待消费者(调度/同步约束) 示例伪代码： 123456789101112131415161718192021class BoundedBuffer&#123; mutex = new Semaphore(1); fullBuffers = new Semaphore(0); // 初值为 0 emptyBuffers = new Semaphore(n); // 初值为 n &#125; BoundedBuffer::Deposit(c)&#123; emptyBuffers-&gt;P(); mutex-&gt;P(); Add c to the buffer; mutex-&gt;V(); fullBuffers-&gt;V(); &#125; BoundedBuffer::Remove(c)&#123; fullBuffers-&gt;P(); mutex-&gt;P(); Remove c to the buffer; mutex-&gt;V(); emptyBuffers-&gt;V(); &#125; 信号量的实现大致代码： 1234567891011121314151617181920class Semaphore&#123; int sem; WaitQueue q;&#125;Semaphore::P()&#123; sem--; if(sem &lt; 0)&#123; Add this thread t to q; block(t); &#125;&#125;Semaphore::V()&#123; sem++; if(sem &lt;= 0)&#123; Remove a thread t from q; wakeup(t); &#125;&#125; 管程由于信号量机制的缺点：进程自备同步操作，P(S)和V(S)操作大量分散在各个进程中，不易管理，易发生死锁。因此引入管程的概念，这是一种比信号量更高的抽象。或者说并没有这种实体存在于系统或编程语言中，更多的是一种机制，一种解决方法，但是编程语言和操作系统都提供了实现管程的重要部件条件变量。 管程特点：管程封装了同步操作，对进程隐蔽了同步细节，简化了同步功能的调用界面。用户编写并发程序如同编写顺序(串行)程序。 目的：分离互斥和条件同步的关注 什么是管程：-&gt; 一个锁：指定临界区-&gt; 0或者多个条件变量：等待通知信号量用于管理并发访问共享数据 管程具体的执行流程图进程或线程以队列方式进入临界区前，执行wait(), 如果不能满足条件变量，则将进程或线程挂在相应条件变量队列上，直到有其他进程或线程执行完临界区，执行Signal(), 唤醒相应队列中的进程或线程继续执行。 管程实现其中wait()需要释放 lock，是由于在进入管程接口时，会先加锁，确保同一时刻只能有一个进程或者线程调用。 实现生产者消费者问题 总结主要介绍了锁，信号量，管程(管程依赖于锁和条件变量)。这三种机制可以解决同步互斥问题。需要注意的是，即使是有同步互斥方法来解决这些问题，但是由于不确定性现象的存在，使得对它进行调试分析很困难，出错了需要知道是怎么错的，因为下次重复操作的时候，问题可能不会重复出现，那么这种情况下，就需要我们 仔细的去设计和分析相应的同步互斥的操作过程，才能够解决此类问题。 总的来说，想要用好同步互斥，需要我们仔细的去分析问题，设计相应的操作流程，才能够有效的解决同步互斥的问题。]]></content>
      <tags>
        <tag>多线程编程</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统--进程间通信(一)]]></title>
    <url>%2F2018%2F11%2F14%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-2018-11-14%2F</url>
    <content type="text"><![CDATA[IPC 运用范畴 配图与本文无关，纯属有趣 相对于做点什么，我们更想睡懒觉，但是相对于睡觉，我想写总结！今天把博客的 git 分支搞混了，浪费了一点时间。那么今天介绍一下进程间通信(IPC) 。进程间通信，我们从 &lt;&lt; UNIX网络编程卷2：进程间通信 &gt;&gt; 最后一章 Sun RPC 谈起，那为什么呢？ 因为我们去掌握一个东西，肯定是因为它有价值，我们才去学习，如果一些技术现在都不用了，淘汰了，那我们就没有必要去深究，只需学习其思想，浅尝辄止即可。最后一张概述部分是这样介绍的，构筑一个应用程序时，我们首先在以下两者之间作出选择： (1) 构筑一个庞大的单一程序，完成全部工作； (2) 把整个应用程序散步到彼此通信的多个进程中。如果我们选择后者，接下去的抉择是： (2a) 假设所有进程运行在同一台主机上 (允许 IPC 用于这些进程间的通信)； (2b) 假设某些进程会运行在其他主机上 (要求使用进程间某种形式的网络通信)。 这本著作主要关注的是 2a 这种情况，也就是 使用消息传递、共享内存、并可能使用某种形式的同步来进行同一台主机上的进程间 IPC。同一进程内不同线程间的 IPC 以及不同进程内各个线程间的 IPC只是这种情形的特殊情况。 而对于不同部分之间需要网络通信的应用程序则大多数使用 显示网络编程（explicit network programming)方式编写，也就是我们现在流行的 Socket编程。 那么现在是什么情况呢？ 由于互联网大火，导致现在主流热门的进程间通信方式变成了使用 Socket 套接字通信。这个也可以理解，由于互联网就是传统的 C/S(服务器端-客户端)架构，对于客户端开发来说，主要就是移动应用开发、PC端应用开发、Web 浏览器开发，这些是互联网主要的流量入口，应用和浏览器需要通信的对象就是服务器，服务器要做的也是和客户端更好的进行通信，所以如果需要从事互联网的工作，那么对 Socket 编程相对于其他 IPC 手段就需要更熟悉，特别是服务器后台开发，客户端还好，客户端业务逻辑和 UI 体验相对重要，至于一些系统层技术，开发框架都已经封装的很好了，只需掌握使用方法就可以，像android 、 IOS开发。但是如果你是从事系统开发，那么所有的 IPC 方式都需要了解，特别是消息传递、共享内存需要深入了解。 具体的 IPC 手段信号软件中断通知事件处理 例如：SIGFPE, SIGKILL, SIGUSR1, SIGSTOP, SIGCONT接收到信号会发生什么： Catch：指定信号处理函数被调用 Ignore：依靠操作系统的默认操作 example：Abort，memory dump，suspend or resume process Mask：闭塞信号，因此不会发生 可能是暂时的（处理同样类型的信号） 不足：不能传输要交换的任何数据 特点： signals are only delivered between processes when either: 仅在同一个用户的进程间传递，或者超级用户发出信号 the processes involved are run by the same user the raising process is run by a superuser signal types and type names are defined in signal.h 定义在 signal.h 文件 signals are not queued 信号没有排队 handlers “terminate process” (SIG_DFL) and “ignore signal” (SIG_IGN) are already defined in signal.h 常用终止进程和忽略信号定义在 signal.h unix 主要接口信息：12345678910#include: signal.hfunctions：void raise(int sig_type)description：用信号sig_type发信号。functions：void signal(int sig_type, void (*sig_handler)(int signal_type))description：sig_type是signal.h中定义的信号值（或名称）之一。 sig_handles是一个指向带有int参数的函数的指针。当进程被指定类型的信号命中时，此函数将在进程上下文中运行。functions：int kill(pid_t dest_pid, int sig_type)description：向使用PID dest_pid运行的进程发送sig_type类型的信号。 dest_pid的特定类型0和-1 make kill（）分别发送与发送方的同一组执行的所有进程，并发信号通知系统中运行的所有进程（仅适用于超级用户凭据)。 管道和FIFO1.管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。特点： pipes are uni-directional 半双工 with file descriptors, they can only be shared between processes with parent-child relationship 只能用于父子进程间 atomicity is guaranteed for messages shorter than PIPE_BUF bytes 特定大小缓存保持原子性 alf-open pipes are told widowed (or broken) pipes. Writing on them causes a write error, reading from them always returns 0 bytes. 坏的管道，会出现写错误，读取时，返回0字节. unix 主要接口信息：1234#include: unistd.hfunctions： int pipe(int *fd_couple) description：创建一个管道并将其文件描述符存储到fd_couple [0]（读取结束）和fd_couple [1]（写入结束）。 return： 成功返回 0，错误返回 -1 模拟使用场景，实现 Linux 系统调用 popen，主要代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869FILE * vpopen(const char * cmdstring, const char * type)&#123; int pfd[2]; FILE * fp; pid_t pid; if ((type[0] != 'r' &amp;&amp; type[0] != 'w') || type[1] != 0) &#123; errno = EINVAL; return (NULL); &#125; if(pipe(pfd) != 0) &#123; return NULL; &#125; if((pid = vfork()) &lt; 0) // vfork 相对于fork区别是: vfork需要等待子进程执行完后才开始执行，两者共享地址空间 &#123; return NULL; &#125; else if(pid == 0) // 子进程 &#123; if(*type == 'r') &#123; close(pfd[0]); if (pfd[1] != STDOUT_FILENO) &#123; dup2(pfd[1], STDOUT_FILENO); close(pfd[1]); &#125; &#125; else &#123; close(pfd[1]); if (pfd[0] != STDIN_FILENO) &#123; dup2(pfd[0], STDIN_FILENO); close(pfd[0]); &#125; &#125; if(execl("/bin/bash", "bash", "-c", cmdstring, (char *) 0) &lt; 0) &#123; return NULL; &#125; &#125; wait(0); // 等子进程结束，回收子进程 if (*type == 'r') &#123; close(pfd[1]); if ((fp = fdopen(pfd[0], type)) == NULL) &#123; return (NULL); &#125; &#125; else &#123; close(pfd[0]); if ((fp = fdopen(pfd[1], type)) == NULL) &#123; return (NULL); &#125; &#125; return (fp);&#125; 2.有名管道，FIFO，特点： 每个FIFO有一个路径名与之关联，允许无亲缘关系进程间的通信 拥有标准管道的属性和特征 unix 主要接口信息：1234* #include: sys/types.h and sys/stat.h* functions： int mkfifo(char *path, mode_t mode) * description：path是要创建的FIFO文件的（路径+）名称。 mode是文件权限（请参阅umask（2）和chmod（2））* return： 成功返回 0，错误返回非 0 模拟使用场景：1234567* 模拟场景* 1. 在 shell 端使用命令创建有名管道： mkfifo /tmp/named_pipe* 2. 运行该接口* 3. 在 shell 端写入数据到管道 ：echo "hey, this is a message" &gt; /tmp/named_pipe* 4. 测试完毕，删除管道： rm /tmp/named_pipe* * 当然我们也可以自己启动一个任意进程向FIFO管道里面写数据 具体实现代码：123456789101112131415161718192021222324252627282930313233343536373839404142int fifo_read()&#123; int pipe; char ch; static char TmpCh; /* we expect a named pipe has been created * in /tmp/named_pipe . The command * $ mkfifo /tmp/named_pipe * is a friend to get to this point */ pipe = open("/tmp/named_pipe", O_RDONLY); if (pipe &lt; 0) &#123; printf("open fifo error, maybe you should create a fifo first !\n"); exit(1); &#125; /* preparing to read from the pipe... */ printf("Waiting data from the pipe... \n"); /* reading one char a time from the pipe */ while (1) &#123; if (read(pipe, &amp;ch, 1) &lt; 0) &#123; printf("Read the pipe failed! \n"); exit(2); &#125; if(ch != TmpCh) &#123; printf("%c", ch); &#125; TmpCh = ch; &#125; /* leaving the pipe */ close(pipe); return 0;&#125; 总结上述主要对IPC做了一个大体的介绍，以及介绍了信号(signal)和管道两种IPC方式，这两者在Linux系统自带功能实现中用的较多。至于 Posix和 System V的进程间通信方式 消息队列，信号和 共享内存，由于内容较多后面再单独介绍。]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统-线程概述]]></title>
    <url>%2F2018%2F11%2F09%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0-2018-11-9%2F</url>
    <content type="text"><![CDATA[为什么使用线程 我们需要一种新的实体(线程)，既能够满足不同实体之间可以并发执行，同时可以共享相同的地址空间和文件资源等，相对于进程，减少创建和切换时的开销。 什么是线程 Thread: 进程当中的一条执行流程 从两个维度来理解进程： 从资源组合的角度：进程把一组相关的资源组合起来，构成了一个资源平台(环境)，包括地址空间(代码段，数据段)，打开的文件等各种资源。 从运行的角度：代码在这个资源平台上的一条执行流程。(这个执行流程既是线程 ) 即：线程 = 进程 - 共享资源 (完成一个控制流的管理) 1. 线程优点： 一个进程中可以同时存在多个线程 各个线程之间可以并发执行 各个线程之间可以共享地址空间和文件等资源 2.线程缺点： You have to explicitly coordinate access to shared date with locks. If you forget a lock, you’ll end up with corrupted data. (共享数据需加锁) Circular dependencies amongst locks can lead to deadlocks. (导致死锁) They are hard to debug with subtle timing issues. (执行时序不确定，难以调试) Callbacks don’t work with locks. (回调不适用于锁) It’s hard to get good performance. (很难有好的表现) They are “too hard for most programmers to use, and even for experts development is painful.” (难以使用) 上述缺点是 1995 年 John Ousterhout 在一个演说中提到的，因为当时时间较早，所以其中有些缺点，比如说难用，回调不适用于锁 (有待考证)，表现不好等，现在可能已经克服了，像 Linux 系统中 NPTL 模型实现的 pthreads 库，以及其他语言实现的多线程库，例如：java 线程库，封装的都很好，使用起来也都十分方便; 但是 共享数据需加锁，死锁, 执行时序不确定，难以调试，这三点依然是现在多线程编程中面临的最大挑战。 Attention：线程和进程比较： 进程是资源分配单位，线程是CPU调度单位； 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈，来达到独立的控制流； 线程同样具有就绪，阻塞和执行三种基本状态，同样具有状态之间的转换关系； 线程能减少并发执行的时间和空间开销：- 线程的创建时间比进程短； - 线程的终止时间比进程短； - 同一进程内的线程切换时间比进程短； - 由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信 线程的实现传统的操作系统主要有三种线程的实现方式:1. 用户线程：在用户空间实现123456789101112POSIX Pthreads， Mach C-threads, Solaris threads在用户空间实现的线程机制，它不依赖于操作系统的内核，由一组用户级线程库函数来完成线程的管理，包括线程的创建，终止，同步和调度等。* 缺点1. 一个线程发起系统调用而阻塞，则整个进程等待2. 当一个线程运行，除非主动交出CPU使用权，否则它所在进程中的其他线程将无法运行3. 由于时间片是分给进程，故与其他进程相比，在多线程执行时，每个线得到的时间片较少，执行会比较慢* 优点1. 无需用户态和内核态切换，速度快2. 允许每个进程拥有自己的调度算法 2. 内核线程：在内核中实现123windwos ，Solaris， Linux指在操作系统内核当中实现的一种线程机制，由操作系统的内核来完成线程的创建，终止和管理，开销较大 3. 轻量级进程：在内核中实现，支持用户线程123Solaris （LightWeight Process）内核支持的用户线程。一个进程可以有一个或者多个轻量级进程，每个轻量级进程由一个单独的内核线程来支持。 Linux 系统线程实现那么最新版本的 Linux 系统中的 pthreads 线程库中的线程是如何实现的呢 ? 我参考了一下书籍 &lt;&lt; Linux 内核设计与实现&gt;&gt; 以及 Linux Programmer&#39;s Manual 当中的描述, 实现流程大致如下： Linux Programmer’s Manual 描述的实现: 1234567891011121314Linux implementations of POSIX threads Over time, two threading implementations have been provided by the GNU C library on Linux: LinuxThreads This is the original Pthreads implementation. Since glibc 2.4, this implementation is no longer supported. NPTL (Native POSIX Threads Library) This is the modern Pthreads implementation. By comparison with LinuxThreads, NPTL provides closer conformance to the requirements of the POSIX.1 specification and better performance when creating large numbers of threads. NPTL is available since glibc 2.3.2, and requires features that are present in the Linux 2.6 kernel. Both of these are so-called 1:1 implementations, meaning that each thread maps to a kernel scheduling entity. Both threading implementations employ the Linux clone(2) system call. In NPTL, thread synchronization primitives (mutexes, thread joining, and so on) are implemented using the Linux futex(2) sys‐ tem call. 在 Linux 2.6 kernel 版本后, 采用的是 NPTL 模型来实现。该模型是一个所谓的 1×1 线程库，其中由用户创建的线程（通过pthread_create() 库函数）与内核中的 可调度实体（Linux中的任务）进行1-1对应，是十分简单的线程实现方式。 假如我们要在一个进程中创建四个线程, 在 Linux 系统中，实现思路是：创建四个进程并分配四个普通的 task_struct (PCB 在代码中的表示) 结构, 然后在建立这个四个进程时，指定它们共享某些资源即可。 也就是说 Linux 系统中创建进程和线程是类似的，最终都是调用 clone()，只是对外封装接口表现不一样，传入参数不一样而已。 参考 https://www.bilibili.com/video/av6538245/?p=2 https://blog.acolyer.org/2014/12/09/why-threads-are-a-bad-idea/ 书籍： &lt;&lt; Linux 内核设计与实现 &gt;&gt; -Robert Love]]></content>
      <tags>
        <tag>多线程编程</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统--进程管理(二)]]></title>
    <url>%2F2018%2F11%2F03%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%BA%8C-2018-11-3%2F</url>
    <content type="text"><![CDATA[进程状态(State) 操作系统通过维护进程状态队列，来对进程进行管理。 状态队列： 由操作系统来维护一组队列，用来表示系统当中所有进程的当前状态； 不同的状态分别用不同的队列来表示(就绪队列，各种类型的阻塞队列)； 每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生改变时，它的PCB从一个队列中脱离出来，加入到另一个队列。 进程的生命周期管理12345678910111213141516171819202122232425* 进程创建 引起进程创建的三个主要事件： * 系统初始化时;(创建init进程，负责创建其他新的进程) * 用户请求创建一个新进程； * 正在运行的进程执行了创建进程的系统调用；* 进程运行 内核选择一个就绪进程，让它占有处理机并执行（涉及相关调度算法，来满足如何选择进程何时来执行）* 进程等待 在以下情况下，进程等待(阻塞)： 1. 请求并等待系统服务，无法马上完成(例如：执行I/O，请求硬盘时) 2. 启动某种操作，无法马上完成(需要等待其他进程完成某个操作才可以执行) 3. 需要的数据没有到达 进程一旦由运行态转换成等待状态就不占有CPU了，那么其他就绪进程就可以占有CPU执行。进程等待(阻塞)只能由进程自己触发， 因为只有进程自己知道才能知道何时需要等待某种事件的发生。* 进程唤起（由阻塞态转换为就绪态） 唤醒进程的原因： 1. 被阻塞进程的需要的资源得到满足 2. 被阻塞进程等待的事件可达 3. 将该进程的PCB插入到就绪队列 进程只能被别的进程或者操作系统唤醒* 进程结束 进程的状态变化模型 进程的三种基本状态：进程在生命结束前处于且仅处于三种基本状态之一，不同系统设置的进程状态数目不同。 运行状态(Running)：当一个进程正在处理机上运行时。 就绪状态(Ready): 一个进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。 等待状态(又称阻塞状态Blocked)：一个进程正在等待某一事件而暂停运行时。如等待某资源，等待输入/输出完成。 进程的挂起模型 进程在挂起状态时，意味着进程没有占有内存空间，处在挂起状态的进程映像在磁盘上。 挂起状态： 阻塞挂起状态(Blocked-suspend)：进程在外存并等待某事件的出现 就绪挂起状态(Ready-suspend)：进程在外存，但只要进入内存即可运行 进程调度算法 FCFS: first come fist server (先来先服务) 12345优点：简单缺点：* 平均等待时间波动较大* 花费时间少的任务可能排在花费时间长的任务后面* 可能导致I/O和CPU之间的重叠处理 SPN/SRT : 短任务优先 1234567按照预测的完成时间来将任务入队。可以是可抢占的或者不可抢占的，可抢占：又叫shortest-Remaining-Time(SRT) (最短剩余时间)优点：不公平，最优平均等待时间缺点：* 优先考虑短时间进程，可能导致饥饿* 需要预知未来，如何预估进程执行时间长短(根据过去预估未来) HRRRN : 最高响应比优先 (在SPN基础上改进) 1234R = (W + S)/S W ：waiting time 等待时间S ：service time 执行时间选择R值最高的进程，充分考虑了进程等待的时间，缓解饥饿现象，不可抢占 Round Robin 轮循调度算法 123456在叫作时间切片的离散单元中分配处理器，时间片结束时，切换到下一个准备好的进程经验规则：维持上下文切换开销处于1%以内，99%的时间用在实际进程执行中优点：公平缺点：平均等待时间较差 MLFQ 多级反馈队列 1动态的根据进程执行的过程，操作系统可以根据进程具有cpu密集型和I/O密集型的特征来动态的调整进程优先级 Fair-share scheduling 公平共享调度 1使得用户的请求在不同的级别享受公平调度，是在进程级别还是用户级别或者用户组级别公平的共享进程的调度]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统--进程管理(一)]]></title>
    <url>%2F2018%2F11%2F02%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B8%80-2018-11-2%2F</url>
    <content type="text"><![CDATA[缅怀 就在昨天，MVP 的呼声响彻标靶中心球馆，步入不惑的玫瑰，拿下了生涯新高 50 分，曾经的天之骄子，风城玫瑰，NBA 历史上最年轻的常规赛 MVP，经过多年坎途，不曾在病魔面前哭泣，而在昨天却低下了头，落下了泪… 感慨万千，脑海中记着的依然是 09 年那一轮史诗级季后赛，还有那个给芝加哥带来无限希望的玫瑰。此刻，向传奇致敬！加油，罗斯！ 进程定义 一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。 说的直接一点，我们编写代码时，一个 mian() 函数的动态执行过程就是一个进程，当然还包括这个 main() 函数执行过程中使用的资源和数据。 进程的组成一个进程应该包括： 程序的代码； 程序处理的数据； 程序计数器中的值，指示下一条将运行的指令； 一组通用的寄存器的当前值，堆，栈； 一组系统资源(如内存资源，文件系统，网络等一系列资源) 总之，进程包含了正在运行的一个程序的所有状态信息。 进程与程序的关系 程序是产生进程的基础 程序的每次运行构成不同的进程 进程是程序功能的体现 通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包含多个程序。 进程与程序的区别 进程是 动态的，程序是静态的：程序是有序代码的集合；进程是程序的执行，进程有核心态用户态 进程是 暂时的，程序是永久的：进程是一个状态变化的过程，程序可长久保存 进程与程序的组成不同：进程的组成包括程序，数据和进程控制块(即进程状态信息) 进程的特点 动态性：可动态的创建，结束进程； 创建接口 fork(), 结束进程： kill 等。 并发性：进程可以被独立调度并占有处理机运行；多核并行，单核一段时间内并发执行； 独立性：不同进程的工作不相互影响；(正确性不受影响，操作系统内存管理，页表管理使得不同进程访问不同的物理内存，相互之间独立不受影响。越过地址空间会产生缺页异常。保证进程独数据独立性。) 制约性：因访问共享数据/资源或者进程间同步产生制约； 进程控制结构(PCB) 进程控制块：操作系统管理控制进程运行所用的信息集合。操作系统用PCB来描述进程的基本情况以及运行变化过程，PCB是进程存在的唯一标志。 使用进程控制块 进程的创建：为该进程生成一个PCB进程终止：回收它的PCB进程的组织管理：通过对PCB的组织管理来实现 对进程的创建，终止和管理都是通过处理PCB来完成。 PCB包含的三大类信息 进程标识信息。如本进程的标识，本进程的产生者标识(父进程标识)；用户标识。 处理机状态信息保存区。保存进程的运行现场信息： 1. 用户可见寄存器，用户程序可以使用数据，地址等寄存器。 2. 控制和状态寄存器，如程序计数器(PC)，程序状态字(PSW)。 3. 栈指针，过程调用/系统调用/中断处理和返回时需要用到它。 进程控制信息： 1. 调度和状态信息，用于操作系统调度进程并占用处理机使用。 2. 进程间通信信息，为支持进程间与通信相关的各种标识，信号，信件等，这些信息存放在接收方的进程控制块里面。 3. 存储管理信息，包含有指向本进程影像存储空间的数据结构。 4. 进程所用的资源，说明由进程打开，使用的系统资源，如打开的文件等。 5. 有关数据结构连接信息，进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB。 PCB的组织方式 链表： 同一状态的进程其 PCB 组成一个链表，多个状态对应多个不同的链表。各状态的进程形成不同的链表：就绪链表，阻塞链表。(一般采用链表，动态插入删除，开销较小) 索引表：同一状态的进程归入一个 index 表(由 index 指向 PCB )，多个状态对应多个不同的 index 表。各状态的进程形成不同的索引表：就绪索引表，阻塞索引表。(如果 PCB 个数比较固定，不会频繁插入删除，使用索引表) 参考链接 https://www.bilibili.com/video/av6538245/?p=2]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统简述]]></title>
    <url>%2F2018%2F10%2F31%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E8%BF%B0-2018-10-31%2F</url>
    <content type="text"><![CDATA[操作系统基本概念 操作系统 (operating system, 缩写 OS)，是指控制和管理整个计算机系统的硬件和软件资源，合理地组织调度计算机的工作和资源的分配的集合，为用户和底层硬件之间的桥梁。对于程序员来说，操作系统是工作场地，是应用程序控制底层硬件接口的提供者。 操作系统启动以 Linux 为例，一开始操作系统是存放在 Disk 上面的，然后再由 BIOS（基本I/O处理系统）检测我们计算机操作系统的各种外设，检测完，如果外设正常，再将一个 bootloader 小程序由 Disk 加载到内存中去，bootloader (512个字节) 负责将操作系统加载到内存，最终操作系统开始正常工作。 操作系统启动后，如何与外设和应用程序交互呢？ 外设是通过中断和I/O来处理的，至于应用程序，是通过系统调用和异常来提供相应功能。中断，异常，系统调用三者就是操作系统同应用程序和底层硬件之间交互手段，三者具体定义如下： 系统调用（来源于应用程序)应用程序主动向操作系统发出服务请求。系统调用会触发”用户态”到”内核态”的一个转换。”用户态”指的是应用程序在运行过程中， cpu 所处的一个特权级状态，权限较低，不能直接访问特殊的机器指令和 I/O ; “内核态”指的是操作系统运行过程中 cpu 所指的一个状态，权限较高，该状态下，操作系统可以执行任何一条指令，包括特权指令，访问 I/O 指令。这种机制使得系统安全性可以得到保证。系统调用付出的代价主要是执行的开销相对普通函数调用较大 (切换堆栈，用户态切换内核态)。Windows 应用 WIN32 APIPOSIX-based systems 应用 POSIX API（包括unix，Linux，mac os x的所有版本） 异常（来源于不良的应用程序）非法指令或者其他坏的处理状态。（如：内存出错） 操作系统需要保存现场，然后处理异常，接着杀死异常程序或重新执行异常程序。 中断（来源于外设）来自不同的硬件设备的计时器和网络中断 。中断向量表中保存有各个外设的中断编号和相应的中断服务例程地址，操作系统收到中断编号，查表，然后转到相应地址执行服务例程，这个时候操作系统需要保存当前处理状态，处理完中断再恢复现场。 操作系统特征 并发 (Concurrence) 并发： 一个时间段内，多个程序在运行。并行：同一个时间点上，多个程序在运行，需要多核cpu来完成。操作系统特征之一就是并发，同时存在多个运行程序，需要通过操作系统来进行调度。 共享 （Sharing) 对于硬件资源，内存资源和相关外设等”同时”访问，共同使用，实际上是互斥共享。 虚拟 （Virtual) 虚拟是指 把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实的，即实际存在的；而后者是虚的，是用户感觉上的事物。用于实现虚拟的技术，称为虚拟技术。在操作系统中利用了多种虚拟技术，分别用来实现虚拟处理器、虚拟内存和虚拟外部设备。 在虚拟处理器技术中，是 通过多道程序设计技术，让多道程序并发执行的方法，来分时使用一个处理器的。此时，虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个中央处理器（CPU) 在专门为它服务。利用多道程序设计技术，把一个物理上的CPU虚拟为多个逻辑上的 CPU，称为虚拟处理器。 类似地，可以通过虚拟存储器技术，将一台机器的物理存储器变为虚拟存储器，以便从逻辑上来扩充存储器的容量。当然,这时用户所感觉到的内存容量是虚的。我们把用户所感觉到的存储器（实际是不存在的）称为虚拟存储器。 还可以通过虚拟设备技术，将一台物理 I/O 设备虚拟为多台逻辑上的I/O设备，并允许每个用户占用一台逻辑上的 I/O 设备，这样便可以 使原来仅允许在一段时间内由一个用户访问的设备（即临界资源)，变为在一段时间内允许多个用户同时访问的共享设备。因此，操作系统的虚拟技术可归纳为：时分复用技术，如处理器的分时共享；空分复用技术，如虚拟存储器 异步 (Asynchronism) 程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知，但只要运行环境相同，操作系统需要保证程序运行结果也相同。异步使得操作系统运行在一种随机的环境下，可能导致进程产生与时间有关的错误 (就像对全局变量的访问顺序不当会导致程序出错一样）。 Linux 系统组成 上图是 Linux 操作系统内核组成图，从中我们可以看到，操作系统主要功能为以下四个，那么后面文章中会一一深入介绍！ 进程管理（Processing management） 内存管理（Memory management） 文件系统（File system） 网络通信（Networking） 参考链接 https://www.bilibili.com/video/av6538245/?p=2https://blog.csdn.net/bigpudding24/article/details/48603301]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于这个博客]]></title>
    <url>%2F2018%2F10%2F27%2F2018-10-29%2F</url>
    <content type="text"><![CDATA[hello 花了两三天时间，搭建了一个自己的博客，在阿里云买了人生中第一个域名 mikeblog.top，基本框架用的是hexo+githubpage，这个网上教程很多，也很详细，我就不介绍详细过程了，在这里十分感谢其他博主的分享，也感谢这两个平台，让我在互联网上有了一个自己的小栖息地，说实话，感觉像有了一个自己的家。第一篇博客，当然是用来解释前世今生，立flag用的，我为什么要弄一个博客呢？这个博客以后是用来干啥的呢？ 博客搭建自己博客的原因大概今年5月份，开始有了持续更新博客的念头，原因主要有两个，不对应该是三个。 原因一一是工作上的原因，工作差不多快两年了，期间接触到的，学习到的东西很多，然后每次想起自己在技术上的积累时，总是这个懂，那个也懂，但是要你很系统的表达出来，却又做不到，显得很凌乱。所以，好记性不如烂笔头，想通过写博客来对自己已掌握的，或者掌握的不牢固的技术点进行总结和提升, 成体系化，并且分享出来，分享也算是一种变相的激励，需要你去对所分享的东西进行 深层次的熟悉和了解，如果能帮助到有缘人，那是极好的。 原因二第二个原因，是想记录下一些关于自己的文字，想要更了解自己，我想应该没有什么是比文字更能描绘一个人的了，记录自己对工作对行业的了解和看法，以及自己三观的演变。 原因三第三个是因为博客园对Markdown的支持实在让我不能忍，还有博客相关的UI界面体验，实在不敢恭维。国内比较出名的技术网站，博客园和CSDN，持续时间久，上面积累的技术博客和资源确实很多，有很多质量也很不错，很多技术大牛都有在上面分享的经历，但是呢，最后都离开了，这肯定是有原因的。 最重要的，当然是 freedom 了，自己的博客没有这么多条条框框，比较自由，可以按照自己的想法来开发集成，加功能，选择自己喜欢的风格，好的开源框架这么多，不用白不用是吧。 博客记录的主要内容我当前干的活，主要是应用软件开发(平台：linux, android), 主要语言C/C++, 脚本语言shell, 主要做逻辑层和基础库这一块，为多个平台提供库和通用API，至于UI框架这一块，接触的比较少，要说接触过的应该就Qt了，但是不深入。后续博客记录的主要内容短期会聚焦在: Linux 系统 ：多进程/多线程, 内存, I/O, 网络 (I/O和网络需加强) C++/C++11/C++17 : STL库分析总结; C++11/17 新增特性分析 编译链接相关： make/cmake, 动态库链接 脚本语言： shell, python git：持续集成 (CI) 当然，因为现在工作上到了迷茫期，正在考虑方向上的事情，所以后面记录的东西也可能会随之改变 ！ 12345678910111213141516171819202122232425/* Add a new node to the list, to head, containing the specified 'value' * pointer as value. * * On error, NULL is returned and no operation is performed (i.e. the * list remains unaltered). * On success the 'list' pointer you pass to the function is returned. */list *listAddNodeHead(list *list, void *value)&#123; listNode *node; if ((node = zmalloc(sizeof(*node))) == NULL) return NULL; node-&gt;value = value; if (list-&gt;len == 0) &#123; list-&gt;head = list-&gt;tail = node; node-&gt;prev = node-&gt;next = NULL; &#125; else &#123; node-&gt;prev = NULL; node-&gt;next = list-&gt;head; list-&gt;head-&gt;prev = node; list-&gt;head = node; &#125; list-&gt;len++; return list;&#125; 测试一下代码显示效果，笑脸。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
