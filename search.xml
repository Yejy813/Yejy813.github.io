<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[操作系统简述]]></title>
    <url>%2F2018%2F10%2F31%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E8%BF%B0-2018-10-31%2F</url>
    <content type="text"><![CDATA[操作系统基本概念 操作系统 (operating system, 缩写 OS)，是指控制和管理整个计算机系统的硬件和软件资源，合理地组织调度计算机的工作和资源的分配的集合，为用户和底层硬件之间的桥梁。对于程序员来说，操作系统是工作场地，是应用程序控制底层硬件接口的提供者。 操作系统启动以 Linux 为例，一开始操作系统是存放在 Disk 上面的，然后再由 BIOS（基本I/O处理系统）检测我们计算机操作系统的各种外设，检测完，如果外设正常，再将一个 bootloader 小程序由 Disk 加载到内存中去，bootloader (512个字节) 负责将操作系统加载到内存，最终操作系统开始正常工作。 操作系统启动后，如何与外设和应用程序交互呢？ 外设是通过中断和I/O来处理的，至于应用程序，是通过系统调用和异常来提供相应功能。中断，异常，系统调用三者就是操作系统同应用程序和底层硬件之间交互手段，三者具体定义如下： 系统调用（来源于应用程序)应用程序主动向操作系统发出服务请求。系统调用会触发”用户态”到”内核态”的一个转换。”用户态”指的是应用程序在运行过程中， cpu 所处的一个特权级状态，权限较低，不能直接访问特殊的机器指令和 I/O ; “内核态”指的是操作系统运行过程中 cpu 所指的一个状态，权限较高，该状态下，操作系统可以执行任何一条指令，包括特权指令，访问 I/O 指令。这种机制使得系统安全性可以得到保证。系统调用付出的代价主要是执行的开销相对普通函数调用较大 (切换堆栈，用户态切换内核态)。Windows 应用 WIN32 APIPOSIX-based systems 应用 POSIX API（包括unix，Linux，mac os x的所有版本） 异常（来源于不良的应用程序）非法指令或者其他坏的处理状态。（如：内存出错） 操作系统需要保存现场，然后处理异常，接着杀死异常程序或重新执行异常程序。 中断（来源于外设）来自不同的硬件设备的计时器和网络中断 。中断向量表中保存有各个外设的中断编号和相应的中断服务例程地址，操作系统收到中断编号，查表，然后转到相应地址执行服务例程，这个时候操作系统需要保存当前处理状态，处理完中断再恢复现场。 操作系统特征 并发 (Concurrence) 并发： 一个时间段内，多个程序在运行。并行：同一个时间点上，多个程序在运行，需要多核cpu来完成。操作系统特征之一就是并发，同时存在多个运行程序，需要通过操作系统来进行调度。 共享 （Sharing) 对于硬件资源，内存资源和相关外设等”同时”访问，共同使用，实际上是互斥共享。 虚拟 （Virtual) 虚拟是指 把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实的，即实际存在的；而后者是虚的，是用户感觉上的事物。用于实现虚拟的技术，称为虚拟技术。在操作系统中利用了多种虚拟技术，分别用来实现虚拟处理器、虚拟内存和虚拟外部设备。 在虚拟处理器技术中，是 通过多道程序设计技术，让多道程序并发执行的方法，来分时使用一个处理器的。此时，虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个中央处理器（CPU) 在专门为它服务。利用多道程序设计技术，把一个物理上的CPU虚拟为多个逻辑上的 CPU，称为虚拟处理器。 类似地，可以通过虚拟存储器技术，将一台机器的物理存储器变为虚拟存储器，以便从逻辑上来扩充存储器的容量。当然,这时用户所感觉到的内存容量是虚的。我们把用户所感觉到的存储器（实际是不存在的）称为虚拟存储器。 还可以通过虚拟设备技术，将一台物理 I/O 设备虚拟为多台逻辑上的I/O设备，并允许每个用户占用一台逻辑上的 I/O 设备，这样便可以 使原来仅允许在一段时间内由一个用户访问的设备（即临界资源)，变为在一段时间内允许多个用户同时访问的共享设备。因此，操作系统的虚拟技术可归纳为：时分复用技术，如处理器的分时共享；空分复用技术，如虚拟存储器 异步 (Asynchronism) 程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知，但只要运行环境相同，操作系统需要保证程序运行结果也相同。异步使得操作系统运行在一种随机的环境下，可能导致进程产生与时间有关的错误 (就像对全局变量的访问顺序不当会导致程序出错一样）。 Linux 系统组成 上图是 Linux 操作系统内核组成图，从中我们可以看到，操作系统主要功能为以下四个，那么后面文章中会一一深入介绍！ 进程管理（Processing management） 内存管理（Memory management） 文件系统（File system） 网络通信（Networking） 参考链接 https://www.bilibili.com/video/av6538245/?p=2https://blog.csdn.net/bigpudding24/article/details/48603301]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于这个博客]]></title>
    <url>%2F2018%2F10%2F27%2F2018-10-29%2F</url>
    <content type="text"><![CDATA[花了两三天时间，搭建了一个自己的博客，在阿里云买了人生中第一个域名 mikeblog.top，基本框架用的是hexo+githubpage，这个网上教程很多，也很详细，我就不介绍详细过程了，在这里十分感谢其他博主的分享，也感谢这两个平台，让我在互联网上有了一个自己的小栖息地，说实话，感觉像有了一个自己的家。第一篇博客，当然是用来解释前世今生，立flag用的，我为什么要弄一个博客呢？这个博客以后是用来干啥的呢？ 搭建自己博客的原因大概今年5月份，开始有了持续更新博客的念头，原因主要有两个，不对应该是三个。 原因一一是工作上的原因，工作差不多快两年了，期间接触到的，学习到的东西很多，然后每次想起自己在技术上的积累时，总是这个懂，那个也懂，但是要你很系统的表达出来，却又做不到，显得很凌乱。所以，好记性不如烂笔头，想通过写博客来对自己已掌握的，或者掌握的不牢固的技术点进行总结和提升, 成体系化，并且分享出来，分享也算是一种变相的激励，需要你去对所分享的东西进行 深层次的熟悉和了解，如果能帮助到有缘人，那是极好的。 原因二第二个原因，是想记录下一些关于自己的文字，想要更了解自己，我想应该没有什么是比文字更能描绘一个人的了，记录自己对工作对行业的了解和看法，以及自己三观的演变。 原因三第三个是因为博客园对Markdown的支持实在让我不能忍，还有博客相关的UI界面体验，实在不敢恭维。国内比较出名的技术网站，博客园和CSDN，持续时间久，上面积累的技术博客和资源确实很多，有很多质量也很不错，很多技术大牛都有在上面分享的经历，但是呢，最后都离开了，这肯定是有原因的。 最重要的，当然是 freedom 了，自己的博客没有这么多条条框框，比较自由，可以按照自己的想法来开发集成，加功能，选择自己喜欢的风格，好的开源框架这么多，不用白不用是吧。 博客记录的主要内容我当前干的活，主要是应用软件开发(平台：linux, android), 主要语言C/C++, 脚本语言shell, 主要做逻辑层和基础库这一块，为多个平台提供库和通用API，至于UI框架这一块，接触的比较少，要说接触过的应该就Qt了，但是不深入。后续博客记录的主要内容短期会聚焦在: Linux 系统 ：多进程/多线程, 内存, I/O, 网络 (I/O和网络需加强) C++/C++11/C++17 : STL库分析总结; C++11/17 新增特性分析 编译链接相关： make/cmake, 动态库链接 脚本语言： shell, python git：持续集成 (CI) 当然，因为现在工作上到了迷茫期，正在考虑方向上的事情，所以后面记录的东西也可能会随之改变 ！ 12345678910111213141516171819202122232425/* Add a new node to the list, to head, containing the specified 'value' * pointer as value. * * On error, NULL is returned and no operation is performed (i.e. the * list remains unaltered). * On success the 'list' pointer you pass to the function is returned. */list *listAddNodeHead(list *list, void *value)&#123; listNode *node; if ((node = zmalloc(sizeof(*node))) == NULL) return NULL; node-&gt;value = value; if (list-&gt;len == 0) &#123; list-&gt;head = list-&gt;tail = node; node-&gt;prev = node-&gt;next = NULL; &#125; else &#123; node-&gt;prev = NULL; node-&gt;next = list-&gt;head; list-&gt;head-&gt;prev = node; list-&gt;head = node; &#125; list-&gt;len++; return list;&#125; 测试一下代码显示效果，笑脸。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
